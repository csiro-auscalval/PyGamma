from pathlib import Path
from typing import Sequence, NamedTuple, Dict, Optional
from collections import Counter

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# WARNING: This file is automatically generated!
# See utils/gamma_usage2py.py
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

PyGammaCall = NamedTuple(
    "PyGammaCall",
    [
        ("module", str),
        ("program", str),
        ("parameters", Dict[str, object]),
        ("status", int),
    ],
)


class SimpleParFile(object):
    values = {}

    def __init__(self, path):
        with open(path, "r") as file:
            lines = file.read().splitlines()[1:]  # Skip header lines

            for line in lines:
                value_id = line.split(":")[0]
                if len(value_id.strip()) == 0:
                    continue

                value_data = line[len(value_id) + 2 :].strip()

                self.values[value_id] = value_data

    def get_value(self, value_id: str, dtype=str, index: Optional[int] = None):
        def attempt_convert(val):
            try:
                return dtype(val)
            except:
                return val

        if index is not None:
            return attempt_convert(self.values[value_id].split()[index])
        else:
            return [attempt_convert(i) for i in self.values[value_id].split()]


class PyGammaTestProxy(object):
    ParFile = SimpleParFile

    call_sequence: Sequence[PyGammaCall]
    call_count: Counter
    error_count: int

    _exception_type: type
    _wraps: object
    _fail_reason: str

    def __init__(self, exception_type=None, wraps=None):
        self.reset_proxy()
        self._exception_type = exception_type
        self._wraps = wraps

    def reset_proxy(self):
        self.call_sequence = []
        self.call_count = Counter()
        self.error_count = 0
        self._fail_reason = None

    def _validate(self, cmd, condition, result, fail_reason):
        stat, stdout, stderr = result

        self.error_count += 0 if condition else 1
        stat = stat if condition else -1
        self._fail_reason = self._fail_reason if condition else fail_reason
        # TODO: stderr?

        return stat, stdout, stderr

    def _on_error(self, cmd, params, status):
        if status is None or status == 0:
            return

        if self._exception_type is None:
            return

        raise self._exception_type(f"failed to execute pg.{cmd} ({self._fail_reason})")

    def gc_map_fine(self, gc_in: str, width, DIFF_par, gc_out: str, ref_flg=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gc_map_fine"] += 1

        if gc_in is not None:
            result = self._validate(
                "gc_map_fine",
                gc_in == "-" or Path(gc_in).exists(),
                result,
                f"gc_in path does not exist ({gc_in})",
            )
        if gc_out is not None and gc_out != "-":
            Path(gc_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "gc_map_fine",
            ref_flg == "-" or ref_flg in valid_values,
            result,
            f"ref_flg is not a valid value (expects: {valid_values}, got: {ref_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.gc_map_fine(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gc_map_fine", supplied_args, result[0])
        )
        self._on_error("gc_map_fine", supplied_args, result[0])
        return result

    def diff_ls_fit(
        self,
        unw_1: str,
        unw_2: str,
        DIFF_par: str,
        nr=None,
        naz=None,
        mask=None,
        plot_data: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["diff_ls_fit"] += 1

        if unw_1 is not None:
            result = self._validate(
                "diff_ls_fit",
                unw_1 == "-" or Path(unw_1).exists(),
                result,
                f"unw_1 path does not exist ({unw_1})",
            )
        if unw_2 is not None:
            result = self._validate(
                "diff_ls_fit",
                unw_2 == "-" or Path(unw_2).exists(),
                result,
                f"unw_2 path does not exist ({unw_2})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "diff_ls_fit",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if plot_data is not None and plot_data != "-":
            Path(plot_data).touch()
        if self._wraps is not None:
            result = self._wraps.diff_ls_fit(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "diff_ls_fit", supplied_args, result[0])
        )
        self._on_error("diff_ls_fit", supplied_args, result[0])
        return result

    def WSS_mosaic(self, WSS_tab: str, MLI_par: str, WSS_data: str, type):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["WSS_mosaic"] += 1

        if WSS_tab is not None:
            result = self._validate(
                "WSS_mosaic",
                WSS_tab == "-" or Path(WSS_tab).exists(),
                result,
                f"WSS_tab path does not exist ({WSS_tab})",
            )
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if WSS_data is not None and WSS_data != "-":
            Path(WSS_data).touch()
        valid_values = [0, 1]
        result = self._validate(
            "WSS_mosaic",
            type == "-" or type in valid_values,
            result,
            f"type is not a valid value (expects: {valid_values}, got: {type})",
        )
        if self._wraps is not None:
            result = self._wraps.WSS_mosaic(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "WSS_mosaic", supplied_args, result[0])
        )
        self._on_error("WSS_mosaic", supplied_args, result[0])
        return result

    def dispmap_vec_offset(
        self,
        DEM_par: str,
        DEM: str,
        dispmap_r,
        dispmap_az,
        lv_theta,
        lv_phi,
        dv_norm: str,
        dv_theta: str = None,
        dv_phi: str = None,
        dv_x: str = None,
        dv_y: str = None,
        dv_z: str = None,
        mask_angle=None,
        mode=None,
        ax_north=None,
        ax_east=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dispmap_vec_offset"] += 1

        if DEM_par is not None:
            result = self._validate(
                "dispmap_vec_offset",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "dispmap_vec_offset",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if dv_norm is not None and dv_norm != "-":
            Path(dv_norm).touch()
        if dv_theta is not None and dv_theta != "-":
            Path(dv_theta).touch()
        if dv_phi is not None and dv_phi != "-":
            Path(dv_phi).touch()
        if dv_x is not None and dv_x != "-":
            Path(dv_x).touch()
        if dv_y is not None and dv_y != "-":
            Path(dv_y).touch()
        if dv_z is not None and dv_z != "-":
            Path(dv_z).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dispmap_vec_offset",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.dispmap_vec_offset(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dispmap_vec_offset", supplied_args, result[0])
        )
        self._on_error("dispmap_vec_offset", supplied_args, result[0])
        return result

    def create_diff_par(
        self, PAR_1: str, PAR_2: str, DIFF_par: str, PAR_type=None, iflg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["create_diff_par"] += 1

        if PAR_1 is not None:
            result = self._validate(
                "create_diff_par",
                PAR_1 == "-" or Path(PAR_1).exists(),
                result,
                f"PAR_1 path does not exist ({PAR_1})",
            )
        if PAR_2 is not None:
            result = self._validate(
                "create_diff_par",
                PAR_2 == "-" or Path(PAR_2).exists(),
                result,
                f"PAR_2 path does not exist ({PAR_2})",
            )
        if DIFF_par is not None and DIFF_par != "-" and not Path(DIFF_par).exists():
            Path(DIFF_par).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "create_diff_par",
            PAR_type == "-" or PAR_type in valid_values,
            result,
            f"PAR_type is not a valid value (expects: {valid_values}, got: {PAR_type})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "create_diff_par",
            iflg == "-" or iflg in valid_values,
            result,
            f"iflg is not a valid value (expects: {valid_values}, got: {iflg})",
        )
        if self._wraps is not None:
            result = self._wraps.create_diff_par(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "create_diff_par", supplied_args, result[0])
        )
        self._on_error("create_diff_par", supplied_args, result[0])
        return result

    def gc_map_grd(
        self,
        MLI_par: str,
        DEM_par: str,
        DEM: str,
        DEM_seg_par: str,
        DEM_seg: str,
        lookup_table: str,
        lat_ovr=None,
        lon_ovr=None,
        sim_sar: str = None,
        u: str = None,
        v: str = None,
        inc: str = None,
        psi: str = None,
        pix: str = None,
        ls_map: str = None,
        frame=None,
        ls_mode=None,
        r_ovr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gc_map_grd"] += 1

        if MLI_par is not None:
            result = self._validate(
                "gc_map_grd",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "gc_map_grd",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "gc_map_grd",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if (
            DEM_seg_par is not None
            and DEM_seg_par != "-"
            and not Path(DEM_seg_par).exists()
        ):
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "gc_map_grd",
            ls_mode == "-" or ls_mode in valid_values,
            result,
            f"ls_mode is not a valid value (expects: {valid_values}, got: {ls_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.gc_map_grd(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gc_map_grd", supplied_args, result[0])
        )
        self._on_error("gc_map_grd", supplied_args, result[0])
        return result

    def multi_mosaic(
        self, data_tab: str, data_out: str, DEM_par_out: str, mode, format_flag
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_mosaic"] += 1

        if data_tab is not None:
            result = self._validate(
                "multi_mosaic",
                data_tab == "-" or Path(data_tab).exists(),
                result,
                f"data_tab path does not exist ({data_tab})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if DEM_par_out is not None and DEM_par_out != "-":
            Path(DEM_par_out).touch()
        valid_values = [0, 1]
        result = self._validate(
            "multi_mosaic",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1, 2, 3, 4, 5]
        result = self._validate(
            "multi_mosaic",
            format_flag == "-" or format_flag in valid_values,
            result,
            f"format_flag is not a valid value (expects: {valid_values}, got: {format_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.multi_mosaic(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "multi_mosaic", supplied_args, result[0])
        )
        self._on_error("multi_mosaic", supplied_args, result[0])
        return result

    def gc_map1(
        self,
        MLI_par: str,
        OFF_par: str,
        DEM_par: str,
        DEM: str,
        DEM_seg_par: str,
        DEM_seg: str,
        lookup_table: str,
        lat_ovr=None,
        lon_ovr=None,
        sim_sar: str = None,
        u: str = None,
        v: str = None,
        inc: str = None,
        psi: str = None,
        pix: str = None,
        ls_map: str = None,
        frame=None,
        ls_mode=None,
        r_ovr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gc_map1"] += 1

        if MLI_par is not None:
            result = self._validate(
                "gc_map1",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "gc_map1",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "gc_map1",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "gc_map1",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if (
            DEM_seg_par is not None
            and DEM_seg_par != "-"
            and not Path(DEM_seg_par).exists()
        ):
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "gc_map1",
            ls_mode == "-" or ls_mode in valid_values,
            result,
            f"ls_mode is not a valid value (expects: {valid_values}, got: {ls_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.gc_map1(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gc_map1", supplied_args, result[0])
        )
        self._on_error("gc_map1", supplied_args, result[0])
        return result

    def SLC_diff_intf(
        self,
        SLC_1: str,
        SLC_2R: str,
        SLC1_par: str,
        SLC2R_par: str,
        OFF_par: str,
        sim_unw,
        diff_int: str,
        rlks,
        azlks,
        sps_flg=None,
        azf_flg=None,
        rbw_min=None,
        rp1_flg=None,
        rp2_flg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_diff_intf"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "SLC_diff_intf",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2R is not None:
            result = self._validate(
                "SLC_diff_intf",
                SLC_2R == "-" or Path(SLC_2R).exists(),
                result,
                f"SLC_2R path does not exist ({SLC_2R})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_diff_intf",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2R_par is not None:
            result = self._validate(
                "SLC_diff_intf",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "SLC_diff_intf",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if diff_int is not None and diff_int != "-":
            Path(diff_int).touch()
        valid_values = [1, 0] + [None]
        result = self._validate(
            "SLC_diff_intf",
            sps_flg == "-" or sps_flg in valid_values,
            result,
            f"sps_flg is not a valid value (expects: {valid_values}, got: {sps_flg})",
        )
        valid_values = [1, 0] + [None]
        result = self._validate(
            "SLC_diff_intf",
            azf_flg == "-" or azf_flg in valid_values,
            result,
            f"azf_flg is not a valid value (expects: {valid_values}, got: {azf_flg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_diff_intf",
            rp1_flg == "-" or rp1_flg in valid_values,
            result,
            f"rp1_flg is not a valid value (expects: {valid_values}, got: {rp1_flg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_diff_intf",
            rp2_flg == "-" or rp2_flg in valid_values,
            result,
            f"rp2_flg is not a valid value (expects: {valid_values}, got: {rp2_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_diff_intf(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "SLC_diff_intf", supplied_args, result[0])
        )
        self._on_error("SLC_diff_intf", supplied_args, result[0])
        return result

    def pixel_area(
        self,
        MLI_par: str,
        DEM_par: str,
        DEM: str,
        lookup_table: str,
        ls_map: str,
        inc_map: str,
        pix_sigma0: str,
        pix_gamma0: str = None,
        nstep=None,
        area_fact=None,
        sigma0_ratio: str = None,
        gamma0_ratio: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["pixel_area"] += 1

        if MLI_par is not None:
            result = self._validate(
                "pixel_area",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "pixel_area",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "pixel_area",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if lookup_table is not None:
            result = self._validate(
                "pixel_area",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        if ls_map is not None:
            result = self._validate(
                "pixel_area",
                ls_map == "-" or Path(ls_map).exists(),
                result,
                f"ls_map path does not exist ({ls_map})",
            )
        if inc_map is not None:
            result = self._validate(
                "pixel_area",
                inc_map == "-" or Path(inc_map).exists(),
                result,
                f"inc_map path does not exist ({inc_map})",
            )
        if pix_sigma0 is not None and pix_sigma0 != "-":
            Path(pix_sigma0).touch()
        if pix_gamma0 is not None and pix_gamma0 != "-":
            Path(pix_gamma0).touch()
        if sigma0_ratio is not None and sigma0_ratio != "-":
            Path(sigma0_ratio).touch()
        if gamma0_ratio is not None and gamma0_ratio != "-":
            Path(gamma0_ratio).touch()
        if self._wraps is not None:
            result = self._wraps.pixel_area(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "pixel_area", supplied_args, result[0])
        )
        self._on_error("pixel_area", supplied_args, result[0])
        return result

    def extract_gcp(
        self, DEM_rdc: str, OFF_par: str, GCP: str, nr, naz, mask: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["extract_gcp"] += 1

        if DEM_rdc is not None:
            result = self._validate(
                "extract_gcp",
                DEM_rdc == "-" or Path(DEM_rdc).exists(),
                result,
                f"DEM_rdc path does not exist ({DEM_rdc})",
            )
        if OFF_par is not None:
            result = self._validate(
                "extract_gcp",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if GCP is not None and GCP != "-":
            Path(GCP).touch()
        if mask is not None:
            result = self._validate(
                "extract_gcp",
                mask == "-" or Path(mask).exists(),
                result,
                f"mask path does not exist ({mask})",
            )
        if self._wraps is not None:
            result = self._wraps.extract_gcp(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "extract_gcp", supplied_args, result[0])
        )
        self._on_error("extract_gcp", supplied_args, result[0])
        return result

    def gc_map2(
        self,
        MLI_par: str,
        DEM_par: str,
        DEM: str,
        DEM_seg_par: str = None,
        DEM_seg: str = None,
        lookup_table: str = None,
        lat_ovr=None,
        lon_ovr=None,
        ls_map: str = None,
        ls_map_rdc: str = None,
        inc: str = None,
        res: str = None,
        offnadir: str = None,
        sim_sar: str = None,
        u: str = None,
        v: str = None,
        psi: str = None,
        pix: str = None,
        r_ovr=None,
        az_dec=None,
        mask=None,
        frame=None,
        ls_scaling=None,
        DIFF_par: str = None,
        ref_flg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gc_map2"] += 1

        if MLI_par is not None:
            result = self._validate(
                "gc_map2",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "gc_map2",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "gc_map2",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if DEM_seg_par is not None and DEM_seg_par != "-":
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()
        if ls_map_rdc is not None and ls_map_rdc != "-":
            Path(ls_map_rdc).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if res is not None and res != "-":
            Path(res).touch()
        if offnadir is not None and offnadir != "-":
            Path(offnadir).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "gc_map2",
            mask == "-" or mask in valid_values,
            result,
            f"mask is not a valid value (expects: {valid_values}, got: {mask})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "gc_map2",
            ls_scaling == "-" or ls_scaling in valid_values,
            result,
            f"ls_scaling is not a valid value (expects: {valid_values}, got: {ls_scaling})",
        )
        if DIFF_par is not None:
            result = self._validate(
                "gc_map2",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "gc_map2",
            ref_flg == "-" or ref_flg in valid_values,
            result,
            f"ref_flg is not a valid value (expects: {valid_values}, got: {ref_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.gc_map2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gc_map2", supplied_args, result[0])
        )
        self._on_error("gc_map2", supplied_args, result[0])
        return result

    def dem_trans(
        self,
        DEM1_par: str,
        DEM1: str,
        DEM2_par: str,
        DEM2: str,
        lat_ovr=None,
        lon_ovr=None,
        datum_shift=None,
        bflg=None,
        lookup_table: str = None,
        interp_mode=None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dem_trans"] += 1

        if DEM1_par is not None:
            result = self._validate(
                "dem_trans",
                DEM1_par == "-" or Path(DEM1_par).exists(),
                result,
                f"DEM1_par path does not exist ({DEM1_par})",
            )
        if DEM1 is not None:
            result = self._validate(
                "dem_trans",
                DEM1 == "-" or Path(DEM1).exists(),
                result,
                f"DEM1 path does not exist ({DEM1})",
            )
        if DEM2_par is not None and DEM2_par != "-" and not Path(DEM2_par).exists():
            Path(DEM2_par).touch()
        if DEM2 is not None and DEM2 != "-":
            Path(DEM2).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dem_trans",
            datum_shift == "-" or datum_shift in valid_values,
            result,
            f"datum_shift is not a valid value (expects: {valid_values}, got: {datum_shift})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dem_trans",
            bflg == "-" or bflg in valid_values,
            result,
            f"bflg is not a valid value (expects: {valid_values}, got: {bflg})",
        )
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "dem_trans",
            interp_mode == "-" or interp_mode in valid_values,
            result,
            f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.dem_trans(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dem_trans", supplied_args, result[0])
        )
        self._on_error("dem_trans", supplied_args, result[0])
        return result

    def quad_sub(self, int_1, DIFF_par: str, int_2: str, int_type, mode=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["quad_sub"] += 1

        if DIFF_par is not None:
            result = self._validate(
                "quad_sub",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if int_2 is not None and int_2 != "-":
            Path(int_2).touch()
        valid_values = [0, 1]
        result = self._validate(
            "quad_sub",
            int_type == "-" or int_type in valid_values,
            result,
            f"int_type is not a valid value (expects: {valid_values}, got: {int_type})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "quad_sub",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.quad_sub(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "quad_sub", supplied_args, result[0])
        )
        self._on_error("quad_sub", supplied_args, result[0])
        return result

    def phase_sum(
        self,
        im_list,
        width,
        sum: str,
        start=None,
        nlines=None,
        pixav_x=None,
        pixav_y=None,
        zflag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["phase_sum"] += 1

        if sum is not None and sum != "-":
            Path(sum).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "phase_sum",
            zflag == "-" or zflag in valid_values,
            result,
            f"zflag is not a valid value (expects: {valid_values}, got: {zflag})",
        )
        if self._wraps is not None:
            result = self._wraps.phase_sum(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "phase_sum", supplied_args, result[0])
        )
        self._on_error("phase_sum", supplied_args, result[0])
        return result

    def base_add(self, base_1: str, base_2: str, base_out: str, mode=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["base_add"] += 1

        if base_1 is not None:
            result = self._validate(
                "base_add",
                base_1 == "-" or Path(base_1).exists(),
                result,
                f"base_1 path does not exist ({base_1})",
            )
        if base_2 is not None:
            result = self._validate(
                "base_add",
                base_2 == "-" or Path(base_2).exists(),
                result,
                f"base_2 path does not exist ({base_2})",
            )
        if base_out is not None and base_out != "-":
            Path(base_out).touch()
        if self._wraps is not None:
            result = self._wraps.base_add(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "base_add", supplied_args, result[0])
        )
        self._on_error("base_add", supplied_args, result[0])
        return result

    def gec_map_grd(
        self,
        GRD_par: str,
        DEM_par: str,
        href: str,
        DEM_seg_par: str,
        lookup_table: str,
        lat_ovr=None,
        lon_ovr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gec_map_grd"] += 1

        if GRD_par is not None:
            result = self._validate(
                "gec_map_grd",
                GRD_par == "-" or Path(GRD_par).exists(),
                result,
                f"GRD_par path does not exist ({GRD_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "gec_map_grd",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if href is not None:
            result = self._validate(
                "gec_map_grd",
                href == "-" or Path(href).exists(),
                result,
                f"href path does not exist ({href})",
            )
        if (
            DEM_seg_par is not None
            and DEM_seg_par != "-"
            and not Path(DEM_seg_par).exists()
        ):
            Path(DEM_seg_par).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if self._wraps is not None:
            result = self._wraps.gec_map_grd(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gec_map_grd", supplied_args, result[0])
        )
        self._on_error("gec_map_grd", supplied_args, result[0])
        return result

    def sarpix_coord_list(
        self, SLC_par: str, OFF_par: str, DEM_par: str, SAR_coord: str, MAP_coord: str
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["sarpix_coord_list"] += 1

        if SLC_par is not None:
            result = self._validate(
                "sarpix_coord_list",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "sarpix_coord_list",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "sarpix_coord_list",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if SAR_coord is not None:
            result = self._validate(
                "sarpix_coord_list",
                SAR_coord == "-" or Path(SAR_coord).exists(),
                result,
                f"SAR_coord path does not exist ({SAR_coord})",
            )
        if MAP_coord is not None and MAP_coord != "-":
            Path(MAP_coord).touch()
        if self._wraps is not None:
            result = self._wraps.sarpix_coord_list(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "sarpix_coord_list", supplied_args, result[0])
        )
        self._on_error("sarpix_coord_list", supplied_args, result[0])
        return result

    def dispmap_vec(
        self,
        DEM_par: str,
        dispmap,
        lv_theta: str,
        lv_phi: str,
        fv_theta: str,
        fv_phi: str,
        dv_norm: str,
        dv_theta: str = None,
        dv_phi: str = None,
        dv_x: str = None,
        dv_y: str = None,
        dv_z: str = None,
        mask_angle=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dispmap_vec"] += 1

        if DEM_par is not None:
            result = self._validate(
                "dispmap_vec",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if lv_theta is not None:
            result = self._validate(
                "dispmap_vec",
                lv_theta == "-" or Path(lv_theta).exists(),
                result,
                f"lv_theta path does not exist ({lv_theta})",
            )
        if lv_phi is not None:
            result = self._validate(
                "dispmap_vec",
                lv_phi == "-" or Path(lv_phi).exists(),
                result,
                f"lv_phi path does not exist ({lv_phi})",
            )
        if fv_theta is not None:
            result = self._validate(
                "dispmap_vec",
                fv_theta == "-" or Path(fv_theta).exists(),
                result,
                f"fv_theta path does not exist ({fv_theta})",
            )
        if fv_phi is not None:
            result = self._validate(
                "dispmap_vec",
                fv_phi == "-" or Path(fv_phi).exists(),
                result,
                f"fv_phi path does not exist ({fv_phi})",
            )
        if dv_norm is not None and dv_norm != "-":
            Path(dv_norm).touch()
        if dv_theta is not None and dv_theta != "-":
            Path(dv_theta).touch()
        if dv_phi is not None and dv_phi != "-":
            Path(dv_phi).touch()
        if dv_x is not None and dv_x != "-":
            Path(dv_x).touch()
        if dv_y is not None and dv_y != "-":
            Path(dv_y).touch()
        if dv_z is not None and dv_z != "-":
            Path(dv_z).touch()
        if self._wraps is not None:
            result = self._wraps.dispmap_vec(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dispmap_vec", supplied_args, result[0])
        )
        self._on_error("dispmap_vec", supplied_args, result[0])
        return result

    def scale_base(
        self,
        unw_2: str,
        scaled_unw_2: str,
        baseline_1: str,
        SLC1_par_1: str,
        OFF_par_1,
        baseline_2: str,
        SLC_1_par_2: str,
        OFF_par_2,
        int_type,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["scale_base"] += 1

        if unw_2 is not None:
            result = self._validate(
                "scale_base",
                unw_2 == "-" or Path(unw_2).exists(),
                result,
                f"unw_2 path does not exist ({unw_2})",
            )
        if scaled_unw_2 is not None and scaled_unw_2 != "-":
            Path(scaled_unw_2).touch()
        if baseline_1 is not None:
            result = self._validate(
                "scale_base",
                baseline_1 == "-" or Path(baseline_1).exists(),
                result,
                f"baseline_1 path does not exist ({baseline_1})",
            )
        if SLC1_par_1 is not None:
            result = self._validate(
                "scale_base",
                SLC1_par_1 == "-" or Path(SLC1_par_1).exists(),
                result,
                f"SLC1_par_1 path does not exist ({SLC1_par_1})",
            )
        if baseline_2 is not None:
            result = self._validate(
                "scale_base",
                baseline_2 == "-" or Path(baseline_2).exists(),
                result,
                f"baseline_2 path does not exist ({baseline_2})",
            )
        if SLC_1_par_2 is not None:
            result = self._validate(
                "scale_base",
                SLC_1_par_2 == "-" or Path(SLC_1_par_2).exists(),
                result,
                f"SLC_1_par_2 path does not exist ({SLC_1_par_2})",
            )
        if self._wraps is not None:
            result = self._wraps.scale_base(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "scale_base", supplied_args, result[0])
        )
        self._on_error("scale_base", supplied_args, result[0])
        return result

    def par_EORC_PALSAR_geo(
        self,
        CEOS_leader: str,
        MLI_par: str,
        DEM_par: str,
        CEOS_data: str,
        MLI: str = None,
        cal=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_EORC_PALSAR_geo"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_EORC_PALSAR_geo",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if CEOS_data is not None:
            result = self._validate(
                "par_EORC_PALSAR_geo",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if self._wraps is not None:
            result = self._wraps.par_EORC_PALSAR_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "par_EORC_PALSAR_geo", supplied_args, result[0])
        )
        self._on_error("par_EORC_PALSAR_geo", supplied_args, result[0])
        return result

    def SLC_intf_geo(
        self,
        SLC_1: str,
        SLC_2: str,
        DEM_par: str,
        interf: str,
        DEM_par2: str,
        e_lks,
        n_lks,
        MLI_1: str = None,
        MLI_2: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_intf_geo"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "SLC_intf_geo",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "SLC_intf_geo",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if DEM_par is not None:
            result = self._validate(
                "SLC_intf_geo",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if interf is not None and interf != "-":
            Path(interf).touch()
        if DEM_par2 is not None and DEM_par2 != "-":
            Path(DEM_par2).touch()
        if MLI_1 is not None and MLI_1 != "-":
            Path(MLI_1).touch()
        if MLI_2 is not None and MLI_2 != "-":
            Path(MLI_2).touch()
        if self._wraps is not None:
            result = self._wraps.SLC_intf_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "SLC_intf_geo", supplied_args, result[0])
        )
        self._on_error("SLC_intf_geo", supplied_args, result[0])
        return result

    def map_trans(
        self,
        DEM1_par: str,
        data1: str,
        DEM2_par: str,
        data2: str,
        lat_ovr=None,
        lon_ovr=None,
        interp_mode=None,
        dtype=None,
        bflg=None,
        lookup_table: str = None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["map_trans"] += 1

        if DEM1_par is not None:
            result = self._validate(
                "map_trans",
                DEM1_par == "-" or Path(DEM1_par).exists(),
                result,
                f"DEM1_par path does not exist ({DEM1_par})",
            )
        if data1 is not None:
            result = self._validate(
                "map_trans",
                data1 == "-" or Path(data1).exists(),
                result,
                f"data1 path does not exist ({data1})",
            )
        if DEM2_par is not None and DEM2_par != "-" and not Path(DEM2_par).exists():
            Path(DEM2_par).touch()
        if data2 is not None and data2 != "-":
            Path(data2).touch()
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        result = self._validate(
            "map_trans",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "map_trans",
            bflg == "-" or bflg in valid_values,
            result,
            f"bflg is not a valid value (expects: {valid_values}, got: {bflg})",
        )
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if self._wraps is not None:
            result = self._wraps.map_trans(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "map_trans", supplied_args, result[0])
        )
        self._on_error("map_trans", supplied_args, result[0])
        return result

    def gc_map_inversion(
        self,
        gc_map,
        width_in,
        gc_map_out,
        width_out,
        nlines_out=None,
        interp_mode=None,
        n_ovr=None,
        rad_max=None,
        nintr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gc_map_inversion"] += 1

        valid_values = [0, 1, 2, 3, 4] + [None]
        result = self._validate(
            "gc_map_inversion",
            interp_mode == "-" or interp_mode in valid_values,
            result,
            f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.gc_map_inversion(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gc_map_inversion", supplied_args, result[0])
        )
        self._on_error("gc_map_inversion", supplied_args, result[0])
        return result

    def par_JERS_geo(
        self,
        CEOS_leader: str,
        CEOS_data: str,
        MLI_par: str,
        DEM_par: str,
        GEO: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_JERS_geo"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_JERS_geo",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if CEOS_data is not None:
            result = self._validate(
                "par_JERS_geo",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if GEO is not None and GEO != "-":
            Path(GEO).touch()
        if self._wraps is not None:
            result = self._wraps.par_JERS_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "par_JERS_geo", supplied_args, result[0])
        )
        self._on_error("par_JERS_geo", supplied_args, result[0])
        return result

    def interp_data(
        self,
        data2: str,
        DIFF_par: str,
        data2_out: str,
        interp_mode=None,
        dtype=None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["interp_data"] += 1

        if data2 is not None:
            result = self._validate(
                "interp_data",
                data2 == "-" or Path(data2).exists(),
                result,
                f"data2 path does not exist ({data2})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "interp_data",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if data2_out is not None and data2_out != "-":
            Path(data2_out).touch()
        valid_values = [0, 1, 2, 3, 4, 5, 6] + [None]
        result = self._validate(
            "interp_data",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.interp_data(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "interp_data", supplied_args, result[0])
        )
        self._on_error("interp_data", supplied_args, result[0])
        return result

    def rdc_trans(self, MLI1_par: str, DEM_RDC, MLI2_par: str, lt: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rdc_trans"] += 1

        if MLI1_par is not None:
            result = self._validate(
                "rdc_trans",
                MLI1_par == "-" or Path(MLI1_par).exists(),
                result,
                f"MLI1_par path does not exist ({MLI1_par})",
            )
        if MLI2_par is not None:
            result = self._validate(
                "rdc_trans",
                MLI2_par == "-" or Path(MLI2_par).exists(),
                result,
                f"MLI2_par path does not exist ({MLI2_par})",
            )
        if lt is not None and lt != "-":
            Path(lt).touch()
        if self._wraps is not None:
            result = self._wraps.rdc_trans(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "rdc_trans", supplied_args, result[0])
        )
        self._on_error("rdc_trans", supplied_args, result[0])
        return result

    def SLC_interp_lt_ScanSAR(
        self,
        SLC2_tab: str,
        SLC2_par: str,
        SLC1_tab: str,
        SLC1_par: str,
        lookup_table: str,
        MLI1_par: str,
        MLI2_par: str,
        OFF_par: str,
        SLC2R_tab: str,
        SLC_2R: str = None,
        SLC2R_par: str = None,
        mode=None,
        order=None,
        SLC2R_dir=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_interp_lt_ScanSAR"] += 1

        if SLC2_tab is not None:
            result = self._validate(
                "SLC_interp_lt_ScanSAR",
                SLC2_tab == "-" or Path(SLC2_tab).exists(),
                result,
                f"SLC2_tab path does not exist ({SLC2_tab})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "SLC_interp_lt_ScanSAR",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if SLC1_tab is not None:
            result = self._validate(
                "SLC_interp_lt_ScanSAR",
                SLC1_tab == "-" or Path(SLC1_tab).exists(),
                result,
                f"SLC1_tab path does not exist ({SLC1_tab})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_interp_lt_ScanSAR",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if lookup_table is not None:
            result = self._validate(
                "SLC_interp_lt_ScanSAR",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        if MLI1_par is not None:
            result = self._validate(
                "SLC_interp_lt_ScanSAR",
                MLI1_par == "-" or Path(MLI1_par).exists(),
                result,
                f"MLI1_par path does not exist ({MLI1_par})",
            )
        if MLI2_par is not None:
            result = self._validate(
                "SLC_interp_lt_ScanSAR",
                MLI2_par == "-" or Path(MLI2_par).exists(),
                result,
                f"MLI2_par path does not exist ({MLI2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "SLC_interp_lt_ScanSAR",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if SLC2R_tab is not None and SLC2R_tab != "-" and not Path(SLC2R_tab).exists():
            Path(SLC2R_tab).touch()
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_interp_lt_ScanSAR",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_interp_lt_ScanSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "SLC_interp_lt_ScanSAR", supplied_args, result[0])
        )
        self._on_error("SLC_interp_lt_ScanSAR", supplied_args, result[0])
        return result

    def par_CS_geo(self, HDF5: str, MLI_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_CS_geo"] += 1

        if HDF5 is not None:
            result = self._validate(
                "par_CS_geo",
                HDF5 == "-" or Path(HDF5).exists(),
                result,
                f"HDF5 path does not exist ({HDF5})",
            )
        if MLI_par is not None:
            result = self._validate(
                "par_CS_geo",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if self._wraps is not None:
            result = self._wraps.par_CS_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "par_CS_geo", supplied_args, result[0])
        )
        self._on_error("par_CS_geo", supplied_args, result[0])
        return result

    def par_RCM_geo(
        self,
        RCM_dir: str,
        polarization,
        MLI_par: str,
        DEM_par: str,
        GEO: str,
        dtype=None,
        ps=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RCM_geo"] += 1

        if RCM_dir is not None:
            result = self._validate(
                "par_RCM_geo",
                RCM_dir == "-" or Path(RCM_dir).exists(),
                result,
                f"RCM_dir path does not exist ({RCM_dir})",
            )
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if GEO is not None and GEO != "-":
            Path(GEO).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "par_RCM_geo",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.par_RCM_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "par_RCM_geo", supplied_args, result[0])
        )
        self._on_error("par_RCM_geo", supplied_args, result[0])
        return result

    def offset_pwr_trackingm2(
        self,
        MLI_1: str,
        MLI_2: str,
        DIFF_par: str,
        offs: str,
        ccp: str,
        DIFF_par2: str = None,
        offs2: str = None,
        rwin=None,
        azwin=None,
        offsets: str = None,
        n_ovr=None,
        thres=None,
        rstep=None,
        azstep=None,
        rstart=None,
        rstop=None,
        azstart=None,
        azstop=None,
        bw_frac=None,
        pflag=None,
        pltflg=None,
        ccs: str = None,
        std_mean=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_pwr_trackingm2"] += 1

        if MLI_1 is not None:
            result = self._validate(
                "offset_pwr_trackingm2",
                MLI_1 == "-" or Path(MLI_1).exists(),
                result,
                f"MLI_1 path does not exist ({MLI_1})",
            )
        if MLI_2 is not None:
            result = self._validate(
                "offset_pwr_trackingm2",
                MLI_2 == "-" or Path(MLI_2).exists(),
                result,
                f"MLI_2 path does not exist ({MLI_2})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "offset_pwr_trackingm2",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if DIFF_par2 is not None:
            result = self._validate(
                "offset_pwr_trackingm2",
                DIFF_par2 == "-" or Path(DIFF_par2).exists(),
                result,
                f"DIFF_par2 path does not exist ({DIFF_par2})",
            )
        if offs2 is not None:
            result = self._validate(
                "offset_pwr_trackingm2",
                offs2 == "-" or Path(offs2).exists(),
                result,
                f"offs2 path does not exist ({offs2})",
            )
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_trackingm2",
            pflag == "-" or pflag in valid_values,
            result,
            f"pflag is not a valid value (expects: {valid_values}, got: {pflag})",
        )
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "offset_pwr_trackingm2",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if ccs is not None and ccs != "-":
            Path(ccs).touch()
        if self._wraps is not None:
            result = self._wraps.offset_pwr_trackingm2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "offset_pwr_trackingm2", supplied_args, result[0])
        )
        self._on_error("offset_pwr_trackingm2", supplied_args, result[0])
        return result

    def init_offset_orbitm(
        self,
        MLI1_par: str,
        MLI2_par: str,
        DIFF_par: str,
        rpos=None,
        azpos=None,
        cflag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["init_offset_orbitm"] += 1

        if MLI1_par is not None:
            result = self._validate(
                "init_offset_orbitm",
                MLI1_par == "-" or Path(MLI1_par).exists(),
                result,
                f"MLI1_par path does not exist ({MLI1_par})",
            )
        if MLI2_par is not None:
            result = self._validate(
                "init_offset_orbitm",
                MLI2_par == "-" or Path(MLI2_par).exists(),
                result,
                f"MLI2_par path does not exist ({MLI2_par})",
            )
        if DIFF_par is not None and DIFF_par != "-" and not Path(DIFF_par).exists():
            Path(DIFF_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "init_offset_orbitm",
            cflag == "-" or cflag in valid_values,
            result,
            f"cflag is not a valid value (expects: {valid_values}, got: {cflag})",
        )
        if self._wraps is not None:
            result = self._wraps.init_offset_orbitm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "init_offset_orbitm", supplied_args, result[0])
        )
        self._on_error("init_offset_orbitm", supplied_args, result[0])
        return result

    def quad_fit(
        self,
        unw,
        DIFF_par,
        dr=None,
        daz=None,
        mask=None,
        plot_data: str = None,
        model=None,
        pmodel: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["quad_fit"] += 1

        if plot_data is not None and plot_data != "-":
            Path(plot_data).touch()
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7] + [None]
        result = self._validate(
            "quad_fit",
            model == "-" or model in valid_values,
            result,
            f"model is not a valid value (expects: {valid_values}, got: {model})",
        )
        if pmodel is not None and pmodel != "-":
            Path(pmodel).touch()
        if self._wraps is not None:
            result = self._wraps.quad_fit(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "quad_fit", supplied_args, result[0])
        )
        self._on_error("quad_fit", supplied_args, result[0])
        return result

    def stacking(
        self,
        DIFF_tab,
        width,
        ph_rate: str,
        sig_ph_rate: str,
        sig_ph: str,
        roff,
        loff,
        nr=None,
        nl=None,
        np_min=None,
        tscale=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["stacking"] += 1

        if ph_rate is not None and ph_rate != "-":
            Path(ph_rate).touch()
        if sig_ph_rate is not None and sig_ph_rate != "-":
            Path(sig_ph_rate).touch()
        if sig_ph is not None and sig_ph != "-":
            Path(sig_ph).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "stacking",
            tscale == "-" or tscale in valid_values,
            result,
            f"tscale is not a valid value (expects: {valid_values}, got: {tscale})",
        )
        if self._wraps is not None:
            result = self._wraps.stacking(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "stacking", supplied_args, result[0])
        )
        self._on_error("stacking", supplied_args, result[0])
        return result

    def atm_mod2(
        self,
        diff_unw,
        hgt: str,
        MLI_par: str,
        model: str,
        dr=None,
        daz=None,
        mask: str = None,
        mode=None,
        roff=None,
        loff=None,
        report: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["atm_mod2"] += 1

        if hgt is not None:
            result = self._validate(
                "atm_mod2",
                hgt == "-" or Path(hgt).exists(),
                result,
                f"hgt path does not exist ({hgt})",
            )
        if MLI_par is not None:
            result = self._validate(
                "atm_mod2",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if model is not None and model != "-":
            Path(model).touch()
        if mask is not None:
            result = self._validate(
                "atm_mod2",
                mask == "-" or Path(mask).exists(),
                result,
                f"mask path does not exist ({mask})",
            )
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "atm_mod2",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if report is not None and report != "-":
            Path(report).touch()
        if self._wraps is not None:
            result = self._wraps.atm_mod2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "atm_mod2", supplied_args, result[0])
        )
        self._on_error("atm_mod2", supplied_args, result[0])
        return result

    def par_UAVSAR_geo(self, ann: str, SLC_MLI_par: str = None, DEM_par: str = None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_UAVSAR_geo"] += 1

        if ann is not None:
            result = self._validate(
                "par_UAVSAR_geo",
                ann == "-" or Path(ann).exists(),
                result,
                f"ann path does not exist ({ann})",
            )
        if SLC_MLI_par is not None and SLC_MLI_par != "-":
            Path(SLC_MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_UAVSAR_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "par_UAVSAR_geo", supplied_args, result[0])
        )
        self._on_error("par_UAVSAR_geo", supplied_args, result[0])
        return result

    def dem_import(
        self,
        input_DEM: str,
        DEM: str,
        DEM_par: str,
        input_type=None,
        priority=None,
        geoid: str = None,
        geoid_par: str = None,
        geoid_type=None,
        latN_shift=None,
        lonE_shift=None,
        zflg=None,
        no_data=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dem_import"] += 1

        if input_DEM is not None:
            result = self._validate(
                "dem_import",
                input_DEM == "-" or Path(input_DEM).exists(),
                result,
                f"input_DEM path does not exist ({input_DEM})",
            )
        if DEM is not None and DEM != "-":
            Path(DEM).touch()
        if DEM_par is not None and DEM_par != "-" and not Path(DEM_par).exists():
            Path(DEM_par).touch()
        valid_values = [0, 1, 2, 3, 4] + [None]
        result = self._validate(
            "dem_import",
            input_type == "-" or input_type in valid_values,
            result,
            f"input_type is not a valid value (expects: {valid_values}, got: {input_type})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dem_import",
            priority == "-" or priority in valid_values,
            result,
            f"priority is not a valid value (expects: {valid_values}, got: {priority})",
        )
        if geoid is not None:
            result = self._validate(
                "dem_import",
                geoid == "-" or Path(geoid).exists(),
                result,
                f"geoid path does not exist ({geoid})",
            )
        if geoid_par is not None:
            result = self._validate(
                "dem_import",
                geoid_par == "-" or Path(geoid_par).exists(),
                result,
                f"geoid_par path does not exist ({geoid_par})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dem_import",
            geoid_type == "-" or geoid_type in valid_values,
            result,
            f"geoid_type is not a valid value (expects: {valid_values}, got: {geoid_type})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dem_import",
            zflg == "-" or zflg in valid_values,
            result,
            f"zflg is not a valid value (expects: {valid_values}, got: {zflg})",
        )
        if self._wraps is not None:
            result = self._wraps.dem_import(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dem_import", supplied_args, result[0])
        )
        self._on_error("dem_import", supplied_args, result[0])
        return result

    def SLC_interp_lt(
        self,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        lookup_table: str,
        MLI1_par: str,
        MLI2_par: str,
        OFF_par: str,
        SLC_2R: str,
        SLC2R_par: str,
        blk_size=None,
        mode=None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_interp_lt"] += 1

        if SLC_2 is not None:
            result = self._validate(
                "SLC_interp_lt",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_interp_lt",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "SLC_interp_lt",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if lookup_table is not None:
            result = self._validate(
                "SLC_interp_lt",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        if MLI1_par is not None:
            result = self._validate(
                "SLC_interp_lt",
                MLI1_par == "-" or Path(MLI1_par).exists(),
                result,
                f"MLI1_par path does not exist ({MLI1_par})",
            )
        if MLI2_par is not None:
            result = self._validate(
                "SLC_interp_lt",
                MLI2_par == "-" or Path(MLI2_par).exists(),
                result,
                f"MLI2_par path does not exist ({MLI2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "SLC_interp_lt",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_interp_lt",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_interp_lt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "SLC_interp_lt", supplied_args, result[0])
        )
        self._on_error("SLC_interp_lt", supplied_args, result[0])
        return result

    def dispmap(
        self, unw, hgt, MLI_par: str, OFF_par: str, disp_map: str, mode=None, sflg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dispmap"] += 1

        if MLI_par is not None:
            result = self._validate(
                "dispmap",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "dispmap",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if disp_map is not None and disp_map != "-":
            Path(disp_map).touch()
        if self._wraps is not None:
            result = self._wraps.dispmap(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dispmap", supplied_args, result[0])
        )
        self._on_error("dispmap", supplied_args, result[0])
        return result

    def atm_mod(
        self,
        diff_unw,
        hgt: str,
        DIFF_par,
        model: str,
        dr=None,
        daz=None,
        mask: str = None,
        mode=None,
        roff=None,
        loff=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["atm_mod"] += 1

        if hgt is not None:
            result = self._validate(
                "atm_mod",
                hgt == "-" or Path(hgt).exists(),
                result,
                f"hgt path does not exist ({hgt})",
            )
        if model is not None and model != "-":
            Path(model).touch()
        if mask is not None:
            result = self._validate(
                "atm_mod",
                mask == "-" or Path(mask).exists(),
                result,
                f"mask path does not exist ({mask})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "atm_mod",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.atm_mod(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "atm_mod", supplied_args, result[0])
        )
        self._on_error("atm_mod", supplied_args, result[0])
        return result

    def dispmap_LOS(self, unw, width, freq, disp_map: str, sflg=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dispmap_LOS"] += 1

        if disp_map is not None and disp_map != "-":
            Path(disp_map).touch()
        if self._wraps is not None:
            result = self._wraps.dispmap_LOS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dispmap_LOS", supplied_args, result[0])
        )
        self._on_error("dispmap_LOS", supplied_args, result[0])
        return result

    def sub_phase(
        self, int_1: str, unw_2: str, DIFF_par: str, diff_int: str, dtype, mode=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["sub_phase"] += 1

        if int_1 is not None:
            result = self._validate(
                "sub_phase",
                int_1 == "-" or Path(int_1).exists(),
                result,
                f"int_1 path does not exist ({int_1})",
            )
        if unw_2 is not None:
            result = self._validate(
                "sub_phase",
                unw_2 == "-" or Path(unw_2).exists(),
                result,
                f"unw_2 path does not exist ({unw_2})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "sub_phase",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if diff_int is not None and diff_int != "-":
            Path(diff_int).touch()
        valid_values = [0, 1, 2]
        result = self._validate(
            "sub_phase",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "sub_phase",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.sub_phase(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "sub_phase", supplied_args, result[0])
        )
        self._on_error("sub_phase", supplied_args, result[0])
        return result

    def phase_sim(
        self,
        SLC1_par: str,
        OFF_par: str,
        baseline: str,
        hgt,
        sim_unw: str,
        ph_flag=None,
        bflag=None,
        definition=None,
        delta_t=None,
        int_mode=None,
        SLC2R_par: str = None,
        ph_mode=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["phase_sim"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "phase_sim",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "phase_sim",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if baseline is not None:
            result = self._validate(
                "phase_sim",
                baseline == "-" or Path(baseline).exists(),
                result,
                f"baseline path does not exist ({baseline})",
            )
        if sim_unw is not None and sim_unw != "-":
            Path(sim_unw).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "phase_sim",
            ph_flag == "-" or ph_flag in valid_values,
            result,
            f"ph_flag is not a valid value (expects: {valid_values}, got: {ph_flag})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "phase_sim",
            bflag == "-" or bflag in valid_values,
            result,
            f"bflag is not a valid value (expects: {valid_values}, got: {bflag})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "phase_sim",
            int_mode == "-" or int_mode in valid_values,
            result,
            f"int_mode is not a valid value (expects: {valid_values}, got: {int_mode})",
        )
        if SLC2R_par is not None:
            result = self._validate(
                "phase_sim",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "phase_sim",
            ph_mode == "-" or ph_mode in valid_values,
            result,
            f"ph_mode is not a valid value (expects: {valid_values}, got: {ph_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.phase_sim(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "phase_sim", supplied_args, result[0])
        )
        self._on_error("phase_sim", supplied_args, result[0])
        return result

    def par_RISAT_geo(
        self,
        annotation_XML: str,
        GeoTIFF: str,
        polarization,
        DEM_par: str,
        MLI_par: str,
        MLI: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RISAT_geo"] += 1

        if annotation_XML is not None:
            result = self._validate(
                "par_RISAT_geo",
                annotation_XML == "-" or Path(annotation_XML).exists(),
                result,
                f"annotation_XML path does not exist ({annotation_XML})",
            )
        if GeoTIFF is not None:
            result = self._validate(
                "par_RISAT_geo",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if self._wraps is not None:
            result = self._wraps.par_RISAT_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "par_RISAT_geo", supplied_args, result[0])
        )
        self._on_error("par_RISAT_geo", supplied_args, result[0])
        return result

    def MLI_interp_lt(
        self,
        MLI_2: str,
        MLI1_par: str,
        MLI2_par: str,
        lookup_table: str,
        MLI3_par: str,
        MLI4_par: str,
        DIFF_par: str,
        MLI_2R: str,
        MLI2R_par: str,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["MLI_interp_lt"] += 1

        if MLI_2 is not None:
            result = self._validate(
                "MLI_interp_lt",
                MLI_2 == "-" or Path(MLI_2).exists(),
                result,
                f"MLI_2 path does not exist ({MLI_2})",
            )
        if MLI1_par is not None:
            result = self._validate(
                "MLI_interp_lt",
                MLI1_par == "-" or Path(MLI1_par).exists(),
                result,
                f"MLI1_par path does not exist ({MLI1_par})",
            )
        if MLI2_par is not None:
            result = self._validate(
                "MLI_interp_lt",
                MLI2_par == "-" or Path(MLI2_par).exists(),
                result,
                f"MLI2_par path does not exist ({MLI2_par})",
            )
        if lookup_table is not None:
            result = self._validate(
                "MLI_interp_lt",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        if MLI3_par is not None:
            result = self._validate(
                "MLI_interp_lt",
                MLI3_par == "-" or Path(MLI3_par).exists(),
                result,
                f"MLI3_par path does not exist ({MLI3_par})",
            )
        if MLI4_par is not None:
            result = self._validate(
                "MLI_interp_lt",
                MLI4_par == "-" or Path(MLI4_par).exists(),
                result,
                f"MLI4_par path does not exist ({MLI4_par})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "MLI_interp_lt",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if MLI_2R is not None and MLI_2R != "-":
            Path(MLI_2R).touch()
        if MLI2R_par is not None and MLI2R_par != "-":
            Path(MLI2R_par).touch()
        if self._wraps is not None:
            result = self._wraps.MLI_interp_lt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "MLI_interp_lt", supplied_args, result[0])
        )
        self._on_error("MLI_interp_lt", supplied_args, result[0])
        return result

    def lk_vec_lt(
        self,
        MLI_par: str,
        DEM_par: str,
        DEM: str,
        lt: str,
        lv_theta: str,
        lv_phi: str,
        lv_ENU: str = None,
        azv_ENU: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["lk_vec_lt"] += 1

        if MLI_par is not None:
            result = self._validate(
                "lk_vec_lt",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "lk_vec_lt",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "lk_vec_lt",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if lt is not None:
            result = self._validate(
                "lk_vec_lt",
                lt == "-" or Path(lt).exists(),
                result,
                f"lt path does not exist ({lt})",
            )
        if lv_theta is not None and lv_theta != "-":
            Path(lv_theta).touch()
        if lv_phi is not None and lv_phi != "-":
            Path(lv_phi).touch()
        if lv_ENU is not None and lv_ENU != "-":
            Path(lv_ENU).touch()
        if azv_ENU is not None and azv_ENU != "-":
            Path(azv_ENU).touch()
        if self._wraps is not None:
            result = self._wraps.lk_vec_lt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "lk_vec_lt", supplied_args, result[0])
        )
        self._on_error("lk_vec_lt", supplied_args, result[0])
        return result

    def coord_to_sarpix(
        self,
        SLC_par,
        OFF_par: str,
        DEM_par: str,
        north_lat=None,
        east_lon=None,
        hgt=None,
        DIFF_par=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["coord_to_sarpix"] += 1

        if OFF_par is not None:
            result = self._validate(
                "coord_to_sarpix",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "coord_to_sarpix",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if self._wraps is not None:
            result = self._wraps.coord_to_sarpix(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "coord_to_sarpix", supplied_args, result[0])
        )
        self._on_error("coord_to_sarpix", supplied_args, result[0])
        return result

    def WSS_intf(
        self,
        SLC_1: str,
        SLC_2R: str,
        SLC1_par: str,
        SLC2R_par: str,
        OFF_par: str,
        interf: str,
        rlks=None,
        sps_flg=None,
        azf_flg=None,
        m_flg=None,
        boff=None,
        bstep=None,
        bmax=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["WSS_intf"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "WSS_intf",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2R is not None:
            result = self._validate(
                "WSS_intf",
                SLC_2R == "-" or Path(SLC_2R).exists(),
                result,
                f"SLC_2R path does not exist ({SLC_2R})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "WSS_intf",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2R_par is not None:
            result = self._validate(
                "WSS_intf",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        if OFF_par is not None and OFF_par != "-":
            Path(OFF_par).touch()
        if interf is not None and interf != "-":
            Path(interf).touch()
        valid_values = [1, 0] + [None]
        result = self._validate(
            "WSS_intf",
            sps_flg == "-" or sps_flg in valid_values,
            result,
            f"sps_flg is not a valid value (expects: {valid_values}, got: {sps_flg})",
        )
        valid_values = [1, 0] + [None]
        result = self._validate(
            "WSS_intf",
            azf_flg == "-" or azf_flg in valid_values,
            result,
            f"azf_flg is not a valid value (expects: {valid_values}, got: {azf_flg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "WSS_intf",
            m_flg == "-" or m_flg in valid_values,
            result,
            f"m_flg is not a valid value (expects: {valid_values}, got: {m_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.WSS_intf(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "WSS_intf", supplied_args, result[0])
        )
        self._on_error("WSS_intf", supplied_args, result[0])
        return result

    def map_section(
        self,
        DEM_par: str,
        n1,
        e1,
        n2,
        e2,
        post_north,
        post_east,
        DEM_par2: str,
        lt: str = None,
        MLI_par1: str = None,
        MLI_par2: str = None,
        cflg=None,
        lt2: str = None,
        MLI_coord: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["map_section"] += 1

        if DEM_par is not None:
            result = self._validate(
                "map_section",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM_par2 is not None and DEM_par2 != "-":
            Path(DEM_par2).touch()
        if lt is not None:
            result = self._validate(
                "map_section",
                lt == "-" or Path(lt).exists(),
                result,
                f"lt path does not exist ({lt})",
            )
        if MLI_par1 is not None:
            result = self._validate(
                "map_section",
                MLI_par1 == "-" or Path(MLI_par1).exists(),
                result,
                f"MLI_par1 path does not exist ({MLI_par1})",
            )
        if MLI_par2 is not None:
            result = self._validate(
                "map_section",
                MLI_par2 == "-" or Path(MLI_par2).exists(),
                result,
                f"MLI_par2 path does not exist ({MLI_par2})",
            )
        if lt2 is not None and lt2 != "-":
            Path(lt2).touch()
        if MLI_coord is not None and MLI_coord != "-":
            Path(MLI_coord).touch()
        if self._wraps is not None:
            result = self._wraps.map_section(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "map_section", supplied_args, result[0])
        )
        self._on_error("map_section", supplied_args, result[0])
        return result

    def offset_list_fitm(
        self,
        cp_list: str,
        DIFF_par: str,
        DEM_par: str,
        lookup_table: str = None,
        lt_type=None,
        type1=None,
        type2=None,
        coffsets: str = None,
        poly_order=None,
        interact_flag=None,
        trans_list=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_list_fitm"] += 1

        if cp_list is not None:
            result = self._validate(
                "offset_list_fitm",
                cp_list == "-" or Path(cp_list).exists(),
                result,
                f"cp_list path does not exist ({cp_list})",
            )
        if DIFF_par is not None and DIFF_par != "-" and not Path(DIFF_par).exists():
            Path(DIFF_par).touch()
        if DEM_par is not None:
            result = self._validate(
                "offset_list_fitm",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if lookup_table is not None:
            result = self._validate(
                "offset_list_fitm",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        valid_values = [1, 2] + [None]
        result = self._validate(
            "offset_list_fitm",
            lt_type == "-" or lt_type in valid_values,
            result,
            f"lt_type is not a valid value (expects: {valid_values}, got: {lt_type})",
        )
        valid_values = [1, 2, 3] + [None]
        result = self._validate(
            "offset_list_fitm",
            type1 == "-" or type1 in valid_values,
            result,
            f"type1 is not a valid value (expects: {valid_values}, got: {type1})",
        )
        valid_values = [1, 2, 3] + [None]
        result = self._validate(
            "offset_list_fitm",
            type2 == "-" or type2 in valid_values,
            result,
            f"type2 is not a valid value (expects: {valid_values}, got: {type2})",
        )
        if coffsets is not None and coffsets != "-":
            Path(coffsets).touch()
        if self._wraps is not None:
            result = self._wraps.offset_list_fitm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "offset_list_fitm", supplied_args, result[0])
        )
        self._on_error("offset_list_fitm", supplied_args, result[0])
        return result

    def dem_RDC_list(
        self,
        DEM_par1: str,
        gc_map: str,
        MLI_par: str,
        mask: str,
        clist_RDC: str,
        clist_MAP: str,
        DEM_par2: str,
        s_north,
        s_east,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dem_RDC_list"] += 1

        if DEM_par1 is not None:
            result = self._validate(
                "dem_RDC_list",
                DEM_par1 == "-" or Path(DEM_par1).exists(),
                result,
                f"DEM_par1 path does not exist ({DEM_par1})",
            )
        if gc_map is not None:
            result = self._validate(
                "dem_RDC_list",
                gc_map == "-" or Path(gc_map).exists(),
                result,
                f"gc_map path does not exist ({gc_map})",
            )
        if MLI_par is not None:
            result = self._validate(
                "dem_RDC_list",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if mask is not None:
            result = self._validate(
                "dem_RDC_list",
                mask == "-" or Path(mask).exists(),
                result,
                f"mask path does not exist ({mask})",
            )
        if clist_RDC is not None and clist_RDC != "-":
            Path(clist_RDC).touch()
        if clist_MAP is not None and clist_MAP != "-":
            Path(clist_MAP).touch()
        if DEM_par2 is not None and DEM_par2 != "-":
            Path(DEM_par2).touch()
        if self._wraps is not None:
            result = self._wraps.dem_RDC_list(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dem_RDC_list", supplied_args, result[0])
        )
        self._on_error("dem_RDC_list", supplied_args, result[0])
        return result

    def multi_look_geo(
        self,
        geo_SLC: str,
        SLC_DEM_par: str,
        MLI: str,
        MLI_DEM_par: str,
        e_lks,
        n_lks,
        dtype=None,
        scale=None,
        exp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_look_geo"] += 1

        if geo_SLC is not None:
            result = self._validate(
                "multi_look_geo",
                geo_SLC == "-" or Path(geo_SLC).exists(),
                result,
                f"geo_SLC path does not exist ({geo_SLC})",
            )
        if SLC_DEM_par is not None:
            result = self._validate(
                "multi_look_geo",
                SLC_DEM_par == "-" or Path(SLC_DEM_par).exists(),
                result,
                f"SLC_DEM_par path does not exist ({SLC_DEM_par})",
            )
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_DEM_par is not None and MLI_DEM_par != "-":
            Path(MLI_DEM_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "multi_look_geo",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.multi_look_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "multi_look_geo", supplied_args, result[0])
        )
        self._on_error("multi_look_geo", supplied_args, result[0])
        return result

    def WSS_interp_lt(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        lookup_table: str,
        MLI1_par: str,
        MLI2_par: str,
        DIFF_par1: str,
        SLC_2R: str,
        SLC2R_par: str,
        DIFF_par2: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["WSS_interp_lt"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "WSS_interp_lt",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "WSS_interp_lt",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "WSS_interp_lt",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "WSS_interp_lt",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if lookup_table is not None:
            result = self._validate(
                "WSS_interp_lt",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        if MLI1_par is not None:
            result = self._validate(
                "WSS_interp_lt",
                MLI1_par == "-" or Path(MLI1_par).exists(),
                result,
                f"MLI1_par path does not exist ({MLI1_par})",
            )
        if MLI2_par is not None:
            result = self._validate(
                "WSS_interp_lt",
                MLI2_par == "-" or Path(MLI2_par).exists(),
                result,
                f"MLI2_par path does not exist ({MLI2_par})",
            )
        if DIFF_par1 is not None:
            result = self._validate(
                "WSS_interp_lt",
                DIFF_par1 == "-" or Path(DIFF_par1).exists(),
                result,
                f"DIFF_par1 path does not exist ({DIFF_par1})",
            )
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()
        if DIFF_par2 is not None and DIFF_par2 != "-":
            Path(DIFF_par2).touch()
        if self._wraps is not None:
            result = self._wraps.WSS_interp_lt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "WSS_interp_lt", supplied_args, result[0])
        )
        self._on_error("WSS_interp_lt", supplied_args, result[0])
        return result

    def dispmap_vec2(
        self,
        DEM_par: str,
        DEM: str,
        dispmap1,
        lv1_theta: str,
        lv1_phi: str,
        dispmap2,
        lv2_theta: str,
        lv2_phi: str,
        dv_norm: str,
        dv_theta: str = None,
        dv_phi: str = None,
        dv_x: str = None,
        dv_y: str = None,
        dv_z: str = None,
        mask_angle=None,
        mode=None,
        ax_north=None,
        ax_east=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dispmap_vec2"] += 1

        if DEM_par is not None:
            result = self._validate(
                "dispmap_vec2",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "dispmap_vec2",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if lv1_theta is not None:
            result = self._validate(
                "dispmap_vec2",
                lv1_theta == "-" or Path(lv1_theta).exists(),
                result,
                f"lv1_theta path does not exist ({lv1_theta})",
            )
        if lv1_phi is not None:
            result = self._validate(
                "dispmap_vec2",
                lv1_phi == "-" or Path(lv1_phi).exists(),
                result,
                f"lv1_phi path does not exist ({lv1_phi})",
            )
        if lv2_theta is not None:
            result = self._validate(
                "dispmap_vec2",
                lv2_theta == "-" or Path(lv2_theta).exists(),
                result,
                f"lv2_theta path does not exist ({lv2_theta})",
            )
        if lv2_phi is not None:
            result = self._validate(
                "dispmap_vec2",
                lv2_phi == "-" or Path(lv2_phi).exists(),
                result,
                f"lv2_phi path does not exist ({lv2_phi})",
            )
        if dv_norm is not None and dv_norm != "-":
            Path(dv_norm).touch()
        if dv_theta is not None and dv_theta != "-":
            Path(dv_theta).touch()
        if dv_phi is not None and dv_phi != "-":
            Path(dv_phi).touch()
        if dv_x is not None and dv_x != "-":
            Path(dv_x).touch()
        if dv_y is not None and dv_y != "-":
            Path(dv_y).touch()
        if dv_z is not None and dv_z != "-":
            Path(dv_z).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "dispmap_vec2",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.dispmap_vec2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dispmap_vec2", supplied_args, result[0])
        )
        self._on_error("dispmap_vec2", supplied_args, result[0])
        return result

    def diff_ls_unw(
        self, int_1: str, unw_2: str, DIFF_par, diff_int: str, int_type=None, ph_flag=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["diff_ls_unw"] += 1

        if int_1 is not None:
            result = self._validate(
                "diff_ls_unw",
                int_1 == "-" or Path(int_1).exists(),
                result,
                f"int_1 path does not exist ({int_1})",
            )
        if unw_2 is not None:
            result = self._validate(
                "diff_ls_unw",
                unw_2 == "-" or Path(unw_2).exists(),
                result,
                f"unw_2 path does not exist ({unw_2})",
            )
        if diff_int is not None and diff_int != "-":
            Path(diff_int).touch()
        if self._wraps is not None:
            result = self._wraps.diff_ls_unw(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "diff_ls_unw", supplied_args, result[0])
        )
        self._on_error("diff_ls_unw", supplied_args, result[0])
        return result

    def offset_pwr_list(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        clist_RDC: str,
        clist_MAP: str,
        offs: str,
        ccp: str,
        nx,
        ny,
        rwin=None,
        azwin=None,
        offsets: str = None,
        n_ovr=None,
        thres=None,
        bw_frac=None,
        deramp=None,
        int_filt=None,
        pflag=None,
        pltflg=None,
        ccs: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_pwr_list"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "offset_pwr_list",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "offset_pwr_list",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "offset_pwr_list",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "offset_pwr_list",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_pwr_list",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if clist_RDC is not None:
            result = self._validate(
                "offset_pwr_list",
                clist_RDC == "-" or Path(clist_RDC).exists(),
                result,
                f"clist_RDC path does not exist ({clist_RDC})",
            )
        if clist_MAP is not None:
            result = self._validate(
                "offset_pwr_list",
                clist_MAP == "-" or Path(clist_MAP).exists(),
                result,
                f"clist_MAP path does not exist ({clist_MAP})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_list",
            int_filt == "-" or int_filt in valid_values,
            result,
            f"int_filt is not a valid value (expects: {valid_values}, got: {int_filt})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_list",
            pflag == "-" or pflag in valid_values,
            result,
            f"pflag is not a valid value (expects: {valid_values}, got: {pflag})",
        )
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "offset_pwr_list",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if ccs is not None and ccs != "-":
            Path(ccs).touch()
        if self._wraps is not None:
            result = self._wraps.offset_pwr_list(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "offset_pwr_list", supplied_args, result[0])
        )
        self._on_error("offset_pwr_list", supplied_args, result[0])
        return result

    def geocode(
        self,
        lookup_table: str,
        data_in: str,
        width_in,
        data_out: str,
        width_out,
        nlines_out=None,
        interp_mode=None,
        dtype=None,
        lr_in=None,
        lr_out=None,
        n_ovr=None,
        rad_max=None,
        nintr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["geocode"] += 1

        if lookup_table is not None:
            result = self._validate(
                "geocode",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        if data_in is not None:
            result = self._validate(
                "geocode",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1, 2, 3, 4] + [None]
        result = self._validate(
            "geocode",
            interp_mode == "-" or interp_mode in valid_values,
            result,
            f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})",
        )
        valid_values = [0, 1, 2, 3, 4, 5, 6] + [None]
        result = self._validate(
            "geocode",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.geocode(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "geocode", supplied_args, result[0])
        )
        self._on_error("geocode", supplied_args, result[0])
        return result

    def par_TX_geo(
        self,
        annotation_XML: str,
        GeoTIFF: str,
        MLI_par: str,
        DEM_par: str,
        GEO: str,
        pol=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_TX_geo"] += 1

        if annotation_XML is not None:
            result = self._validate(
                "par_TX_geo",
                annotation_XML == "-" or Path(annotation_XML).exists(),
                result,
                f"annotation_XML path does not exist ({annotation_XML})",
            )
        if GeoTIFF is not None:
            result = self._validate(
                "par_TX_geo",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if GEO is not None and GEO != "-":
            Path(GEO).touch()
        if self._wraps is not None:
            result = self._wraps.par_TX_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "par_TX_geo", supplied_args, result[0])
        )
        self._on_error("par_TX_geo", supplied_args, result[0])
        return result

    def data2xyz(self, DEM_par: str, data, data_xyz: str, dflg=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["data2xyz"] += 1

        if DEM_par is not None:
            result = self._validate(
                "data2xyz",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if data_xyz is not None and data_xyz != "-":
            Path(data_xyz).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "data2xyz",
            dflg == "-" or dflg in valid_values,
            result,
            f"dflg is not a valid value (expects: {valid_values}, got: {dflg})",
        )
        if self._wraps is not None:
            result = self._wraps.data2xyz(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "data2xyz", supplied_args, result[0])
        )
        self._on_error("data2xyz", supplied_args, result[0])
        return result

    def ScanSAR_burst_diff_intf(
        self,
        SLC1_tab: str,
        SLC2R_tab: str,
        SIM_tab: str,
        DIFF_tab: str,
        SLCR_tab: str = None,
        DIFF_dir=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ScanSAR_burst_diff_intf"] += 1

        if SLC1_tab is not None:
            result = self._validate(
                "ScanSAR_burst_diff_intf",
                SLC1_tab == "-" or Path(SLC1_tab).exists(),
                result,
                f"SLC1_tab path does not exist ({SLC1_tab})",
            )
        if SLC2R_tab is not None:
            result = self._validate(
                "ScanSAR_burst_diff_intf",
                SLC2R_tab == "-" or Path(SLC2R_tab).exists(),
                result,
                f"SLC2R_tab path does not exist ({SLC2R_tab})",
            )
        if SIM_tab is not None:
            result = self._validate(
                "ScanSAR_burst_diff_intf",
                SIM_tab == "-" or Path(SIM_tab).exists(),
                result,
                f"SIM_tab path does not exist ({SIM_tab})",
            )
        if DIFF_tab is not None and DIFF_tab != "-" and not Path(DIFF_tab).exists():
            Path(DIFF_tab).touch()
        if SLCR_tab is not None:
            result = self._validate(
                "ScanSAR_burst_diff_intf",
                SLCR_tab == "-" or Path(SLCR_tab).exists(),
                result,
                f"SLCR_tab path does not exist ({SLCR_tab})",
            )
        if self._wraps is not None:
            result = self._wraps.ScanSAR_burst_diff_intf(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "ScanSAR_burst_diff_intf", supplied_args, result[0])
        )
        self._on_error("ScanSAR_burst_diff_intf", supplied_args, result[0])
        return result

    def dem_xyz(self, DEM_par: str, DEM: str, DEM_XYZ: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dem_xyz"] += 1

        if DEM_par is not None:
            result = self._validate(
                "dem_xyz",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "dem_xyz",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if DEM_XYZ is not None and DEM_XYZ != "-":
            Path(DEM_XYZ).touch()
        if self._wraps is not None:
            result = self._wraps.dem_xyz(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dem_xyz", supplied_args, result[0])
        )
        self._on_error("dem_xyz", supplied_args, result[0])
        return result

    def look_vector(
        self,
        SLC_par: str,
        OFF_par: str,
        DEM_par: str,
        DEM: str,
        lv_theta: str,
        lv_phi: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["look_vector"] += 1

        if SLC_par is not None:
            result = self._validate(
                "look_vector",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "look_vector",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "look_vector",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "look_vector",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if lv_theta is not None and lv_theta != "-":
            Path(lv_theta).touch()
        if lv_phi is not None and lv_phi != "-":
            Path(lv_phi).touch()
        if self._wraps is not None:
            result = self._wraps.look_vector(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "look_vector", supplied_args, result[0])
        )
        self._on_error("look_vector", supplied_args, result[0])
        return result

    def create_dem_par(
        self,
        DEM_par: str,
        SLC_par: str = None,
        terra_alt=None,
        delta_y=None,
        delta_x=None,
        EPSG=None,
        iflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["create_dem_par"] += 1

        if DEM_par is not None and DEM_par != "-" and not Path(DEM_par).exists():
            Path(DEM_par).touch()
        if SLC_par is not None:
            result = self._validate(
                "create_dem_par",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "create_dem_par",
            iflg == "-" or iflg in valid_values,
            result,
            f"iflg is not a valid value (expects: {valid_values}, got: {iflg})",
        )
        if self._wraps is not None:
            result = self._wraps.create_dem_par(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "create_dem_par", supplied_args, result[0])
        )
        self._on_error("create_dem_par", supplied_args, result[0])
        return result

    def dem_x_y_z(
        self, DEM_par: str, DEM: str, DEM_X: str, DEM_Y: str, DEM_Z: str, format_flag=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dem_x_y_z"] += 1

        if DEM_par is not None:
            result = self._validate(
                "dem_x_y_z",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "dem_x_y_z",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if DEM_X is not None and DEM_X != "-":
            Path(DEM_X).touch()
        if DEM_Y is not None and DEM_Y != "-":
            Path(DEM_Y).touch()
        if DEM_Z is not None and DEM_Z != "-":
            Path(DEM_Z).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dem_x_y_z",
            format_flag == "-" or format_flag in valid_values,
            result,
            f"format_flag is not a valid value (expects: {valid_values}, got: {format_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.dem_x_y_z(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dem_x_y_z", supplied_args, result[0])
        )
        self._on_error("dem_x_y_z", supplied_args, result[0])
        return result

    def ras_clist(
        self,
        clist: str,
        ras_in: str,
        ras_out: str,
        xsf=None,
        ysf=None,
        r=None,
        g=None,
        b=None,
        xs=None,
        zflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_clist"] += 1

        if clist is not None:
            result = self._validate(
                "ras_clist",
                clist == "-" or Path(clist).exists(),
                result,
                f"clist path does not exist ({clist})",
            )
        if ras_in is not None:
            result = self._validate(
                "ras_clist",
                ras_in == "-" or Path(ras_in).exists(),
                result,
                f"ras_in path does not exist ({ras_in})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        if self._wraps is not None:
            result = self._wraps.ras_clist(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "ras_clist", supplied_args, result[0])
        )
        self._on_error("ras_clist", supplied_args, result[0])
        return result

    def dispmap_sim(
        self,
        LV: str,
        DEM_par: str,
        disp_east: str,
        disp_north: str,
        disp_up: str,
        disp_LOS: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dispmap_sim"] += 1

        if LV is not None:
            result = self._validate(
                "dispmap_sim",
                LV == "-" or Path(LV).exists(),
                result,
                f"LV path does not exist ({LV})",
            )
        if DEM_par is not None:
            result = self._validate(
                "dispmap_sim",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if disp_east is not None:
            result = self._validate(
                "dispmap_sim",
                disp_east == "-" or Path(disp_east).exists(),
                result,
                f"disp_east path does not exist ({disp_east})",
            )
        if disp_north is not None:
            result = self._validate(
                "dispmap_sim",
                disp_north == "-" or Path(disp_north).exists(),
                result,
                f"disp_north path does not exist ({disp_north})",
            )
        if disp_up is not None:
            result = self._validate(
                "dispmap_sim",
                disp_up == "-" or Path(disp_up).exists(),
                result,
                f"disp_up path does not exist ({disp_up})",
            )
        if disp_LOS is not None and disp_LOS != "-":
            Path(disp_LOS).touch()
        if self._wraps is not None:
            result = self._wraps.dispmap_sim(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dispmap_sim", supplied_args, result[0])
        )
        self._on_error("dispmap_sim", supplied_args, result[0])
        return result

    def dem_gradient(
        self, DEM_par: str, DEM: str, theta: str, phi: str, mag: str, type=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dem_gradient"] += 1

        if DEM_par is not None:
            result = self._validate(
                "dem_gradient",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "dem_gradient",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if theta is not None and theta != "-":
            Path(theta).touch()
        if phi is not None and phi != "-":
            Path(phi).touch()
        if mag is not None and mag != "-":
            Path(mag).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dem_gradient",
            type == "-" or type in valid_values,
            result,
            f"type is not a valid value (expects: {valid_values}, got: {type})",
        )
        if self._wraps is not None:
            result = self._wraps.dem_gradient(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dem_gradient", supplied_args, result[0])
        )
        self._on_error("dem_gradient", supplied_args, result[0])
        return result

    def offset_pwr_trackingm(
        self,
        MLI_1: str,
        MLI_2: str,
        DIFF_par: str,
        offs: str,
        ccp: str,
        rwin=None,
        azwin=None,
        offsets: str = None,
        n_ovr=None,
        thres=None,
        rstep=None,
        azstep=None,
        rstart=None,
        rstop=None,
        azstart=None,
        azstop=None,
        lanczos=None,
        bw_frac=None,
        pflag=None,
        pltflg=None,
        ccs: str = None,
        std_mean=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_pwr_trackingm"] += 1

        if MLI_1 is not None:
            result = self._validate(
                "offset_pwr_trackingm",
                MLI_1 == "-" or Path(MLI_1).exists(),
                result,
                f"MLI_1 path does not exist ({MLI_1})",
            )
        if MLI_2 is not None:
            result = self._validate(
                "offset_pwr_trackingm",
                MLI_2 == "-" or Path(MLI_2).exists(),
                result,
                f"MLI_2 path does not exist ({MLI_2})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "offset_pwr_trackingm",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_trackingm",
            pflag == "-" or pflag in valid_values,
            result,
            f"pflag is not a valid value (expects: {valid_values}, got: {pflag})",
        )
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "offset_pwr_trackingm",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if ccs is not None and ccs != "-":
            Path(ccs).touch()
        if self._wraps is not None:
            result = self._wraps.offset_pwr_trackingm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "offset_pwr_trackingm", supplied_args, result[0])
        )
        self._on_error("offset_pwr_trackingm", supplied_args, result[0])
        return result

    def init_offsetm(
        self,
        MLI_1,
        MLI_2,
        DIFF_par,
        rlks=None,
        azlks=None,
        rpos=None,
        azpos=None,
        offr=None,
        offaz=None,
        thres=None,
        patch=None,
        cflag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["init_offsetm"] += 1

        valid_values = [0, 1] + [None]
        result = self._validate(
            "init_offsetm",
            cflag == "-" or cflag in valid_values,
            result,
            f"cflag is not a valid value (expects: {valid_values}, got: {cflag})",
        )
        if self._wraps is not None:
            result = self._wraps.init_offsetm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "init_offsetm", supplied_args, result[0])
        )
        self._on_error("init_offsetm", supplied_args, result[0])
        return result

    def gc_map_fd(
        self,
        MLI_par: str,
        fd_tab: str,
        DEM_par: str,
        DEM: str,
        DEM_seg_par: str,
        DEM_seg: str,
        lookup_table: str,
        lat_ovr=None,
        lon_ovr=None,
        sim_sar: str = None,
        u: str = None,
        v: str = None,
        inc: str = None,
        psi: str = None,
        pix: str = None,
        ls_map: str = None,
        frame=None,
        ls_mode=None,
        r_ovr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gc_map_fd"] += 1

        if MLI_par is not None:
            result = self._validate(
                "gc_map_fd",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if fd_tab is not None:
            result = self._validate(
                "gc_map_fd",
                fd_tab == "-" or Path(fd_tab).exists(),
                result,
                f"fd_tab path does not exist ({fd_tab})",
            )
        if DEM_par is not None:
            result = self._validate(
                "gc_map_fd",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "gc_map_fd",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if (
            DEM_seg_par is not None
            and DEM_seg_par != "-"
            and not Path(DEM_seg_par).exists()
        ):
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "gc_map_fd",
            ls_mode == "-" or ls_mode in valid_values,
            result,
            f"ls_mode is not a valid value (expects: {valid_values}, got: {ls_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.gc_map_fd(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gc_map_fd", supplied_args, result[0])
        )
        self._on_error("gc_map_fd", supplied_args, result[0])
        return result

    def phase_sim_orb(
        self,
        SLC1_par: str,
        SLC2R_par: str,
        OFF_par: str,
        hgt,
        sim_unw: str,
        SLC_ref_par: str = None,
        definition=None,
        delta_t=None,
        int_mode=None,
        ph_mode=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["phase_sim_orb"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "phase_sim_orb",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2R_par is not None:
            result = self._validate(
                "phase_sim_orb",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "phase_sim_orb",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if sim_unw is not None and sim_unw != "-":
            Path(sim_unw).touch()
        if SLC_ref_par is not None:
            result = self._validate(
                "phase_sim_orb",
                SLC_ref_par == "-" or Path(SLC_ref_par).exists(),
                result,
                f"SLC_ref_par path does not exist ({SLC_ref_par})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "phase_sim_orb",
            int_mode == "-" or int_mode in valid_values,
            result,
            f"int_mode is not a valid value (expects: {valid_values}, got: {int_mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "phase_sim_orb",
            ph_mode == "-" or ph_mode in valid_values,
            result,
            f"ph_mode is not a valid value (expects: {valid_values}, got: {ph_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.phase_sim_orb(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "phase_sim_orb", supplied_args, result[0])
        )
        self._on_error("phase_sim_orb", supplied_args, result[0])
        return result

    def gec_map(
        self,
        SLC_par: str,
        OFF_par: str,
        DEM_par: str,
        href: str,
        DEM_seg_par: str,
        lookup_table: str,
        lat_ovr=None,
        lon_ovr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gec_map"] += 1

        if SLC_par is not None:
            result = self._validate(
                "gec_map",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "gec_map",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "gec_map",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if href is not None:
            result = self._validate(
                "gec_map",
                href == "-" or Path(href).exists(),
                result,
                f"href path does not exist ({href})",
            )
        if (
            DEM_seg_par is not None
            and DEM_seg_par != "-"
            and not Path(DEM_seg_par).exists()
        ):
            Path(DEM_seg_par).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if self._wraps is not None:
            result = self._wraps.gec_map(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gec_map", supplied_args, result[0])
        )
        self._on_error("gec_map", supplied_args, result[0])
        return result

    def dh_map_orb(
        self,
        SLC1_par: str,
        SLC2R_par: str,
        OFF_par: str,
        hgt,
        dp,
        dpdh: str,
        dh: str,
        SLC_ref_par: str = None,
        int_mode=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dh_map_orb"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "dh_map_orb",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2R_par is not None:
            result = self._validate(
                "dh_map_orb",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "dh_map_orb",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if dpdh is not None and dpdh != "-":
            Path(dpdh).touch()
        if dh is not None and dh != "-":
            Path(dh).touch()
        if SLC_ref_par is not None:
            result = self._validate(
                "dh_map_orb",
                SLC_ref_par == "-" or Path(SLC_ref_par).exists(),
                result,
                f"SLC_ref_par path does not exist ({SLC_ref_par})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dh_map_orb",
            int_mode == "-" or int_mode in valid_values,
            result,
            f"int_mode is not a valid value (expects: {valid_values}, got: {int_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.dh_map_orb(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dh_map_orb", supplied_args, result[0])
        )
        self._on_error("dh_map_orb", supplied_args, result[0])
        return result

    def offset_subm(self, offs: str, DIFF_par: str, offs_sub: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_subm"] += 1

        if offs is not None:
            result = self._validate(
                "offset_subm",
                offs == "-" or Path(offs).exists(),
                result,
                f"offs path does not exist ({offs})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "offset_subm",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if offs_sub is not None and offs_sub != "-":
            Path(offs_sub).touch()
        if self._wraps is not None:
            result = self._wraps.offset_subm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "offset_subm", supplied_args, result[0])
        )
        self._on_error("offset_subm", supplied_args, result[0])
        return result

    def offset_trackingm(
        self,
        offs: str,
        snr,
        MLI_par: str,
        DIFF_par: str,
        coffs_map: str,
        coffsets: str = None,
        mode=None,
        thres=None,
        poly_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_trackingm"] += 1

        if offs is not None:
            result = self._validate(
                "offset_trackingm",
                offs == "-" or Path(offs).exists(),
                result,
                f"offs path does not exist ({offs})",
            )
        if MLI_par is not None:
            result = self._validate(
                "offset_trackingm",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "offset_trackingm",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if coffs_map is not None and coffs_map != "-":
            Path(coffs_map).touch()
        if coffsets is not None and coffsets != "-":
            Path(coffsets).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "offset_trackingm",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_trackingm",
            poly_flag == "-" or poly_flag in valid_values,
            result,
            f"poly_flag is not a valid value (expects: {valid_values}, got: {poly_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.offset_trackingm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "offset_trackingm", supplied_args, result[0])
        )
        self._on_error("offset_trackingm", supplied_args, result[0])
        return result

    def comb_interfs(
        self,
        int_1,
        int_2,
        base_1,
        base_2,
        factor_1,
        factor_2,
        width,
        combi_out,
        combi_base,
        sm=None,
        Only=None,
        The=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["comb_interfs"] += 1

        if self._wraps is not None:
            result = self._wraps.comb_interfs(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "comb_interfs", supplied_args, result[0])
        )
        self._on_error("comb_interfs", supplied_args, result[0])
        return result

    def gc_insar(self, SLC_par: str, OFF_par: str, hgt, DEM_par, lookup_table: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gc_insar"] += 1

        if SLC_par is not None:
            result = self._validate(
                "gc_insar",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "gc_insar",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if self._wraps is not None:
            result = self._wraps.gc_insar(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gc_insar", supplied_args, result[0])
        )
        self._on_error("gc_insar", supplied_args, result[0])
        return result

    def par_KS_geo(self, HDF5: str, MLI_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_KS_geo"] += 1

        if HDF5 is not None:
            result = self._validate(
                "par_KS_geo",
                HDF5 == "-" or Path(HDF5).exists(),
                result,
                f"HDF5 path does not exist ({HDF5})",
            )
        if MLI_par is not None:
            result = self._validate(
                "par_KS_geo",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if self._wraps is not None:
            result = self._wraps.par_KS_geo(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "par_KS_geo", supplied_args, result[0])
        )
        self._on_error("par_KS_geo", supplied_args, result[0])
        return result

    def offset_pwrm(
        self,
        MLI_1: str,
        MLI_2: str,
        DIFF_par: str,
        offs: str,
        ccp: str,
        rwin=None,
        azwin=None,
        offsets: str = None,
        n_ovr=None,
        nr=None,
        naz=None,
        thres=None,
        lanczos=None,
        bw_frac=None,
        pflag=None,
        pltflg=None,
        ccs: str = None,
        std_mean=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_pwrm"] += 1

        if MLI_1 is not None:
            result = self._validate(
                "offset_pwrm",
                MLI_1 == "-" or Path(MLI_1).exists(),
                result,
                f"MLI_1 path does not exist ({MLI_1})",
            )
        if MLI_2 is not None:
            result = self._validate(
                "offset_pwrm",
                MLI_2 == "-" or Path(MLI_2).exists(),
                result,
                f"MLI_2 path does not exist ({MLI_2})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "offset_pwrm",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwrm",
            pflag == "-" or pflag in valid_values,
            result,
            f"pflag is not a valid value (expects: {valid_values}, got: {pflag})",
        )
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "offset_pwrm",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if ccs is not None and ccs != "-":
            Path(ccs).touch()
        if self._wraps is not None:
            result = self._wraps.offset_pwrm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "offset_pwrm", supplied_args, result[0])
        )
        self._on_error("offset_pwrm", supplied_args, result[0])
        return result

    def coord_to_sarpix_list(
        self,
        SLC_par: str,
        OFF_par: str,
        DEM_par: str,
        MAP_coord: str,
        SAR_coord: str,
        DIFF_par: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["coord_to_sarpix_list"] += 1

        if SLC_par is not None:
            result = self._validate(
                "coord_to_sarpix_list",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "coord_to_sarpix_list",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "coord_to_sarpix_list",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if MAP_coord is not None:
            result = self._validate(
                "coord_to_sarpix_list",
                MAP_coord == "-" or Path(MAP_coord).exists(),
                result,
                f"MAP_coord path does not exist ({MAP_coord})",
            )
        if SAR_coord is not None and SAR_coord != "-":
            Path(SAR_coord).touch()
        if DIFF_par is not None:
            result = self._validate(
                "coord_to_sarpix_list",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if self._wraps is not None:
            result = self._wraps.coord_to_sarpix_list(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "coord_to_sarpix_list", supplied_args, result[0])
        )
        self._on_error("coord_to_sarpix_list", supplied_args, result[0])
        return result

    def offset_fitm(
        self,
        offs: str,
        ccp,
        DIFF_par: str,
        coffs: str = None,
        coffsets: str = None,
        thres=None,
        npoly=None,
        interact_mode=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_fitm"] += 1

        if offs is not None:
            result = self._validate(
                "offset_fitm",
                offs == "-" or Path(offs).exists(),
                result,
                f"offs path does not exist ({offs})",
            )
        if DIFF_par is not None:
            result = self._validate(
                "offset_fitm",
                DIFF_par == "-" or Path(DIFF_par).exists(),
                result,
                f"DIFF_par path does not exist ({DIFF_par})",
            )
        if coffs is not None and coffs != "-":
            Path(coffs).touch()
        if coffsets is not None and coffsets != "-":
            Path(coffsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_fitm",
            interact_mode == "-" or interact_mode in valid_values,
            result,
            f"interact_mode is not a valid value (expects: {valid_values}, got: {interact_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.offset_fitm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "offset_fitm", supplied_args, result[0])
        )
        self._on_error("offset_fitm", supplied_args, result[0])
        return result

    def dispmap_ENU(
        self,
        LV_tab: str,
        DISP_tab: str,
        SIGMA_tab: str,
        DEM_par: str,
        disp_east: str,
        disp_north: str,
        disp_up: str,
        sigma_east: str = None,
        sigma_north: str = None,
        sigma_up: str = None,
        chi2: str = None,
        min_obs=None,
        tol=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dispmap_ENU"] += 1

        if LV_tab is not None:
            result = self._validate(
                "dispmap_ENU",
                LV_tab == "-" or Path(LV_tab).exists(),
                result,
                f"LV_tab path does not exist ({LV_tab})",
            )
        if DISP_tab is not None:
            result = self._validate(
                "dispmap_ENU",
                DISP_tab == "-" or Path(DISP_tab).exists(),
                result,
                f"DISP_tab path does not exist ({DISP_tab})",
            )
        if SIGMA_tab is not None:
            result = self._validate(
                "dispmap_ENU",
                SIGMA_tab == "-" or Path(SIGMA_tab).exists(),
                result,
                f"SIGMA_tab path does not exist ({SIGMA_tab})",
            )
        if DEM_par is not None:
            result = self._validate(
                "dispmap_ENU",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if disp_east is not None and disp_east != "-":
            Path(disp_east).touch()
        if disp_north is not None and disp_north != "-":
            Path(disp_north).touch()
        if disp_up is not None and disp_up != "-":
            Path(disp_up).touch()
        if sigma_east is not None and sigma_east != "-":
            Path(sigma_east).touch()
        if sigma_north is not None and sigma_north != "-":
            Path(sigma_north).touch()
        if sigma_up is not None and sigma_up != "-":
            Path(sigma_up).touch()
        if chi2 is not None and chi2 != "-":
            Path(chi2).touch()
        if self._wraps is not None:
            result = self._wraps.dispmap_ENU(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dispmap_ENU", supplied_args, result[0])
        )
        self._on_error("dispmap_ENU", supplied_args, result[0])
        return result

    def dem_coord(self, DEM_par: str, east: str, north: str, dtype=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dem_coord"] += 1

        if DEM_par is not None:
            result = self._validate(
                "dem_coord",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if east is not None and east != "-":
            Path(east).touch()
        if north is not None and north != "-":
            Path(north).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dem_coord",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.dem_coord(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "dem_coord", supplied_args, result[0])
        )
        self._on_error("dem_coord", supplied_args, result[0])
        return result

    def rotate_image(
        self,
        data_in: str,
        width_in,
        angle,
        data_out: str,
        width_out,
        nlines_out,
        interp_mode=None,
        dtype=None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rotate_image"] += 1

        if data_in is not None:
            result = self._validate(
                "rotate_image",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7] + [None]
        result = self._validate(
            "rotate_image",
            interp_mode == "-" or interp_mode in valid_values,
            result,
            f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})",
        )
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        result = self._validate(
            "rotate_image",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.rotate_image(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "rotate_image", supplied_args, result[0])
        )
        self._on_error("rotate_image", supplied_args, result[0])
        return result

    def geocode_back(
        self,
        data_in: str,
        width_in,
        lookup_table: str,
        data_out: str,
        width_out,
        nlines_out=None,
        interp_mode=None,
        dtype=None,
        lr_in=None,
        lr_out=None,
        order=None,
        e_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["geocode_back"] += 1

        if data_in is not None:
            result = self._validate(
                "geocode_back",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if lookup_table is not None:
            result = self._validate(
                "geocode_back",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        result = self._validate(
            "geocode_back",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "geocode_back",
            e_flag == "-" or e_flag in valid_values,
            result,
            f"e_flag is not a valid value (expects: {valid_values}, got: {e_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.geocode_back(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "geocode_back", supplied_args, result[0])
        )
        self._on_error("geocode_back", supplied_args, result[0])
        return result

    def sarpix_coord(
        self,
        SLC_par: str,
        OFF_par: str = None,
        DEM_par: str = None,
        azlin=None,
        rpix=None,
        ref_hgt=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["sarpix_coord"] += 1

        if SLC_par is not None:
            result = self._validate(
                "sarpix_coord",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "sarpix_coord",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "sarpix_coord",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if self._wraps is not None:
            result = self._wraps.sarpix_coord(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "sarpix_coord", supplied_args, result[0])
        )
        self._on_error("sarpix_coord", supplied_args, result[0])
        return result

    def resamp_image(
        self,
        data_in: str,
        width_in,
        xscale,
        yscale,
        data_out: str,
        width_out,
        nlines_out,
        interp_mode=None,
        dtype=None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["resamp_image"] += 1

        if data_in is not None:
            result = self._validate(
                "resamp_image",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        result = self._validate(
            "resamp_image",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.resamp_image(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "resamp_image", supplied_args, result[0])
        )
        self._on_error("resamp_image", supplied_args, result[0])
        return result

    def pol2rec(
        self,
        data1: str,
        SLC_par1: str,
        data2: str,
        SLC_par2: str,
        pix_size: str,
        dtype,
        mode=None,
        xmin=None,
        nx=None,
        ymin=None,
        ny=None,
        rmax=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["pol2rec"] += 1

        if data1 is not None:
            result = self._validate(
                "pol2rec",
                data1 == "-" or Path(data1).exists(),
                result,
                f"data1 path does not exist ({data1})",
            )
        if SLC_par1 is not None:
            result = self._validate(
                "pol2rec",
                SLC_par1 == "-" or Path(SLC_par1).exists(),
                result,
                f"SLC_par1 path does not exist ({SLC_par1})",
            )
        if data2 is not None and data2 != "-":
            Path(data2).touch()
        if SLC_par2 is not None and SLC_par2 != "-":
            Path(SLC_par2).touch()
        if pix_size is not None and pix_size != "-":
            Path(pix_size).touch()
        valid_values = [0, 1]
        result = self._validate(
            "pol2rec",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "pol2rec",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.pol2rec(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "pol2rec", supplied_args, result[0])
        )
        self._on_error("pol2rec", supplied_args, result[0])
        return result

    def WSS_interp(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        DIFF_par,
        SLC_2R: str,
        SLC2R_par: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["WSS_interp"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "WSS_interp",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "WSS_interp",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "WSS_interp",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "WSS_interp",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()
        if self._wraps is not None:
            result = self._wraps.WSS_interp(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "WSS_interp", supplied_args, result[0])
        )
        self._on_error("WSS_interp", supplied_args, result[0])
        return result

    def gc_GPRI_map(
        self,
        MLI_par: str,
        DEM_par: str,
        DEM: str,
        DEM_seg_par: str,
        DEM_seg: str,
        lookup_table: str,
        lat_ovr=None,
        lon_ovr=None,
        sim_sar: str = None,
        lv_theta: str = None,
        lv_phi: str = None,
        u: str = None,
        v: str = None,
        inc: str = None,
        psi: str = None,
        pix: str = None,
        ls_map: str = None,
        frame=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gc_GPRI_map"] += 1

        if MLI_par is not None:
            result = self._validate(
                "gc_GPRI_map",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "gc_GPRI_map",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if DEM is not None:
            result = self._validate(
                "gc_GPRI_map",
                DEM == "-" or Path(DEM).exists(),
                result,
                f"DEM path does not exist ({DEM})",
            )
        if (
            DEM_seg_par is not None
            and DEM_seg_par != "-"
            and not Path(DEM_seg_par).exists()
        ):
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if lv_theta is not None and lv_theta != "-":
            Path(lv_theta).touch()
        if lv_phi is not None and lv_phi != "-":
            Path(lv_phi).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()
        if self._wraps is not None:
            result = self._wraps.gc_GPRI_map(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DIFF", "gc_GPRI_map", supplied_args, result[0])
        )
        self._on_error("gc_GPRI_map", supplied_args, result[0])
        return result

    def dop_mlcc(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        plot_data: str = None,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dop_mlcc"] += 1

        if SAR_par is not None:
            result = self._validate(
                "dop_mlcc",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "dop_mlcc",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "dop_mlcc",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if plot_data is not None and plot_data != "-":
            Path(plot_data).touch()
        if self._wraps is not None:
            result = self._wraps.dop_mlcc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "dop_mlcc", supplied_args, result[0])
        )
        self._on_error("dop_mlcc", supplied_args, result[0])
        return result

    def ERS_proc_ASF_2000(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_ASF_2000"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_ASF_2000",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_ASF_2000(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_ASF_2000", supplied_args, result[0])
        )
        self._on_error("ERS_proc_ASF_2000", supplied_args, result[0])
        return result

    def ERS_proc_ASF(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_ASF"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_ASF",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_ASF(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_ASF", supplied_args, result[0])
        )
        self._on_error("ERS_proc_ASF", supplied_args, result[0])
        return result

    def doppler_2d(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        dop2d: str,
        loff=None,
        blsz=None,
        nbl=None,
        a2_flg=None,
        b0_flg=None,
        b1_flg=None,
        c0_flg=None,
        ambig_flag=None,
        namb=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["doppler_2d"] += 1

        if SAR_par is not None:
            result = self._validate(
                "doppler_2d",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "doppler_2d",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "doppler_2d",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if dop2d is not None and dop2d != "-":
            Path(dop2d).touch()
        if self._wraps is not None:
            result = self._wraps.doppler_2d(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "doppler_2d", supplied_args, result[0])
        )
        self._on_error("doppler_2d", supplied_args, result[0])
        return result

    def ERS_proc_ESA(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_ESA"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_ESA",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_ESA(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_ESA", supplied_args, result[0])
        )
        self._on_error("ERS_proc_ESA", supplied_args, result[0])
        return result

    def az_proc(
        self,
        SAR_par: str,
        PROC_par: str,
        rc_data: str,
        SLC: str,
        az_patch=None,
        SLC_format=None,
        cal_fact=None,
        SLC_type=None,
        kaiser=None,
        npatch=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["az_proc"] += 1

        if SAR_par is not None:
            result = self._validate(
                "az_proc",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "az_proc",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if rc_data is not None:
            result = self._validate(
                "az_proc",
                rc_data == "-" or Path(rc_data).exists(),
                result,
                f"rc_data path does not exist ({rc_data})",
            )
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "az_proc",
            SLC_format == "-" or SLC_format in valid_values,
            result,
            f"SLC_format is not a valid value (expects: {valid_values}, got: {SLC_format})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "az_proc",
            SLC_type == "-" or SLC_type in valid_values,
            result,
            f"SLC_type is not a valid value (expects: {valid_values}, got: {SLC_type})",
        )
        if self._wraps is not None:
            result = self._wraps.az_proc(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "az_proc", supplied_args, result[0]))
        self._on_error("az_proc", supplied_args, result[0])
        return result

    def dop_interf(
        self,
        SAR_par1,
        PROC_par1,
        PROC_par2,
        PROC_par1_out: str,
        PROC_par2_out: str,
        dop: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dop_interf"] += 1

        if PROC_par1_out is not None and PROC_par1_out != "-":
            Path(PROC_par1_out).touch()
        if PROC_par2_out is not None and PROC_par2_out != "-":
            Path(PROC_par2_out).touch()
        if dop is not None and dop != "-":
            Path(dop).touch()
        if self._wraps is not None:
            result = self._wraps.dop_interf(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "dop_interf", supplied_args, result[0])
        )
        self._on_error("dop_interf", supplied_args, result[0])
        return result

    def CS_proc(
        self, HDF5: str, SAR_par: str, PROC_par: str, raw_out: str, loff=None, nl=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["CS_proc"] += 1

        if HDF5 is not None:
            result = self._validate(
                "CS_proc",
                HDF5 == "-" or Path(HDF5).exists(),
                result,
                f"HDF5 path does not exist ({HDF5})",
            )
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()
        if self._wraps is not None:
            result = self._wraps.CS_proc(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "CS_proc", supplied_args, result[0]))
        self._on_error("CS_proc", supplied_args, result[0])
        return result

    def azsp_SLC(
        self,
        SAR_par: str,
        PROC_par: str,
        SAR_data: str,
        spectrum,
        loff=None,
        roff=None,
        nsub=None,
        data_format=None,
        pltflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["azsp_SLC"] += 1

        if SAR_par is not None:
            result = self._validate(
                "azsp_SLC",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "azsp_SLC",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if SAR_data is not None:
            result = self._validate(
                "azsp_SLC",
                SAR_data == "-" or Path(SAR_data).exists(),
                result,
                f"SAR_data path does not exist ({SAR_data})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "azsp_SLC",
            data_format == "-" or data_format in valid_values,
            result,
            f"data_format is not a valid value (expects: {valid_values}, got: {data_format})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "azsp_SLC",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.azsp_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "azsp_SLC", supplied_args, result[0])
        )
        self._on_error("azsp_SLC", supplied_args, result[0])
        return result

    def pre_rc_JERS(
        self,
        SAR_par: str,
        PROC_par: str,
        rspec: str,
        signal_data: str,
        rc_data: str,
        prefilt_dec=None,
        kaiser=None,
        filt_lm=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["pre_rc_JERS"] += 1

        if SAR_par is not None:
            result = self._validate(
                "pre_rc_JERS",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "pre_rc_JERS",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if rspec is not None:
            result = self._validate(
                "pre_rc_JERS",
                rspec == "-" or Path(rspec).exists(),
                result,
                f"rspec path does not exist ({rspec})",
            )
        if signal_data is not None:
            result = self._validate(
                "pre_rc_JERS",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()
        if self._wraps is not None:
            result = self._wraps.pre_rc_JERS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "pre_rc_JERS", supplied_args, result[0])
        )
        self._on_error("pre_rc_JERS", supplied_args, result[0])
        return result

    def ERS_proc_NASDA(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_NASDA"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_NASDA",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_NASDA(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_NASDA", supplied_args, result[0])
        )
        self._on_error("ERS_proc_NASDA", supplied_args, result[0])
        return result

    def ERS_proc_ARG(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_ARG"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_ARG",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_ARG(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_ARG", supplied_args, result[0])
        )
        self._on_error("ERS_proc_ARG", supplied_args, result[0])
        return result

    def PALSAR_proc(
        self,
        CEOS_SAR_leader: str,
        SAR_par: str,
        PROC_par: str,
        CEOS_raw_data: str,
        raw_out: str,
        TX_POL=None,
        RX_POL=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["PALSAR_proc"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "PALSAR_proc",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if CEOS_raw_data is not None:
            result = self._validate(
                "PALSAR_proc",
                CEOS_raw_data == "-" or Path(CEOS_raw_data).exists(),
                result,
                f"CEOS_raw_data path does not exist ({CEOS_raw_data})",
            )
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "PALSAR_proc",
            TX_POL == "-" or TX_POL in valid_values,
            result,
            f"TX_POL is not a valid value (expects: {valid_values}, got: {TX_POL})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "PALSAR_proc",
            RX_POL == "-" or RX_POL in valid_values,
            result,
            f"RX_POL is not a valid value (expects: {valid_values}, got: {RX_POL})",
        )
        if self._wraps is not None:
            result = self._wraps.PALSAR_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "PALSAR_proc", supplied_args, result[0])
        )
        self._on_error("PALSAR_proc", supplied_args, result[0])
        return result

    def rspec_real(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        range_spec: str,
        loff=None,
        nlspec=None,
        nrfft=None,
        pltflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rspec_real"] += 1

        if SAR_par is not None:
            result = self._validate(
                "rspec_real",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "rspec_real",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "rspec_real",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if range_spec is not None and range_spec != "-":
            Path(range_spec).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "rspec_real",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.rspec_real(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "rspec_real", supplied_args, result[0])
        )
        self._on_error("rspec_real", supplied_args, result[0])
        return result

    def rspec_IQ(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        range_spec: str,
        loff=None,
        nlspec=None,
        nrfft=None,
        roff=None,
        pltflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rspec_IQ"] += 1

        if SAR_par is not None:
            result = self._validate(
                "rspec_IQ",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "rspec_IQ",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "rspec_IQ",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if range_spec is not None and range_spec != "-":
            Path(range_spec).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "rspec_IQ",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.rspec_IQ(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "rspec_IQ", supplied_args, result[0])
        )
        self._on_error("rspec_IQ", supplied_args, result[0])
        return result

    def af(
        self,
        SAR_par: str,
        PROC_par: str,
        SLC: str,
        rwin=None,
        azwin=None,
        dr=None,
        daz=None,
        thres=None,
        update_flg=None,
        a1_flg=None,
        b0_flg=None,
        offsets: str = None,
        dac_flg=None,
        n_ovr=None,
        roff=None,
        azoff=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["af"] += 1

        if SAR_par is not None:
            result = self._validate(
                "af",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "af",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if SLC is not None:
            result = self._validate(
                "af",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "af",
            update_flg == "-" or update_flg in valid_values,
            result,
            f"update_flg is not a valid value (expects: {valid_values}, got: {update_flg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "af",
            a1_flg == "-" or a1_flg in valid_values,
            result,
            f"a1_flg is not a valid value (expects: {valid_values}, got: {a1_flg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "af",
            b0_flg == "-" or b0_flg in valid_values,
            result,
            f"b0_flg is not a valid value (expects: {valid_values}, got: {b0_flg})",
        )
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "af",
            dac_flg == "-" or dac_flg in valid_values,
            result,
            f"dac_flg is not a valid value (expects: {valid_values}, got: {dac_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.af(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "af", supplied_args, result[0]))
        self._on_error("af", supplied_args, result[0])
        return result

    def hist_IQ(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        historgram: str,
        loff=None,
        nl=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["hist_IQ"] += 1

        if SAR_par is not None:
            result = self._validate(
                "hist_IQ",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "hist_IQ",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "hist_IQ",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if historgram is not None and historgram != "-":
            Path(historgram).touch()
        if self._wraps is not None:
            result = self._wraps.hist_IQ(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "hist_IQ", supplied_args, result[0]))
        self._on_error("hist_IQ", supplied_args, result[0])
        return result

    def PALSAR_burst_sync(
        self,
        SAR_par1: str,
        PROC_par1: str,
        raw1: str,
        SAR_par2: str,
        PROC_par2: str,
        raw2: str,
        PROC_par1_out: str,
        raw1_out: str,
        PROC_par2_out: str,
        raw2_out: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["PALSAR_burst_sync"] += 1

        if SAR_par1 is not None:
            result = self._validate(
                "PALSAR_burst_sync",
                SAR_par1 == "-" or Path(SAR_par1).exists(),
                result,
                f"SAR_par1 path does not exist ({SAR_par1})",
            )
        if PROC_par1 is not None:
            result = self._validate(
                "PALSAR_burst_sync",
                PROC_par1 == "-" or Path(PROC_par1).exists(),
                result,
                f"PROC_par1 path does not exist ({PROC_par1})",
            )
        if raw1 is not None:
            result = self._validate(
                "PALSAR_burst_sync",
                raw1 == "-" or Path(raw1).exists(),
                result,
                f"raw1 path does not exist ({raw1})",
            )
        if SAR_par2 is not None:
            result = self._validate(
                "PALSAR_burst_sync",
                SAR_par2 == "-" or Path(SAR_par2).exists(),
                result,
                f"SAR_par2 path does not exist ({SAR_par2})",
            )
        if PROC_par2 is not None:
            result = self._validate(
                "PALSAR_burst_sync",
                PROC_par2 == "-" or Path(PROC_par2).exists(),
                result,
                f"PROC_par2 path does not exist ({PROC_par2})",
            )
        if raw2 is not None:
            result = self._validate(
                "PALSAR_burst_sync",
                raw2 == "-" or Path(raw2).exists(),
                result,
                f"raw2 path does not exist ({raw2})",
            )
        if PROC_par1_out is not None and PROC_par1_out != "-":
            Path(PROC_par1_out).touch()
        if raw1_out is not None and raw1_out != "-":
            Path(raw1_out).touch()
        if PROC_par2_out is not None and PROC_par2_out != "-":
            Path(PROC_par2_out).touch()
        if raw2_out is not None and raw2_out != "-":
            Path(raw2_out).touch()
        if self._wraps is not None:
            result = self._wraps.PALSAR_burst_sync(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "PALSAR_burst_sync", supplied_args, result[0])
        )
        self._on_error("PALSAR_burst_sync", supplied_args, result[0])
        return result

    def swap_IQ(self, SAR_par: str, raw_IQ: str, raw_IQ_swap: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["swap_IQ"] += 1

        if SAR_par is not None:
            result = self._validate(
                "swap_IQ",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if raw_IQ is not None:
            result = self._validate(
                "swap_IQ",
                raw_IQ == "-" or Path(raw_IQ).exists(),
                result,
                f"raw_IQ path does not exist ({raw_IQ})",
            )
        if raw_IQ_swap is not None and raw_IQ_swap != "-":
            Path(raw_IQ_swap).touch()
        if self._wraps is not None:
            result = self._wraps.swap_IQ(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "swap_IQ", supplied_args, result[0]))
        self._on_error("swap_IQ", supplied_args, result[0])
        return result

    def dop_ambig(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        algorithm=None,
        loff=None,
        output_plot: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dop_ambig"] += 1

        if SAR_par is not None:
            result = self._validate(
                "dop_ambig",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "dop_ambig",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "dop_ambig",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        valid_values = [1, 2] + [None]
        result = self._validate(
            "dop_ambig",
            algorithm == "-" or algorithm in valid_values,
            result,
            f"algorithm is not a valid value (expects: {valid_values}, got: {algorithm})",
        )
        if output_plot is not None and output_plot != "-":
            Path(output_plot).touch()
        if self._wraps is not None:
            result = self._wraps.dop_ambig(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "dop_ambig", supplied_args, result[0])
        )
        self._on_error("dop_ambig", supplied_args, result[0])
        return result

    def PRC_proc(self, PROC_par: str, PRC, nstate=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["PRC_proc"] += 1

        if PROC_par is not None:
            result = self._validate(
                "PRC_proc",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if self._wraps is not None:
            result = self._wraps.PRC_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "PRC_proc", supplied_args, result[0])
        )
        self._on_error("PRC_proc", supplied_args, result[0])
        return result

    def rc_fmcw(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        rc_data: str,
        nrc_off,
        nrc_samp=None,
        loff=None,
        nl=None,
        kaiser=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rc_fmcw"] += 1

        if SAR_par is not None:
            result = self._validate(
                "rc_fmcw",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "rc_fmcw",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "rc_fmcw",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()
        if self._wraps is not None:
            result = self._wraps.rc_fmcw(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "rc_fmcw", supplied_args, result[0]))
        self._on_error("rc_fmcw", supplied_args, result[0])
        return result

    def RSAT_lks(
        self, SLC_PROC_par: str, MLI_PROC_par: str, SLC_image: str, ML_image, kaiser=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["RSAT_lks"] += 1

        if SLC_PROC_par is not None:
            result = self._validate(
                "RSAT_lks",
                SLC_PROC_par == "-" or Path(SLC_PROC_par).exists(),
                result,
                f"SLC_PROC_par path does not exist ({SLC_PROC_par})",
            )
        if MLI_PROC_par is not None and MLI_PROC_par != "-":
            Path(MLI_PROC_par).touch()
        if SLC_image is not None:
            result = self._validate(
                "RSAT_lks",
                SLC_image == "-" or Path(SLC_image).exists(),
                result,
                f"SLC_image path does not exist ({SLC_image})",
            )
        if self._wraps is not None:
            result = self._wraps.RSAT_lks(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "RSAT_lks", supplied_args, result[0])
        )
        self._on_error("RSAT_lks", supplied_args, result[0])
        return result

    def extract_psd(self, spectra, num, output_spectrum):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["extract_psd"] += 1

        if self._wraps is not None:
            result = self._wraps.extract_psd(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "extract_psd", supplied_args, result[0])
        )
        self._on_error("extract_psd", supplied_args, result[0])
        return result

    def doppler_real(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        doppler: str,
        loff=None,
        nsub=None,
        ambig_flag=None,
        namb=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["doppler_real"] += 1

        if SAR_par is not None:
            result = self._validate(
                "doppler_real",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "doppler_real",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "doppler_real",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if doppler is not None and doppler != "-":
            Path(doppler).touch()
        if self._wraps is not None:
            result = self._wraps.doppler_real(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "doppler_real", supplied_args, result[0])
        )
        self._on_error("doppler_real", supplied_args, result[0])
        return result

    def pre_rc(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        rc_data: str,
        prefilt_dec=None,
        loff=None,
        nl=None,
        nr_samp=None,
        kaiser=None,
        filt_lm=None,
        nr_ext=None,
        fr_ext=None,
        pre_ext=None,
        post_ext=None,
        RFI_filt=None,
        RFI_thres=None,
        fc_offset=None,
        win_bw=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["pre_rc"] += 1

        if SAR_par is not None:
            result = self._validate(
                "pre_rc",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "pre_rc",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "pre_rc",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "pre_rc",
            RFI_filt == "-" or RFI_filt in valid_values,
            result,
            f"RFI_filt is not a valid value (expects: {valid_values}, got: {RFI_filt})",
        )
        if self._wraps is not None:
            result = self._wraps.pre_rc(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "pre_rc", supplied_args, result[0]))
        self._on_error("pre_rc", supplied_args, result[0])
        return result

    def PALSAR_proc_WB(
        self,
        CEOS_SAR_leader: str,
        SAR_par: str,
        PROC_par: str,
        CEOS_raw_data: str,
        beam: str,
        raw_out: str,
        prf: str = None,
        wflg: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["PALSAR_proc_WB"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "PALSAR_proc_WB",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if CEOS_raw_data is not None:
            result = self._validate(
                "PALSAR_proc_WB",
                CEOS_raw_data == "-" or Path(CEOS_raw_data).exists(),
                result,
                f"CEOS_raw_data path does not exist ({CEOS_raw_data})",
            )
        if beam is not None:
            result = self._validate(
                "PALSAR_proc_WB",
                beam == "-" or Path(beam).exists(),
                result,
                f"beam path does not exist ({beam})",
            )
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()
        if prf is not None:
            result = self._validate(
                "PALSAR_proc_WB",
                prf == "-" or Path(prf).exists(),
                result,
                f"prf path does not exist ({prf})",
            )
        if wflg is not None:
            result = self._validate(
                "PALSAR_proc_WB",
                wflg == "-" or Path(wflg).exists(),
                result,
                f"wflg path does not exist ({wflg})",
            )
        if self._wraps is not None:
            result = self._wraps.PALSAR_proc_WB(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "PALSAR_proc_WB", supplied_args, result[0])
        )
        self._on_error("PALSAR_proc_WB", supplied_args, result[0])
        return result

    def ORRM_proc(self, PROC_par: str, ORRM: str, nstate=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ORRM_proc"] += 1

        if PROC_par is not None and PROC_par != "-" and not Path(PROC_par).exists():
            Path(PROC_par).touch()
        if ORRM is not None:
            result = self._validate(
                "ORRM_proc",
                ORRM == "-" or Path(ORRM).exists(),
                result,
                f"ORRM path does not exist ({ORRM})",
            )
        if self._wraps is not None:
            result = self._wraps.ORRM_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ORRM_proc", supplied_args, result[0])
        )
        self._on_error("ORRM_proc", supplied_args, result[0])
        return result

    def ERS_proc_UK(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_UK"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_UK",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_UK(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_UK", supplied_args, result[0])
        )
        self._on_error("ERS_proc_UK", supplied_args, result[0])
        return result

    def RSAT_raw(
        self,
        CEOS_leader: str,
        SAR_par: str,
        PROC_par: str,
        raw_data_files: str = None,
        raw_out: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["RSAT_raw"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "RSAT_raw",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw_data_files is not None:
            result = self._validate(
                "RSAT_raw",
                raw_data_files == "-" or Path(raw_data_files).exists(),
                result,
                f"raw_data_files path does not exist ({raw_data_files})",
            )
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()
        if self._wraps is not None:
            result = self._wraps.RSAT_raw(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "RSAT_raw", supplied_args, result[0])
        )
        self._on_error("RSAT_raw", supplied_args, result[0])
        return result

    def ERS_ENVISAT_proc(
        self,
        L0: str,
        SAR_par: str,
        PROC_par: str,
        raw: str,
        loff=None,
        nl=None,
        swst_flg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_ENVISAT_proc"] += 1

        if L0 is not None:
            result = self._validate(
                "ERS_ENVISAT_proc",
                L0 == "-" or Path(L0).exists(),
                result,
                f"L0 path does not exist ({L0})",
            )
        if SAR_par is not None and SAR_par != "-" and not Path(SAR_par).exists():
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw is not None and raw != "-":
            Path(raw).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ERS_ENVISAT_proc",
            swst_flg == "-" or swst_flg in valid_values,
            result,
            f"swst_flg is not a valid value (expects: {valid_values}, got: {swst_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.ERS_ENVISAT_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_ENVISAT_proc", supplied_args, result[0])
        )
        self._on_error("ERS_ENVISAT_proc", supplied_args, result[0])
        return result

    def multi_SLC(
        self,
        SLC_PROC_par: str,
        MLI_PROC_par: str,
        SLC: str,
        MLI: str,
        rlks,
        azlks,
        slc_format=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_SLC"] += 1

        if SLC_PROC_par is not None:
            result = self._validate(
                "multi_SLC",
                SLC_PROC_par == "-" or Path(SLC_PROC_par).exists(),
                result,
                f"SLC_PROC_par path does not exist ({SLC_PROC_par})",
            )
        if MLI_PROC_par is not None and MLI_PROC_par != "-":
            Path(MLI_PROC_par).touch()
        if SLC is not None:
            result = self._validate(
                "multi_SLC",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "multi_SLC",
            slc_format == "-" or slc_format in valid_values,
            result,
            f"slc_format is not a valid value (expects: {valid_values}, got: {slc_format})",
        )
        if self._wraps is not None:
            result = self._wraps.multi_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "multi_SLC", supplied_args, result[0])
        )
        self._on_error("multi_SLC", supplied_args, result[0])
        return result

    def JERS_acs(
        self,
        USER_HEADER: str,
        SEG_DESCR: str,
        ORBIT_DATA: str,
        SENSOR_DATA: str,
        track: str,
        SAR_par: str,
        PROC_par: str,
        raw_out: str,
        loff,
        nl,
        nsx=None,
        fsx=None,
        deskew=None,
        terra_alt=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["JERS_acs"] += 1

        if USER_HEADER is not None:
            result = self._validate(
                "JERS_acs",
                USER_HEADER == "-" or Path(USER_HEADER).exists(),
                result,
                f"USER_HEADER path does not exist ({USER_HEADER})",
            )
        if SEG_DESCR is not None:
            result = self._validate(
                "JERS_acs",
                SEG_DESCR == "-" or Path(SEG_DESCR).exists(),
                result,
                f"SEG_DESCR path does not exist ({SEG_DESCR})",
            )
        if ORBIT_DATA is not None:
            result = self._validate(
                "JERS_acs",
                ORBIT_DATA == "-" or Path(ORBIT_DATA).exists(),
                result,
                f"ORBIT_DATA path does not exist ({ORBIT_DATA})",
            )
        if SENSOR_DATA is not None:
            result = self._validate(
                "JERS_acs",
                SENSOR_DATA == "-" or Path(SENSOR_DATA).exists(),
                result,
                f"SENSOR_DATA path does not exist ({SENSOR_DATA})",
            )
        if track is not None and track != "-":
            Path(track).touch()
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()
        if self._wraps is not None:
            result = self._wraps.JERS_acs(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "JERS_acs", supplied_args, result[0])
        )
        self._on_error("JERS_acs", supplied_args, result[0])
        return result

    def DORIS_proc(self, PROC_par: str, DOR: str, nstate=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["DORIS_proc"] += 1

        if PROC_par is not None and PROC_par != "-" and not Path(PROC_par).exists():
            Path(PROC_par).touch()
        if DOR is not None:
            result = self._validate(
                "DORIS_proc",
                DOR == "-" or Path(DOR).exists(),
                result,
                f"DOR path does not exist ({DOR})",
            )
        if self._wraps is not None:
            result = self._wraps.DORIS_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "DORIS_proc", supplied_args, result[0])
        )
        self._on_error("DORIS_proc", supplied_args, result[0])
        return result

    def ASAR_AP_proc(
        self,
        L0: str,
        INS: str,
        SAR_par1: str,
        SAR_par2: str,
        PROC_par1: str,
        PROC_par2: str,
        raw1: str,
        raw2: str,
        ant_gain1: str,
        ant_gain2: str,
        loff=None,
        nl=None,
        roff=None,
        nr=None,
        refer=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ASAR_AP_proc"] += 1

        if L0 is not None:
            result = self._validate(
                "ASAR_AP_proc",
                L0 == "-" or Path(L0).exists(),
                result,
                f"L0 path does not exist ({L0})",
            )
        if INS is not None:
            result = self._validate(
                "ASAR_AP_proc",
                INS == "-" or Path(INS).exists(),
                result,
                f"INS path does not exist ({INS})",
            )
        if SAR_par1 is not None and SAR_par1 != "-":
            Path(SAR_par1).touch()
        if SAR_par2 is not None and SAR_par2 != "-":
            Path(SAR_par2).touch()
        if PROC_par1 is not None and PROC_par1 != "-":
            Path(PROC_par1).touch()
        if PROC_par2 is not None and PROC_par2 != "-":
            Path(PROC_par2).touch()
        if raw1 is not None and raw1 != "-":
            Path(raw1).touch()
        if raw2 is not None and raw2 != "-":
            Path(raw2).touch()
        if ant_gain1 is not None:
            result = self._validate(
                "ASAR_AP_proc",
                ant_gain1 == "-" or Path(ant_gain1).exists(),
                result,
                f"ant_gain1 path does not exist ({ant_gain1})",
            )
        if ant_gain2 is not None:
            result = self._validate(
                "ASAR_AP_proc",
                ant_gain2 == "-" or Path(ant_gain2).exists(),
                result,
                f"ant_gain2 path does not exist ({ant_gain2})",
            )
        if self._wraps is not None:
            result = self._wraps.ASAR_AP_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ASAR_AP_proc", supplied_args, result[0])
        )
        self._on_error("ASAR_AP_proc", supplied_args, result[0])
        return result

    def JERS_proc_ASF(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["JERS_proc_ASF"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "JERS_proc_ASF",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.JERS_proc_ASF(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "JERS_proc_ASF", supplied_args, result[0])
        )
        self._on_error("JERS_proc_ASF", supplied_args, result[0])
        return result

    def rc_real(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        rc_data: str,
        loff=None,
        nl=None,
        kaiser=None,
        nr_ext=None,
        fr_ext=None,
        r_chirp: str = None,
        rfi_filt=None,
        rfi_thres=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rc_real"] += 1

        if SAR_par is not None:
            result = self._validate(
                "rc_real",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "rc_real",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "rc_real",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()
        if r_chirp is not None:
            result = self._validate(
                "rc_real",
                r_chirp == "-" or Path(r_chirp).exists(),
                result,
                f"r_chirp path does not exist ({r_chirp})",
            )
        if self._wraps is not None:
            result = self._wraps.rc_real(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "rc_real", supplied_args, result[0]))
        self._on_error("rc_real", supplied_args, result[0])
        return result

    def ERS_proc_CRISP(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_CRISP"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_CRISP",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_CRISP(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_CRISP", supplied_args, result[0])
        )
        self._on_error("ERS_proc_CRISP", supplied_args, result[0])
        return result

    def prefilt(
        self,
        SAR_par: str,
        PROC_par: str,
        rc_data: str,
        prefilt_out: str,
        prefilt_dec,
        filt_lm=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["prefilt"] += 1

        if SAR_par is not None:
            result = self._validate(
                "prefilt",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "prefilt",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if rc_data is not None:
            result = self._validate(
                "prefilt",
                rc_data == "-" or Path(rc_data).exists(),
                result,
                f"rc_data path does not exist ({rc_data})",
            )
        if prefilt_out is not None and prefilt_out != "-":
            Path(prefilt_out).touch()
        if self._wraps is not None:
            result = self._wraps.prefilt(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "prefilt", supplied_args, result[0]))
        self._on_error("prefilt", supplied_args, result[0])
        return result

    def doppler(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        doppler: str,
        loff=None,
        nsub=None,
        ambig_flag=None,
        namb=None,
        order=None,
        pltflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["doppler"] += 1

        if SAR_par is not None:
            result = self._validate(
                "doppler",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "doppler",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "doppler",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if doppler is not None and doppler != "-":
            Path(doppler).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "doppler",
            ambig_flag == "-" or ambig_flag in valid_values,
            result,
            f"ambig_flag is not a valid value (expects: {valid_values}, got: {ambig_flag})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "doppler",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.doppler(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "doppler", supplied_args, result[0]))
        self._on_error("doppler", supplied_args, result[0])
        return result

    def DELFT_proc2(self, PROC_par: str, DELFT_dir, nstate=None, interval=None, ODR=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["DELFT_proc2"] += 1

        if PROC_par is not None:
            result = self._validate(
                "DELFT_proc2",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if self._wraps is not None:
            result = self._wraps.DELFT_proc2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "DELFT_proc2", supplied_args, result[0])
        )
        self._on_error("DELFT_proc2", supplied_args, result[0])
        return result

    def copy(
        self,
        infile: str,
        outfile: str,
        lbytes,
        start=None,
        nlines=None,
        offset=None,
        file_ldr=None,
        offb=None,
        nbyte=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["copy"] += 1

        if infile is not None:
            result = self._validate(
                "copy",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.copy(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "copy", supplied_args, result[0]))
        self._on_error("copy", supplied_args, result[0])
        return result

    def ERS_proc_ESRIN_ACS(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_ESRIN_ACS"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_ESRIN_ACS",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_ESRIN_ACS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_ESRIN_ACS", supplied_args, result[0])
        )
        self._on_error("ERS_proc_ESRIN_ACS", supplied_args, result[0])
        return result

    def ERS_proc_ASF_91(self, CEOS_SAR_leader: str, CEOS_trailer: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_ASF_91"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_ASF_91",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if CEOS_trailer is not None:
            result = self._validate(
                "ERS_proc_ASF_91",
                CEOS_trailer == "-" or Path(CEOS_trailer).exists(),
                result,
                f"CEOS_trailer path does not exist ({CEOS_trailer})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_ASF_91(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_ASF_91", supplied_args, result[0])
        )
        self._on_error("ERS_proc_ASF_91", supplied_args, result[0])
        return result

    def ORB_prop(self, PROC_par: str, nstate=None, interval=None, extra=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ORB_prop"] += 1

        if PROC_par is not None:
            result = self._validate(
                "ORB_prop",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if self._wraps is not None:
            result = self._wraps.ORB_prop(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ORB_prop", supplied_args, result[0])
        )
        self._on_error("ORB_prop", supplied_args, result[0])
        return result

    def ERS_fix(
        self,
        ERS_PAF,
        SAR_par: str,
        PROC_par: str,
        cc_flag,
        raw=None,
        output_file: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_fix"] += 1

        if SAR_par is not None:
            result = self._validate(
                "ERS_fix",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "ERS_fix",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if output_file is not None and output_file != "-":
            Path(output_file).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_fix(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "ERS_fix", supplied_args, result[0]))
        self._on_error("ERS_fix", supplied_args, result[0])
        return result

    def ERS_proc_CCRS(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_CCRS"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_CCRS",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_CCRS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_CCRS", supplied_args, result[0])
        )
        self._on_error("ERS_proc_CCRS", supplied_args, result[0])
        return result

    def ptarg(
        self,
        SLC: str,
        width: str,
        r_samp: str,
        az_samp: str,
        ptr_image: str,
        r_plot: str,
        az_plot: str,
        data_format,
        win=None,
        pltflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ptarg"] += 1

        if SLC is not None:
            result = self._validate(
                "ptarg",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if width is not None:
            result = self._validate(
                "ptarg",
                width == "-" or Path(width).exists(),
                result,
                f"width path does not exist ({width})",
            )
        if r_samp is not None:
            result = self._validate(
                "ptarg",
                r_samp == "-" or Path(r_samp).exists(),
                result,
                f"r_samp path does not exist ({r_samp})",
            )
        if az_samp is not None:
            result = self._validate(
                "ptarg",
                az_samp == "-" or Path(az_samp).exists(),
                result,
                f"az_samp path does not exist ({az_samp})",
            )
        if ptr_image is not None and ptr_image != "-":
            Path(ptr_image).touch()
        if r_plot is not None and r_plot != "-":
            Path(r_plot).touch()
        if az_plot is not None and az_plot != "-":
            Path(az_plot).touch()
        valid_values = [0, 1]
        result = self._validate(
            "ptarg",
            data_format == "-" or data_format in valid_values,
            result,
            f"data_format is not a valid value (expects: {valid_values}, got: {data_format})",
        )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "ptarg",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.ptarg(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "ptarg", supplied_args, result[0]))
        self._on_error("ptarg", supplied_args, result[0])
        return result

    def multi_GRD_SLC(
        self,
        SLC_PROC_par: str,
        GRD_PROC_par: str,
        SLC_image: str,
        GRD_image: str,
        rlks,
        azlks,
        interp_mode=None,
        sample_spacing=None,
        gr_start=None,
        t_start=None,
        t_end=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_GRD_SLC"] += 1

        if SLC_PROC_par is not None:
            result = self._validate(
                "multi_GRD_SLC",
                SLC_PROC_par == "-" or Path(SLC_PROC_par).exists(),
                result,
                f"SLC_PROC_par path does not exist ({SLC_PROC_par})",
            )
        if GRD_PROC_par is not None and GRD_PROC_par != "-":
            Path(GRD_PROC_par).touch()
        if SLC_image is not None:
            result = self._validate(
                "multi_GRD_SLC",
                SLC_image == "-" or Path(SLC_image).exists(),
                result,
                f"SLC_image path does not exist ({SLC_image})",
            )
        if GRD_image is not None and GRD_image != "-":
            Path(GRD_image).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "multi_GRD_SLC",
            interp_mode == "-" or interp_mode in valid_values,
            result,
            f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.multi_GRD_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "multi_GRD_SLC", supplied_args, result[0])
        )
        self._on_error("multi_GRD_SLC", supplied_args, result[0])
        return result

    def create_sar_par(self, SAR_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["create_sar_par"] += 1

        if SAR_par is not None and SAR_par != "-" and not Path(SAR_par).exists():
            Path(SAR_par).touch()
        if self._wraps is not None:
            result = self._wraps.create_sar_par(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "create_sar_par", supplied_args, result[0])
        )
        self._on_error("create_sar_par", supplied_args, result[0])
        return result

    def rspec_JERS(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        range_spec: str,
        nr_samp=None,
        nl_spec=None,
        loff=None,
        nlines=None,
        nr_ext=None,
        fr_ext=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rspec_JERS"] += 1

        if SAR_par is not None:
            result = self._validate(
                "rspec_JERS",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "rspec_JERS",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "rspec_JERS",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if range_spec is not None and range_spec != "-":
            Path(range_spec).touch()
        if self._wraps is not None:
            result = self._wraps.rspec_JERS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "rspec_JERS", supplied_args, result[0])
        )
        self._on_error("rspec_JERS", supplied_args, result[0])
        return result

    def azsp_IQ(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        spectrum: str,
        loff=None,
        roff=None,
        nsub=None,
        ambig_flg=None,
        namb=None,
        pltflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["azsp_IQ"] += 1

        if SAR_par is not None:
            result = self._validate(
                "azsp_IQ",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "azsp_IQ",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "azsp_IQ",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if spectrum is not None and spectrum != "-":
            Path(spectrum).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "azsp_IQ",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.azsp_IQ(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "azsp_IQ", supplied_args, result[0]))
        self._on_error("azsp_IQ", supplied_args, result[0])
        return result

    def ERS_proc_ACRES(self, CEOS_SAR_leader: str, PROC_par: str, type=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_ACRES"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_ACRES",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ERS_proc_ACRES",
            type == "-" or type in valid_values,
            result,
            f"type is not a valid value (expects: {valid_values}, got: {type})",
        )
        if self._wraps is not None:
            result = self._wraps.ERS_proc_ACRES(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_ACRES", supplied_args, result[0])
        )
        self._on_error("ERS_proc_ACRES", supplied_args, result[0])
        return result

    def pre_rc_RSAT(
        self,
        SAR_par: str,
        PROC_par: str,
        signal_data: str,
        rc_data: str,
        prefilt_dec=None,
        loff=None,
        nl=None,
        nr_samp=None,
        kaiser=None,
        filt_lm=None,
        nr_ext=None,
        fr_ext=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["pre_rc_RSAT"] += 1

        if SAR_par is not None:
            result = self._validate(
                "pre_rc_RSAT",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "pre_rc_RSAT",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if signal_data is not None:
            result = self._validate(
                "pre_rc_RSAT",
                signal_data == "-" or Path(signal_data).exists(),
                result,
                f"signal_data path does not exist ({signal_data})",
            )
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()
        if self._wraps is not None:
            result = self._wraps.pre_rc_RSAT(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "pre_rc_RSAT", supplied_args, result[0])
        )
        self._on_error("pre_rc_RSAT", supplied_args, result[0])
        return result

    def autof(
        self,
        SAR_par: str,
        PROC_par: str,
        rc_data: str,
        autofocus: str,
        SNR_min=None,
        prefilter=None,
        auto_az=None,
        az_offset=None,
        auto_bins=None,
        dop_ambig=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["autof"] += 1

        if SAR_par is not None:
            result = self._validate(
                "autof",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "autof",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if rc_data is not None:
            result = self._validate(
                "autof",
                rc_data == "-" or Path(rc_data).exists(),
                result,
                f"rc_data path does not exist ({rc_data})",
            )
        if autofocus is not None and autofocus != "-":
            Path(autofocus).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "autof",
            dop_ambig == "-" or dop_ambig in valid_values,
            result,
            f"dop_ambig is not a valid value (expects: {valid_values}, got: {dop_ambig})",
        )
        if self._wraps is not None:
            result = self._wraps.autof(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "autof", supplied_args, result[0]))
        self._on_error("autof", supplied_args, result[0])
        return result

    def cat_raw(
        self,
        RAW_list: str,
        SAR_par: str,
        PROC_par: str,
        RAW_out: str,
        fill=None,
        loff=None,
        nl=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cat_raw"] += 1

        if RAW_list is not None:
            result = self._validate(
                "cat_raw",
                RAW_list == "-" or Path(RAW_list).exists(),
                result,
                f"RAW_list path does not exist ({RAW_list})",
            )
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if RAW_out is not None and RAW_out != "-":
            Path(RAW_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "cat_raw",
            fill == "-" or fill in valid_values,
            result,
            f"fill is not a valid value (expects: {valid_values}, got: {fill})",
        )
        if self._wraps is not None:
            result = self._wraps.cat_raw(*supplied_args)

        self.call_sequence.append(PyGammaCall("MSP", "cat_raw", supplied_args, result[0]))
        self._on_error("cat_raw", supplied_args, result[0])
        return result

    def ERS_proc_ASI(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ERS_proc_ASI"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "ERS_proc_ASI",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.ERS_proc_ASI(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ERS_proc_ASI", supplied_args, result[0])
        )
        self._on_error("ERS_proc_ASI", supplied_args, result[0])
        return result

    def JERS_proc(self, CEOS_SAR_ldr: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["JERS_proc"] += 1

        if CEOS_SAR_ldr is not None:
            result = self._validate(
                "JERS_proc",
                CEOS_SAR_ldr == "-" or Path(CEOS_SAR_ldr).exists(),
                result,
                f"CEOS_SAR_ldr path does not exist ({CEOS_SAR_ldr})",
            )
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.JERS_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "JERS_proc", supplied_args, result[0])
        )
        self._on_error("JERS_proc", supplied_args, result[0])
        return result

    def create_proc_par(self, SAR_par: str, PROC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["create_proc_par"] += 1

        if SAR_par is not None:
            result = self._validate(
                "create_proc_par",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None and PROC_par != "-" and not Path(PROC_par).exists():
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.create_proc_par(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "create_proc_par", supplied_args, result[0])
        )
        self._on_error("create_proc_par", supplied_args, result[0])
        return result

    def SIRC_proc(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, UTC_MET=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SIRC_proc"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "SIRC_proc",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if self._wraps is not None:
            result = self._wraps.SIRC_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "SIRC_proc", supplied_args, result[0])
        )
        self._on_error("SIRC_proc", supplied_args, result[0])
        return result

    def ASAR_IM_proc(
        self,
        L0: str,
        INS: str,
        SAR_par: str,
        PROC_par: str,
        raw: str,
        ant_gain: str,
        loff=None,
        nl=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ASAR_IM_proc"] += 1

        if L0 is not None:
            result = self._validate(
                "ASAR_IM_proc",
                L0 == "-" or Path(L0).exists(),
                result,
                f"L0 path does not exist ({L0})",
            )
        if INS is not None:
            result = self._validate(
                "ASAR_IM_proc",
                INS == "-" or Path(INS).exists(),
                result,
                f"INS path does not exist ({INS})",
            )
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw is not None and raw != "-":
            Path(raw).touch()
        if ant_gain is not None:
            result = self._validate(
                "ASAR_IM_proc",
                ant_gain == "-" or Path(ant_gain).exists(),
                result,
                f"ant_gain path does not exist ({ant_gain})",
            )
        if self._wraps is not None:
            result = self._wraps.ASAR_IM_proc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("MSP", "ASAR_IM_proc", supplied_args, result[0])
        )
        self._on_error("ASAR_IM_proc", supplied_args, result[0])
        return result

    def dishgt(
        self,
        hgt,
        pwr,
        width,
        start_hgt=None,
        start_pwr=None,
        nlines=None,
        m_cycle=None,
        scale=None,
        exp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dishgt"] += 1

        if self._wraps is not None:
            result = self._wraps.dishgt(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "dishgt", supplied_args, result[0]))
        self._on_error("dishgt", supplied_args, result[0])
        return result

    def rasdt_pwr(
        self,
        data,
        pwr,
        width,
        start_data=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        cycle=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
        cc=None,
        start_cc=None,
        cc_min=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasdt_pwr"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rasdt_pwr(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "rasdt_pwr", supplied_args, result[0])
        )
        self._on_error("rasdt_pwr", supplied_args, result[0])
        return result

    def rasdt_cmap(
        self,
        data,
        pwr,
        width,
        start_data=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        min=None,
        max=None,
        mflg=None,
        cmap=None,
        scale=None,
        exp=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasdt_cmap"] += 1

        valid_values = [0, 1] + [None]
        result = self._validate(
            "rasdt_cmap",
            mflg == "-" or mflg in valid_values,
            result,
            f"mflg is not a valid value (expects: {valid_values}, got: {mflg})",
        )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rasdt_cmap(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "rasdt_cmap", supplied_args, result[0])
        )
        self._on_error("rasdt_cmap", supplied_args, result[0])
        return result

    def dis2hgt(
        self,
        hgt1,
        hgt2,
        width1,
        width2,
        start=None,
        nlines=None,
        roff=None,
        azoff=None,
        m_cycle=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2hgt"] += 1

        if self._wraps is not None:
            result = self._wraps.dis2hgt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis2hgt", supplied_args, result[0])
        )
        self._on_error("dis2hgt", supplied_args, result[0])
        return result

    def gcp_ras(self, ras: str, GCP: str, mag=None, win_sz=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gcp_ras"] += 1

        if ras is not None:
            result = self._validate(
                "gcp_ras",
                ras == "-" or Path(ras).exists(),
                result,
                f"ras path does not exist ({ras})",
            )
        if GCP is not None and GCP != "-":
            Path(GCP).touch()
        if self._wraps is not None:
            result = self._wraps.gcp_ras(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "gcp_ras", supplied_args, result[0])
        )
        self._on_error("gcp_ras", supplied_args, result[0])
        return result

    def cpx_math(
        self,
        d1: str,
        d2: str,
        d_out: str,
        width,
        mode,
        roff=None,
        loff=None,
        nr=None,
        nl=None,
        c_re=None,
        c_im=None,
        zflg=None,
        rflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cpx_math"] += 1

        if d1 is not None:
            result = self._validate(
                "cpx_math",
                d1 == "-" or Path(d1).exists(),
                result,
                f"d1 path does not exist ({d1})",
            )
        if d2 is not None:
            result = self._validate(
                "cpx_math",
                d2 == "-" or Path(d2).exists(),
                result,
                f"d2 path does not exist ({d2})",
            )
        if d_out is not None and d_out != "-":
            Path(d_out).touch()
        valid_values = [0, 1, 2, 3]
        result = self._validate(
            "cpx_math",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "cpx_math",
            zflg == "-" or zflg in valid_values,
            result,
            f"zflg is not a valid value (expects: {valid_values}, got: {zflg})",
        )
        if self._wraps is not None:
            result = self._wraps.cpx_math(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "cpx_math", supplied_args, result[0])
        )
        self._on_error("cpx_math", supplied_args, result[0])
        return result

    def disflag(self, flag: str, width, start=None, nlines=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disflag"] += 1

        if flag is not None:
            result = self._validate(
                "disflag",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if self._wraps is not None:
            result = self._wraps.disflag(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "disflag", supplied_args, result[0])
        )
        self._on_error("disflag", supplied_args, result[0])
        return result

    def set_value(self, PAR_in: str, PAR_out: str, keyword, value, new_key=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["set_value"] += 1

        if PAR_in is not None:
            result = self._validate(
                "set_value",
                PAR_in == "-" or Path(PAR_in).exists(),
                result,
                f"PAR_in path does not exist ({PAR_in})",
            )
        if PAR_out is not None and PAR_out != "-":
            Path(PAR_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "set_value",
            new_key == "-" or new_key in valid_values,
            result,
            f"new_key is not a valid value (expects: {valid_values}, got: {new_key})",
        )
        if self._wraps is not None:
            result = self._wraps.set_value(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "set_value", supplied_args, result[0])
        )
        self._on_error("set_value", supplied_args, result[0])
        return result

    def cpx_to_real(self, cpx: str, real: str, width, type):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cpx_to_real"] += 1

        if cpx is not None:
            result = self._validate(
                "cpx_to_real",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        if real is not None and real != "-":
            Path(real).touch()
        valid_values = [0, 1, 2, 3, 4]
        result = self._validate(
            "cpx_to_real",
            type == "-" or type in valid_values,
            result,
            f"type is not a valid value (expects: {valid_values}, got: {type})",
        )
        if self._wraps is not None:
            result = self._wraps.cpx_to_real(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "cpx_to_real", supplied_args, result[0])
        )
        self._on_error("cpx_to_real", supplied_args, result[0])
        return result

    def rascc(
        self,
        cc,
        pwr,
        width,
        start_cc=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        cmin=None,
        cmax=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rascc"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rascc(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "rascc", supplied_args, result[0]))
        self._on_error("rascc", supplied_args, result[0])
        return result

    def disgbyte(self, image: str, width, start=None, nlines=None, scale=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disgbyte"] += 1

        if image is not None:
            result = self._validate(
                "disgbyte",
                image == "-" or Path(image).exists(),
                result,
                f"image path does not exist ({image})",
            )
        if self._wraps is not None:
            result = self._wraps.disgbyte(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "disgbyte", supplied_args, result[0])
        )
        self._on_error("disgbyte", supplied_args, result[0])
        return result

    def dis_dB(self, pwr, width, start=None, nlines=None, min_dB=None, max_dB=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis_dB"] += 1

        if self._wraps is not None:
            result = self._wraps.dis_dB(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "dis_dB", supplied_args, result[0]))
        self._on_error("dis_dB", supplied_args, result[0])
        return result

    def discc(
        self,
        cc,
        pwr,
        width,
        start_cc=None,
        start_pwr=None,
        nlines=None,
        min_corr=None,
        max_corr=None,
        scale=None,
        exp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["discc"] += 1

        if self._wraps is not None:
            result = self._wraps.discc(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "discc", supplied_args, result[0]))
        self._on_error("discc", supplied_args, result[0])
        return result

    def svg_map(
        self,
        image: str,
        dem_par: str,
        svg: str,
        font=None,
        fsize=None,
        color=None,
        gcolor=None,
        majorx=None,
        majory=None,
        minorx=None,
        minory=None,
        thick=None,
        grid=None,
        gopac=None,
        gdash=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["svg_map"] += 1

        if image is not None:
            result = self._validate(
                "svg_map",
                image == "-" or Path(image).exists(),
                result,
                f"image path does not exist ({image})",
            )
        if dem_par is not None:
            result = self._validate(
                "svg_map",
                dem_par == "-" or Path(dem_par).exists(),
                result,
                f"dem_par path does not exist ({dem_par})",
            )
        if svg is not None and svg != "-":
            Path(svg).touch()
        if self._wraps is not None:
            result = self._wraps.svg_map(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "svg_map", supplied_args, result[0])
        )
        self._on_error("svg_map", supplied_args, result[0])
        return result

    def gbyte2float(self, infile: str, outfile: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gbyte2float"] += 1

        if infile is not None:
            result = self._validate(
                "gbyte2float",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.gbyte2float(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "gbyte2float", supplied_args, result[0])
        )
        self._on_error("gbyte2float", supplied_args, result[0])
        return result

    def real_to_cpx(
        self, data1: str, data2: str = None, cpx: str = None, width=None, type=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["real_to_cpx"] += 1

        if data1 is not None:
            result = self._validate(
                "real_to_cpx",
                data1 == "-" or Path(data1).exists(),
                result,
                f"data1 path does not exist ({data1})",
            )
        if data2 is not None:
            result = self._validate(
                "real_to_cpx",
                data2 == "-" or Path(data2).exists(),
                result,
                f"data2 path does not exist ({data2})",
            )
        if cpx is not None and cpx != "-":
            Path(cpx).touch()
        if self._wraps is not None:
            result = self._wraps.real_to_cpx(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "real_to_cpx", supplied_args, result[0])
        )
        self._on_error("real_to_cpx", supplied_args, result[0])
        return result

    def rasmph_pwr(
        self,
        cpx: str,
        pwr: str,
        width,
        start_cpx=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
        cc=None,
        start_cc=None,
        cc_min=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasmph_pwr"] += 1

        if cpx is not None:
            result = self._validate(
                "rasmph_pwr",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        if pwr is not None:
            result = self._validate(
                "rasmph_pwr",
                pwr == "-" or Path(pwr).exists(),
                result,
                f"pwr path does not exist ({pwr})",
            )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rasmph_pwr(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "rasmph_pwr", supplied_args, result[0])
        )
        self._on_error("rasmph_pwr", supplied_args, result[0])
        return result

    def data2geotiff(self, DEM_par: str, data: str, type, GeoTIFF: str, nodata=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["data2geotiff"] += 1

        if DEM_par is not None:
            result = self._validate(
                "data2geotiff",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if data is not None:
            result = self._validate(
                "data2geotiff",
                data == "-" or Path(data).exists(),
                result,
                f"data path does not exist ({data})",
            )
        valid_values = [0, 1, 2, 3, 4, 5]
        result = self._validate(
            "data2geotiff",
            type == "-" or type in valid_values,
            result,
            f"type is not a valid value (expects: {valid_values}, got: {type})",
        )
        if GeoTIFF is not None and GeoTIFF != "-":
            Path(GeoTIFF).touch()
        if self._wraps is not None:
            result = self._wraps.data2geotiff(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "data2geotiff", supplied_args, result[0])
        )
        self._on_error("data2geotiff", supplied_args, result[0])
        return result

    def disras(self, ras: str, mag=None, win_sz=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disras"] += 1

        if ras is not None:
            result = self._validate(
                "disras",
                ras == "-" or Path(ras).exists(),
                result,
                f"ras path does not exist ({ras})",
            )
        if self._wraps is not None:
            result = self._wraps.disras(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "disras", supplied_args, result[0]))
        self._on_error("disras", supplied_args, result[0])
        return result

    def disrmg(
        self,
        unw,
        pwr,
        width,
        start_unw=None,
        start_pwr=None,
        nlines=None,
        ph_scale=None,
        scale=None,
        exp=None,
        ph_offset=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disrmg"] += 1

        if self._wraps is not None:
            result = self._wraps.disrmg(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "disrmg", supplied_args, result[0]))
        self._on_error("disrmg", supplied_args, result[0])
        return result

    def dis2rmg(
        self,
        unw1,
        unw2,
        width1,
        width2,
        start=None,
        nlines=None,
        roff=None,
        azoff=None,
        ph_scale=None,
        ph_offset=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2rmg"] += 1

        if self._wraps is not None:
            result = self._wraps.dis2rmg(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis2rmg", supplied_args, result[0])
        )
        self._on_error("dis2rmg", supplied_args, result[0])
        return result

    def dis2ras(self, ras1: str, ras2: str, mag=None, win_sz=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2ras"] += 1

        if ras1 is not None:
            result = self._validate(
                "dis2ras",
                ras1 == "-" or Path(ras1).exists(),
                result,
                f"ras1 path does not exist ({ras1})",
            )
        if ras2 is not None:
            result = self._validate(
                "dis2ras",
                ras2 == "-" or Path(ras2).exists(),
                result,
                f"ras2 path does not exist ({ras2})",
            )
        if self._wraps is not None:
            result = self._wraps.dis2ras(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis2ras", supplied_args, result[0])
        )
        self._on_error("dis2ras", supplied_args, result[0])
        return result

    def dismph_pwr(
        self,
        cpx: str,
        pwr,
        width,
        start_cpx=None,
        start_pwr=None,
        nlines=None,
        scale=None,
        exp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dismph_pwr"] += 1

        if cpx is not None:
            result = self._validate(
                "dismph_pwr",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        if self._wraps is not None:
            result = self._wraps.dismph_pwr(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dismph_pwr", supplied_args, result[0])
        )
        self._on_error("dismph_pwr", supplied_args, result[0])
        return result

    def vec_math(
        self,
        d1,
        d2,
        d_out: str,
        width,
        mode,
        c1=None,
        c2=None,
        c3=None,
        nflg=None,
        nl=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["vec_math"] += 1

        if d_out is not None and d_out != "-":
            Path(d_out).touch()
        valid_values = [0, 1, 2, 3, 4, 5, 6]
        result = self._validate(
            "vec_math",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.vec_math(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "vec_math", supplied_args, result[0])
        )
        self._on_error("vec_math", supplied_args, result[0])
        return result

    def dismph_fft(
        self,
        cpx: str,
        width,
        start=None,
        nlines=None,
        scale=None,
        exp=None,
        nfft=None,
        mag=None,
        data_type=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dismph_fft"] += 1

        if cpx is not None:
            result = self._validate(
                "dismph_fft",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dismph_fft",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if self._wraps is not None:
            result = self._wraps.dismph_fft(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dismph_fft", supplied_args, result[0])
        )
        self._on_error("dismph_fft", supplied_args, result[0])
        return result

    def svg_arrow(
        self,
        dv_norm,
        dv_phi,
        width,
        svg: str,
        image=None,
        norm=None,
        gridx=None,
        gridy=None,
        color=None,
        thick=None,
        head=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["svg_arrow"] += 1

        if svg is not None and svg != "-":
            Path(svg).touch()
        if self._wraps is not None:
            result = self._wraps.svg_arrow(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "svg_arrow", supplied_args, result[0])
        )
        self._on_error("svg_arrow", supplied_args, result[0])
        return result

    def ras3pwr(
        self,
        d1,
        d2,
        d3,
        width,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        scale1=None,
        scale2=None,
        scale3=None,
        exp=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras3pwr"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.ras3pwr(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras3pwr", supplied_args, result[0])
        )
        self._on_error("ras3pwr", supplied_args, result[0])
        return result

    def disdt_pwr(
        self,
        data,
        pwr,
        width,
        start_data=None,
        start_pwr=None,
        nlines=None,
        cycle=None,
        scale=None,
        exp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disdt_pwr"] += 1

        if self._wraps is not None:
            result = self._wraps.disdt_pwr(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "disdt_pwr", supplied_args, result[0])
        )
        self._on_error("disdt_pwr", supplied_args, result[0])
        return result

    def real_to_vec(self, cmp1, cmp2, cmp3, width, vec: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["real_to_vec"] += 1

        if vec is not None and vec != "-":
            Path(vec).touch()
        if self._wraps is not None:
            result = self._wraps.real_to_vec(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "real_to_vec", supplied_args, result[0])
        )
        self._on_error("real_to_vec", supplied_args, result[0])
        return result

    def float2short(
        self, infile, outfile: str, scale=None, exp=None, neg=None, output=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["float2short"] += 1

        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.float2short(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "float2short", supplied_args, result[0])
        )
        self._on_error("float2short", supplied_args, result[0])
        return result

    def disdt_pwr24(
        self,
        data,
        pwr,
        width,
        start_data=None,
        start_pwr=None,
        nlines=None,
        cycle=None,
        scale=None,
        exp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disdt_pwr24"] += 1

        if self._wraps is not None:
            result = self._wraps.disdt_pwr24(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "disdt_pwr24", supplied_args, result[0])
        )
        self._on_error("disdt_pwr24", supplied_args, result[0])
        return result

    def rashgt_shd(
        self,
        hgt,
        data,
        width,
        col_post,
        row_post=None,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        theta0=None,
        phi0=None,
        color0=None,
        cycle=None,
        LR=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rashgt_shd"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rashgt_shd(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "rashgt_shd", supplied_args, result[0])
        )
        self._on_error("rashgt_shd", supplied_args, result[0])
        return result

    def ras2ras(self, ras_in: str, ras_out: str, cmap=None, force24=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras2ras"] += 1

        if ras_in is not None:
            result = self._validate(
                "ras2ras",
                ras_in == "-" or Path(ras_in).exists(),
                result,
                f"ras_in path does not exist ({ras_in})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ras2ras",
            force24 == "-" or force24 in valid_values,
            result,
            f"force24 is not a valid value (expects: {valid_values}, got: {force24})",
        )
        if self._wraps is not None:
            result = self._wraps.ras2ras(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras2ras", supplied_args, result[0])
        )
        self._on_error("ras2ras", supplied_args, result[0])
        return result

    def ras24_float(
        self,
        f1,
        f2,
        f3,
        width,
        rasf: str,
        color_model=None,
        h0=None,
        hrange=None,
        imin=None,
        imax=None,
        sat_min=None,
        sat_max=None,
        sc1=None,
        A1=None,
        B1=None,
        cyclic1=None,
        sc2=None,
        A2=None,
        B2=None,
        start_f1=None,
        start_f2=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        LR=None,
        General=None,
        start_f3=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras24_float"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "ras24_float",
            color_model == "-" or color_model in valid_values,
            result,
            f"color_model is not a valid value (expects: {valid_values}, got: {color_model})",
        )
        if self._wraps is not None:
            result = self._wraps.ras24_float(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras24_float", supplied_args, result[0])
        )
        self._on_error("ras24_float", supplied_args, result[0])
        return result

    def double2float(self, infile: str, outfile: str, scale=None, exp=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["double2float"] += 1

        if infile is not None:
            result = self._validate(
                "double2float",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.double2float(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "double2float", supplied_args, result[0])
        )
        self._on_error("double2float", supplied_args, result[0])
        return result

    def float2uchar(self, infile, outfile, scale, exp):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["float2uchar"] += 1

        if self._wraps is not None:
            result = self._wraps.float2uchar(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "float2uchar", supplied_args, result[0])
        )
        self._on_error("float2uchar", supplied_args, result[0])
        return result

    def float_math(
        self,
        d1,
        d2,
        d_out: str,
        width,
        mode,
        roff=None,
        loff=None,
        nr=None,
        nl=None,
        c0=None,
        zflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["float_math"] += 1

        if d_out is not None and d_out != "-":
            Path(d_out).touch()
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
        result = self._validate(
            "float_math",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "float_math",
            zflg == "-" or zflg in valid_values,
            result,
            f"zflg is not a valid value (expects: {valid_values}, got: {zflg})",
        )
        if self._wraps is not None:
            result = self._wraps.float_math(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "float_math", supplied_args, result[0])
        )
        self._on_error("float_math", supplied_args, result[0])
        return result

    def cpd(self, din: str, dout: str, width, dtype, xoff, nx, yoff, ny):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cpd"] += 1

        if din is not None:
            result = self._validate(
                "cpd",
                din == "-" or Path(din).exists(),
                result,
                f"din path does not exist ({din})",
            )
        if dout is not None and dout != "-":
            Path(dout).touch()
        valid_values = [0, 1, 2]
        result = self._validate(
            "cpd",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.cpd(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "cpd", supplied_args, result[0]))
        self._on_error("cpd", supplied_args, result[0])
        return result

    def disras_dem_par(self, ras: str, DEM_par: str, mag=None, win_sz=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disras_dem_par"] += 1

        if ras is not None:
            result = self._validate(
                "disras_dem_par",
                ras == "-" or Path(ras).exists(),
                result,
                f"ras path does not exist ({ras})",
            )
        if DEM_par is not None:
            result = self._validate(
                "disras_dem_par",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if self._wraps is not None:
            result = self._wraps.disras_dem_par(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "disras_dem_par", supplied_args, result[0])
        )
        self._on_error("disras_dem_par", supplied_args, result[0])
        return result

    def dismph(
        self, cpx: str, width, start=None, nlines=None, scale=None, exp=None, dtype=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dismph"] += 1

        if cpx is not None:
            result = self._validate(
                "dismph",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dismph",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.dismph(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "dismph", supplied_args, result[0]))
        self._on_error("dismph", supplied_args, result[0])
        return result

    def rasshd(
        self,
        DEM,
        width,
        col_post,
        row_post=None,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        theta0=None,
        phi0=None,
        LR=None,
        rasf: str = None,
        dtype=None,
        zero_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasshd"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "rasshd",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "rasshd",
            zero_flag == "-" or zero_flag in valid_values,
            result,
            f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.rasshd(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "rasshd", supplied_args, result[0]))
        self._on_error("rasshd", supplied_args, result[0])
        return result

    def dis2mph(
        self,
        cpx1: str,
        cpx2: str,
        width1,
        width2,
        start=None,
        nlines=None,
        roff=None,
        azoff=None,
        scale=None,
        exp=None,
        sc_abs1=None,
        sc_abs2=None,
        dtype=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2mph"] += 1

        if cpx1 is not None:
            result = self._validate(
                "dis2mph",
                cpx1 == "-" or Path(cpx1).exists(),
                result,
                f"cpx1 path does not exist ({cpx1})",
            )
        if cpx2 is not None:
            result = self._validate(
                "dis2mph",
                cpx2 == "-" or Path(cpx2).exists(),
                result,
                f"cpx2 path does not exist ({cpx2})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dis2mph",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.dis2mph(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis2mph", supplied_args, result[0])
        )
        self._on_error("dis2mph", supplied_args, result[0])
        return result

    def dis2SLC(
        self,
        SLC1: str,
        SLC2: str,
        width1,
        width2,
        start=None,
        nlines=None,
        roff=None,
        azoff=None,
        scale=None,
        exp=None,
        data_type=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2SLC"] += 1

        if SLC1 is not None:
            result = self._validate(
                "dis2SLC",
                SLC1 == "-" or Path(SLC1).exists(),
                result,
                f"SLC1 path does not exist ({SLC1})",
            )
        if SLC2 is not None:
            result = self._validate(
                "dis2SLC",
                SLC2 == "-" or Path(SLC2).exists(),
                result,
                f"SLC2 path does not exist ({SLC2})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dis2SLC",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if self._wraps is not None:
            result = self._wraps.dis2SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis2SLC", supplied_args, result[0])
        )
        self._on_error("dis2SLC", supplied_args, result[0])
        return result

    def raspwr(
        self,
        pwr: str,
        width,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
        data_type=None,
        hdrz=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["raspwr"] += 1

        if pwr is not None:
            result = self._validate(
                "raspwr",
                pwr == "-" or Path(pwr).exists(),
                result,
                f"pwr path does not exist ({pwr})",
            )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "raspwr",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if self._wraps is not None:
            result = self._wraps.raspwr(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "raspwr", supplied_args, result[0]))
        self._on_error("raspwr", supplied_args, result[0])
        return result

    def disSLC(
        self,
        SLC: str,
        width,
        start=None,
        nlines=None,
        scale=None,
        exp=None,
        data_type=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disSLC"] += 1

        if SLC is not None:
            result = self._validate(
                "disSLC",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "disSLC",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if self._wraps is not None:
            result = self._wraps.disSLC(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "disSLC", supplied_args, result[0]))
        self._on_error("disSLC", supplied_args, result[0])
        return result

    def ras8_colormap(
        self,
        model,
        h0,
        hrange,
        ival,
        sat,
        cm: str,
        cm_ras: str = None,
        width=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras8_colormap"] += 1

        valid_values = [0, 1, 2, 3]
        result = self._validate(
            "ras8_colormap",
            model == "-" or model in valid_values,
            result,
            f"model is not a valid value (expects: {valid_values}, got: {model})",
        )
        if cm is not None and cm != "-":
            Path(cm).touch()
        if cm_ras is not None and cm_ras != "-":
            Path(cm_ras).touch()
        if self._wraps is not None:
            result = self._wraps.ras8_colormap(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras8_colormap", supplied_args, result[0])
        )
        self._on_error("ras8_colormap", supplied_args, result[0])
        return result

    def cp_data(
        self,
        infile: str,
        outfile: str,
        lbytes,
        start=None,
        nlines=None,
        offset=None,
        file_ldr=None,
        offb=None,
        nbyte=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cp_data"] += 1

        if infile is not None:
            result = self._validate(
                "cp_data",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.cp_data(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "cp_data", supplied_args, result[0])
        )
        self._on_error("cp_data", supplied_args, result[0])
        return result

    def ras_cpt(
        self,
        data,
        width,
        cpt: str,
        color_model=None,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        LR=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_cpt"] += 1

        if cpt is not None:
            result = self._validate(
                "ras_cpt",
                cpt == "-" or Path(cpt).exists(),
                result,
                f"cpt path does not exist ({cpt})",
            )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "ras_cpt",
            color_model == "-" or color_model in valid_values,
            result,
            f"color_model is not a valid value (expects: {valid_values}, got: {color_model})",
        )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.ras_cpt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras_cpt", supplied_args, result[0])
        )
        self._on_error("ras_cpt", supplied_args, result[0])
        return result

    def uchar2float(self, infile, outfile, scale, exp, offset=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["uchar2float"] += 1

        if self._wraps is not None:
            result = self._wraps.uchar2float(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "uchar2float", supplied_args, result[0])
        )
        self._on_error("uchar2float", supplied_args, result[0])
        return result

    def rasdt_pwr24(
        self,
        data,
        pwr,
        width,
        start_data=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        cycle=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
        cc=None,
        start_cc=None,
        cc_min=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasdt_pwr24"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rasdt_pwr24(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "rasdt_pwr24", supplied_args, result[0])
        )
        self._on_error("rasdt_pwr24", supplied_args, result[0])
        return result

    def float2gbyte(self, infile: str, outfile: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["float2gbyte"] += 1

        if infile is not None:
            result = self._validate(
                "float2gbyte",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.float2gbyte(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "float2gbyte", supplied_args, result[0])
        )
        self._on_error("float2gbyte", supplied_args, result[0])
        return result

    def disbyte(self, image: str, width, start=None, nlines=None, scale=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disbyte"] += 1

        if image is not None:
            result = self._validate(
                "disbyte",
                image == "-" or Path(image).exists(),
                result,
                f"image path does not exist ({image})",
            )
        if self._wraps is not None:
            result = self._wraps.disbyte(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "disbyte", supplied_args, result[0])
        )
        self._on_error("disbyte", supplied_args, result[0])
        return result

    def rasrmg(
        self,
        unw,
        pwr,
        width,
        start_unw=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        ph_scale=None,
        scale=None,
        exp=None,
        ph_offset=None,
        LR=None,
        rasf: str = None,
        cc=None,
        start_cc=None,
        cc_min=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasrmg"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rasrmg(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "rasrmg", supplied_args, result[0]))
        self._on_error("rasrmg", supplied_args, result[0])
        return result

    def kml_plan(
        self,
        MLI_par: str,
        DEM_par: str,
        lookup_table: str,
        kml: str,
        geoid=None,
        geoid_par: str = None,
        extension=None,
        flight_path=None,
        t_event=None,
        pt_list: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["kml_plan"] += 1

        if MLI_par is not None:
            result = self._validate(
                "kml_plan",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if DEM_par is not None:
            result = self._validate(
                "kml_plan",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if lookup_table is not None:
            result = self._validate(
                "kml_plan",
                lookup_table == "-" or Path(lookup_table).exists(),
                result,
                f"lookup_table path does not exist ({lookup_table})",
            )
        if kml is not None and kml != "-":
            Path(kml).touch()
        if geoid_par is not None:
            result = self._validate(
                "kml_plan",
                geoid_par == "-" or Path(geoid_par).exists(),
                result,
                f"geoid_par path does not exist ({geoid_par})",
            )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "kml_plan",
            flight_path == "-" or flight_path in valid_values,
            result,
            f"flight_path is not a valid value (expects: {valid_values}, got: {flight_path})",
        )
        if pt_list is not None:
            result = self._validate(
                "kml_plan",
                pt_list == "-" or Path(pt_list).exists(),
                result,
                f"pt_list path does not exist ({pt_list})",
            )
        if self._wraps is not None:
            result = self._wraps.kml_plan(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "kml_plan", supplied_args, result[0])
        )
        self._on_error("kml_plan", supplied_args, result[0])
        return result

    def kml_map(self, image: str, dem_par: str, kml: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["kml_map"] += 1

        if image is not None:
            result = self._validate(
                "kml_map",
                image == "-" or Path(image).exists(),
                result,
                f"image path does not exist ({image})",
            )
        if dem_par is not None:
            result = self._validate(
                "kml_map",
                dem_par == "-" or Path(dem_par).exists(),
                result,
                f"dem_par path does not exist ({dem_par})",
            )
        if kml is not None and kml != "-":
            Path(kml).touch()
        if self._wraps is not None:
            result = self._wraps.kml_map(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "kml_map", supplied_args, result[0])
        )
        self._on_error("kml_map", supplied_args, result[0])
        return result

    def dismph_pk(
        self,
        cpx: str,
        width,
        start=None,
        nlines=None,
        scale=None,
        exp=None,
        data_type=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dismph_pk"] += 1

        if cpx is not None:
            result = self._validate(
                "dismph_pk",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dismph_pk",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if self._wraps is not None:
            result = self._wraps.dismph_pk(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dismph_pk", supplied_args, result[0])
        )
        self._on_error("dismph_pk", supplied_args, result[0])
        return result

    def ras_dB(
        self,
        pwr,
        width,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        min_dB=None,
        max_dB=None,
        dB_offset=None,
        LR=None,
        rasf: str = None,
        abs_flag=None,
        inverse=None,
        channel=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_dB"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ras_dB",
            abs_flag == "-" or abs_flag in valid_values,
            result,
            f"abs_flag is not a valid value (expects: {valid_values}, got: {abs_flag})",
        )
        valid_values = [1, 2, 3] + [None]
        result = self._validate(
            "ras_dB",
            channel == "-" or channel in valid_values,
            result,
            f"channel is not a valid value (expects: {valid_values}, got: {channel})",
        )
        if self._wraps is not None:
            result = self._wraps.ras_dB(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "ras_dB", supplied_args, result[0]))
        self._on_error("ras_dB", supplied_args, result[0])
        return result

    def thres_data(
        self, data_in: str, width, data_out: str, t_data: str, t_min, t_max, dtype=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["thres_data"] += 1

        if data_in is not None:
            result = self._validate(
                "thres_data",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if t_data is not None:
            result = self._validate(
                "thres_data",
                t_data == "-" or Path(t_data).exists(),
                result,
                f"t_data path does not exist ({t_data})",
            )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "thres_data",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.thres_data(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "thres_data", supplied_args, result[0])
        )
        self._on_error("thres_data", supplied_args, result[0])
        return result

    def distree(
        self, flag: str, unw, cpx: str, width, start=None, nlines=None, ph_scale=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["distree"] += 1

        if flag is not None:
            result = self._validate(
                "distree",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if cpx is not None:
            result = self._validate(
                "distree",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        if self._wraps is not None:
            result = self._wraps.distree(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "distree", supplied_args, result[0])
        )
        self._on_error("distree", supplied_args, result[0])
        return result

    def dis_linear(self, pwr, width, start=None, nlines=None, min=None, max=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis_linear"] += 1

        if self._wraps is not None:
            result = self._wraps.dis_linear(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis_linear", supplied_args, result[0])
        )
        self._on_error("dis_linear", supplied_args, result[0])
        return result

    def disdem_par(
        self,
        DEM,
        DEM_par: str,
        start=None,
        nlines=None,
        exaggerate=None,
        theta0=None,
        phi0=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disdem_par"] += 1

        if DEM_par is not None:
            result = self._validate(
                "disdem_par",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if self._wraps is not None:
            result = self._wraps.disdem_par(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "disdem_par", supplied_args, result[0])
        )
        self._on_error("disdem_par", supplied_args, result[0])
        return result

    def gcp_2ras(self, ras1: str, ras2: str, gcp: str, mag=None, win_sz=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gcp_2ras"] += 1

        if ras1 is not None:
            result = self._validate(
                "gcp_2ras",
                ras1 == "-" or Path(ras1).exists(),
                result,
                f"ras1 path does not exist ({ras1})",
            )
        if ras2 is not None:
            result = self._validate(
                "gcp_2ras",
                ras2 == "-" or Path(ras2).exists(),
                result,
                f"ras2 path does not exist ({ras2})",
            )
        if gcp is not None and gcp != "-":
            Path(gcp).touch()
        if self._wraps is not None:
            result = self._wraps.gcp_2ras(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "gcp_2ras", supplied_args, result[0])
        )
        self._on_error("gcp_2ras", supplied_args, result[0])
        return result

    def rashgt(
        self,
        hgt,
        pwr,
        width,
        start_hgt=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        m_cycle=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rashgt"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rashgt(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "rashgt", supplied_args, result[0]))
        self._on_error("rashgt", supplied_args, result[0])
        return result

    def ras_linear(
        self,
        pwr,
        width,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        min=None,
        max=None,
        LR=None,
        rasf: str = None,
        inverse=None,
        channel=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_linear"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        valid_values = [1, 2, 3] + [None]
        result = self._validate(
            "ras_linear",
            channel == "-" or channel in valid_values,
            result,
            f"channel is not a valid value (expects: {valid_values}, got: {channel})",
        )
        if self._wraps is not None:
            result = self._wraps.ras_linear(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras_linear", supplied_args, result[0])
        )
        self._on_error("ras_linear", supplied_args, result[0])
        return result

    def tree_edit(self, flag: str, ras: str, mag=None, win_sz=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["tree_edit"] += 1

        if flag is not None:
            result = self._validate(
                "tree_edit",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if ras is not None:
            result = self._validate(
                "tree_edit",
                ras == "-" or Path(ras).exists(),
                result,
                f"ras path does not exist ({ras})",
            )
        if self._wraps is not None:
            result = self._wraps.tree_edit(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "tree_edit", supplied_args, result[0])
        )
        self._on_error("tree_edit", supplied_args, result[0])
        return result

    def fill(self, d1, d2, dout: str, width):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["fill"] += 1

        if dout is not None and dout != "-":
            Path(dout).touch()
        if self._wraps is not None:
            result = self._wraps.fill(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "fill", supplied_args, result[0]))
        self._on_error("fill", supplied_args, result[0])
        return result

    def dis2pwr(
        self,
        pwr1,
        pwr2,
        width1,
        width2,
        start=None,
        nlines=None,
        roff=None,
        azoff=None,
        scale=None,
        exp=None,
        dtype=None,
        sc_abs1=None,
        sc_abs2=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2pwr"] += 1

        valid_values = [0, 1] + [None]
        result = self._validate(
            "dis2pwr",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.dis2pwr(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis2pwr", supplied_args, result[0])
        )
        self._on_error("dis2pwr", supplied_args, result[0])
        return result

    def dispwr(
        self,
        pwr: str,
        width,
        start=None,
        nlines=None,
        scale=None,
        exp=None,
        data_type=None,
        sc_abs=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dispwr"] += 1

        if pwr is not None:
            result = self._validate(
                "dispwr",
                pwr == "-" or Path(pwr).exists(),
                result,
                f"pwr path does not exist ({pwr})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "dispwr",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if self._wraps is not None:
            result = self._wraps.dispwr(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "dispwr", supplied_args, result[0]))
        self._on_error("dispwr", supplied_args, result[0])
        return result

    def rasSLC(
        self,
        SLC: str,
        width,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        scale=None,
        exp=None,
        LR=None,
        data_type=None,
        header=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasSLC"] += 1

        if SLC is not None:
            result = self._validate(
                "rasSLC",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "rasSLC",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rasSLC(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "rasSLC", supplied_args, result[0]))
        self._on_error("rasSLC", supplied_args, result[0])
        return result

    def rasmph_pwr24(
        self,
        cpx: str,
        pwr,
        width,
        start_cpx=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
        cc=None,
        start_cc=None,
        cc_min=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasmph_pwr24"] += 1

        if cpx is not None:
            result = self._validate(
                "rasmph_pwr24",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rasmph_pwr24(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "rasmph_pwr24", supplied_args, result[0])
        )
        self._on_error("rasmph_pwr24", supplied_args, result[0])
        return result

    def dismph_ub(self, cpx: str, width, start=None, nlines=None, scale=None, exp=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dismph_ub"] += 1

        if cpx is not None:
            result = self._validate(
                "dismph_ub",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        if self._wraps is not None:
            result = self._wraps.dismph_ub(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dismph_ub", supplied_args, result[0])
        )
        self._on_error("dismph_ub", supplied_args, result[0])
        return result

    def short2float(self, infile: str, outfile: str, scale=None, exp=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["short2float"] += 1

        if infile is not None:
            result = self._validate(
                "short2float",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.short2float(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "short2float", supplied_args, result[0])
        )
        self._on_error("short2float", supplied_args, result[0])
        return result

    def ras8_color_scale(
        self,
        rasf: str,
        color_model=None,
        h0=None,
        hrange=None,
        ival=None,
        sat=None,
        chip_width=None,
        gap=None,
        chip_height=None,
        nval=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras8_color_scale"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "ras8_color_scale",
            color_model == "-" or color_model in valid_values,
            result,
            f"color_model is not a valid value (expects: {valid_values}, got: {color_model})",
        )
        if self._wraps is not None:
            result = self._wraps.ras8_color_scale(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras8_color_scale", supplied_args, result[0])
        )
        self._on_error("ras8_color_scale", supplied_args, result[0])
        return result

    def rasmph(
        self,
        cpx: str,
        width,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
        data_type=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasmph"] += 1

        if cpx is not None:
            result = self._validate(
                "rasmph",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "rasmph",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if self._wraps is not None:
            result = self._wraps.rasmph(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "rasmph", supplied_args, result[0]))
        self._on_error("rasmph", supplied_args, result[0])
        return result

    def get_value(self, PAR_in, keyword):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["get_value"] += 1

        if self._wraps is not None:
            result = self._wraps.get_value(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "get_value", supplied_args, result[0])
        )
        self._on_error("get_value", supplied_args, result[0])
        return result

    def polyras(self, ras: str, mag=None, win_sz=None, poly_file: str = None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["polyras"] += 1

        if ras is not None:
            result = self._validate(
                "polyras",
                ras == "-" or Path(ras).exists(),
                result,
                f"ras path does not exist ({ras})",
            )
        if poly_file is not None and poly_file != "-":
            Path(poly_file).touch()
        if self._wraps is not None:
            result = self._wraps.polyras(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "polyras", supplied_args, result[0])
        )
        self._on_error("polyras", supplied_args, result[0])
        return result

    def rastree(
        self,
        flag: str,
        unw,
        cpx,
        width,
        start=None,
        nlines=None,
        ph_scale=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rastree"] += 1

        if flag is not None:
            result = self._validate(
                "rastree",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rastree(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "rastree", supplied_args, result[0])
        )
        self._on_error("rastree", supplied_args, result[0])
        return result

    def disshd(
        self,
        DEM,
        width,
        col_post,
        row_post=None,
        start=None,
        nlines=None,
        theta0=None,
        phi0=None,
        data_type=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["disshd"] += 1

        valid_values = [0, 1] + [None]
        result = self._validate(
            "disshd",
            data_type == "-" or data_type in valid_values,
            result,
            f"data_type is not a valid value (expects: {valid_values}, got: {data_type})",
        )
        if self._wraps is not None:
            result = self._wraps.disshd(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "disshd", supplied_args, result[0]))
        self._on_error("disshd", supplied_args, result[0])
        return result

    def dis2gbyte(
        self,
        image1: str,
        image2: str,
        width1,
        width2,
        start=None,
        nlines=None,
        roff=None,
        azoff=None,
        scale=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2gbyte"] += 1

        if image1 is not None:
            result = self._validate(
                "dis2gbyte",
                image1 == "-" or Path(image1).exists(),
                result,
                f"image1 path does not exist ({image1})",
            )
        if image2 is not None:
            result = self._validate(
                "dis2gbyte",
                image2 == "-" or Path(image2).exists(),
                result,
                f"image2 path does not exist ({image2})",
            )
        if self._wraps is not None:
            result = self._wraps.dis2gbyte(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis2gbyte", supplied_args, result[0])
        )
        self._on_error("dis2gbyte", supplied_args, result[0])
        return result

    def ras8_float(
        self,
        f1,
        f2,
        width,
        rasf: str,
        color_model=None,
        h0=None,
        hrange=None,
        imin=None,
        imax=None,
        sat=None,
        sc1=None,
        A1=None,
        B1=None,
        cyclic1=None,
        sc2=None,
        A2=None,
        B2=None,
        start_f1=None,
        start_f2=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        LR=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras8_float"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        valid_values = [0, 1, 2, 3, 4] + [None]
        result = self._validate(
            "ras8_float",
            color_model == "-" or color_model in valid_values,
            result,
            f"color_model is not a valid value (expects: {valid_values}, got: {color_model})",
        )
        if self._wraps is not None:
            result = self._wraps.ras8_float(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras8_float", supplied_args, result[0])
        )
        self._on_error("ras8_float", supplied_args, result[0])
        return result

    def flip(self, infile, outfile: str, width, format=None, sense=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["flip"] += 1

        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.flip(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "flip", supplied_args, result[0]))
        self._on_error("flip", supplied_args, result[0])
        return result

    def create_array(self, output: str, width, nlines, dtype=None, val=None, val_im=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["create_array"] += 1

        if output is not None and output != "-":
            Path(output).touch()
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        result = self._validate(
            "create_array",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.create_array(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "create_array", supplied_args, result[0])
        )
        self._on_error("create_array", supplied_args, result[0])
        return result

    def ascii2float(
        self, data_in: str, width, data_out: str, loff=None, nl=None, coff=None, nv=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ascii2float"] += 1

        if data_in is not None:
            result = self._validate(
                "ascii2float",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if self._wraps is not None:
            result = self._wraps.ascii2float(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ascii2float", supplied_args, result[0])
        )
        self._on_error("ascii2float", supplied_args, result[0])
        return result

    def data2tiff(
        self, data: str, width, type, TIFF: str, nodata=None, xspacing=None, yspacing=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["data2tiff"] += 1

        if data is not None:
            result = self._validate(
                "data2tiff",
                data == "-" or Path(data).exists(),
                result,
                f"data path does not exist ({data})",
            )
        valid_values = [0, 1, 2, 3, 4, 5]
        result = self._validate(
            "data2tiff",
            type == "-" or type in valid_values,
            result,
            f"type is not a valid value (expects: {valid_values}, got: {type})",
        )
        if TIFF is not None and TIFF != "-":
            Path(TIFF).touch()
        if self._wraps is not None:
            result = self._wraps.data2tiff(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "data2tiff", supplied_args, result[0])
        )
        self._on_error("data2tiff", supplied_args, result[0])
        return result

    def mapshd(
        self,
        DEM,
        width,
        col_post,
        row_post,
        theta0,
        phi0,
        shade: str,
        dtype=None,
        zero_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["mapshd"] += 1

        if shade is not None and shade != "-":
            Path(shade).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "mapshd",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "mapshd",
            zero_flag == "-" or zero_flag in valid_values,
            result,
            f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.mapshd(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "mapshd", supplied_args, result[0]))
        self._on_error("mapshd", supplied_args, result[0])
        return result

    def kml_pt(
        self,
        table: str,
        lat_col,
        lon_col,
        val1_col,
        val1_label,
        val2_col,
        val2_label,
        val3_col,
        val3_label,
        id_col,
        kml: str,
        icon_URL=None,
        logo_URL=None,
        legend_URL=None,
        color_model=None,
        h0=None,
        hrange=None,
        imin=None,
        imax=None,
        sat_min=None,
        sat_max=None,
        sc1=None,
        A1=None,
        B1=None,
        cyclic1=None,
        sc2=None,
        A2=None,
        B2=None,
        start_f1=None,
        start_f2=None,
        B3=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["kml_pt"] += 1

        if table is not None:
            result = self._validate(
                "kml_pt",
                table == "-" or Path(table).exists(),
                result,
                f"table path does not exist ({table})",
            )
        if kml is not None and kml != "-":
            Path(kml).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "kml_pt",
            color_model == "-" or color_model in valid_values,
            result,
            f"color_model is not a valid value (expects: {valid_values}, got: {color_model})",
        )
        if self._wraps is not None:
            result = self._wraps.kml_pt(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "kml_pt", supplied_args, result[0]))
        self._on_error("kml_pt", supplied_args, result[0])
        return result

    def vec_to_real(self, vec, width, index, cmp: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["vec_to_real"] += 1

        valid_values = [1, 2, 3]
        result = self._validate(
            "vec_to_real",
            index == "-" or index in valid_values,
            result,
            f"index is not a valid value (expects: {valid_values}, got: {index})",
        )
        if cmp is not None and cmp != "-":
            Path(cmp).touch()
        if self._wraps is not None:
            result = self._wraps.vec_to_real(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "vec_to_real", supplied_args, result[0])
        )
        self._on_error("vec_to_real", supplied_args, result[0])
        return result

    def dismph_pwr24(
        self,
        cpx: str,
        pwr,
        width,
        start_cpx=None,
        start_pwr=None,
        nlines=None,
        scale=None,
        exp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dismph_pwr24"] += 1

        if cpx is not None:
            result = self._validate(
                "dismph_pwr24",
                cpx == "-" or Path(cpx).exists(),
                result,
                f"cpx path does not exist ({cpx})",
            )
        if self._wraps is not None:
            result = self._wraps.dismph_pwr24(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dismph_pwr24", supplied_args, result[0])
        )
        self._on_error("dismph_pwr24", supplied_args, result[0])
        return result

    def swap_bytes(self, infile: str, outfile: str, swap_type):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["swap_bytes"] += 1

        if infile is not None:
            result = self._validate(
                "swap_bytes",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        valid_values = [2, 4, 8]
        result = self._validate(
            "swap_bytes",
            swap_type == "-" or swap_type in valid_values,
            result,
            f"swap_type is not a valid value (expects: {valid_values}, got: {swap_type})",
        )
        if self._wraps is not None:
            result = self._wraps.swap_bytes(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "swap_bytes", supplied_args, result[0])
        )
        self._on_error("swap_bytes", supplied_args, result[0])
        return result

    def float2double(self, infile, outfile: str, scale, exp):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["float2double"] += 1

        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.float2double(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "float2double", supplied_args, result[0])
        )
        self._on_error("float2double", supplied_args, result[0])
        return result

    def dis2byte(
        self,
        image1: str,
        image2: str,
        width1,
        width2,
        start=None,
        nlines=None,
        roff=None,
        azoff=None,
        scale=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2byte"] += 1

        if image1 is not None:
            result = self._validate(
                "dis2byte",
                image1 == "-" or Path(image1).exists(),
                result,
                f"image1 path does not exist ({image1})",
            )
        if image2 is not None:
            result = self._validate(
                "dis2byte",
                image2 == "-" or Path(image2).exists(),
                result,
                f"image2 path does not exist ({image2})",
            )
        if self._wraps is not None:
            result = self._wraps.dis2byte(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "dis2byte", supplied_args, result[0])
        )
        self._on_error("dis2byte", supplied_args, result[0])
        return result

    def svg_poly(
        self,
        image: str,
        dem_par: str,
        poly: str,
        svg: str,
        width=None,
        nlines=None,
        thick=None,
        lcolor=None,
        lopac=None,
        pcolor=None,
        popac=None,
        tcolor=None,
        font=None,
        fsize=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["svg_poly"] += 1

        if image is not None:
            result = self._validate(
                "svg_poly",
                image == "-" or Path(image).exists(),
                result,
                f"image path does not exist ({image})",
            )
        if dem_par is not None:
            result = self._validate(
                "svg_poly",
                dem_par == "-" or Path(dem_par).exists(),
                result,
                f"dem_par path does not exist ({dem_par})",
            )
        if poly is not None:
            result = self._validate(
                "svg_poly",
                poly == "-" or Path(poly).exists(),
                result,
                f"poly path does not exist ({poly})",
            )
        if svg is not None and svg != "-":
            Path(svg).touch()
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] + [None]
        result = self._validate(
            "svg_poly",
            thick == "-" or thick in valid_values,
            result,
            f"thick is not a valid value (expects: {valid_values}, got: {thick})",
        )
        if self._wraps is not None:
            result = self._wraps.svg_poly(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "svg_poly", supplied_args, result[0])
        )
        self._on_error("svg_poly", supplied_args, result[0])
        return result

    def rasbyte(
        self,
        raw: str,
        width,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        scale=None,
        LR=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rasbyte"] += 1

        if raw is not None:
            result = self._validate(
                "rasbyte",
                raw == "-" or Path(raw).exists(),
                result,
                f"raw path does not exist ({raw})",
            )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rasbyte(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "rasbyte", supplied_args, result[0])
        )
        self._on_error("rasbyte", supplied_args, result[0])
        return result

    def ras_cpt_scale(
        self,
        rasf: str,
        cpt: str,
        color_model=None,
        width=None,
        nlines=None,
        start_value=None,
        end_value=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_cpt_scale"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if cpt is not None:
            result = self._validate(
                "ras_cpt_scale",
                cpt == "-" or Path(cpt).exists(),
                result,
                f"cpt path does not exist ({cpt})",
            )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "ras_cpt_scale",
            color_model == "-" or color_model in valid_values,
            result,
            f"color_model is not a valid value (expects: {valid_values}, got: {color_model})",
        )
        if self._wraps is not None:
            result = self._wraps.ras_cpt_scale(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "ras_cpt_scale", supplied_args, result[0])
        )
        self._on_error("ras_cpt_scale", supplied_args, result[0])
        return result

    def dis2cc(
        self,
        cc1,
        cc2,
        width1,
        width2,
        start=None,
        nlines=None,
        roff=None,
        azoff=None,
        cmin=None,
        cmax=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dis2cc"] += 1

        if self._wraps is not None:
            result = self._wraps.dis2cc(*supplied_args)

        self.call_sequence.append(PyGammaCall("DISP", "dis2cc", supplied_args, result[0]))
        self._on_error("dis2cc", supplied_args, result[0])
        return result

    def float2ascii(self, din, width, data_out: str, loff=None, nl=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["float2ascii"] += 1

        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if self._wraps is not None:
            result = self._wraps.float2ascii(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "float2ascii", supplied_args, result[0])
        )
        self._on_error("float2ascii", supplied_args, result[0])
        return result

    def replace_values(
        self,
        f_in: str,
        value,
        new_value,
        f_out: str,
        width,
        rpl_flg=None,
        dtype=None,
        zflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["replace_values"] += 1

        if f_in is not None:
            result = self._validate(
                "replace_values",
                f_in == "-" or Path(f_in).exists(),
                result,
                f"f_in path does not exist ({f_in})",
            )
        if f_out is not None and f_out != "-":
            Path(f_out).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "replace_values",
            rpl_flg == "-" or rpl_flg in valid_values,
            result,
            f"rpl_flg is not a valid value (expects: {valid_values}, got: {rpl_flg})",
        )
        valid_values = [2, 4] + [None]
        result = self._validate(
            "replace_values",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "replace_values",
            zflg == "-" or zflg in valid_values,
            result,
            f"zflg is not a valid value (expects: {valid_values}, got: {zflg})",
        )
        if self._wraps is not None:
            result = self._wraps.replace_values(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("DISP", "replace_values", supplied_args, result[0])
        )
        self._on_error("replace_values", supplied_args, result[0])
        return result

    def sbi_offset(
        self, sbi_unw, SLCf_par: str, SLCb_par: str, OFF_par: str, az_offset: str
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["sbi_offset"] += 1

        if SLCf_par is not None:
            result = self._validate(
                "sbi_offset",
                SLCf_par == "-" or Path(SLCf_par).exists(),
                result,
                f"SLCf_par path does not exist ({SLCf_par})",
            )
        if SLCb_par is not None:
            result = self._validate(
                "sbi_offset",
                SLCb_par == "-" or Path(SLCb_par).exists(),
                result,
                f"SLCb_par path does not exist ({SLCb_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "sbi_offset",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if az_offset is not None and az_offset != "-":
            Path(az_offset).touch()
        if self._wraps is not None:
            result = self._wraps.sbi_offset(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "sbi_offset", supplied_args, result[0])
        )
        self._on_error("sbi_offset", supplied_args, result[0])
        return result

    def par_ASF_RSAT_SS(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ASF_RSAT_SS"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_ASF_RSAT_SS",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if CEOS_data is not None:
            result = self._validate(
                "par_ASF_RSAT_SS",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if self._wraps is not None:
            result = self._wraps.par_ASF_RSAT_SS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ASF_RSAT_SS", supplied_args, result[0])
        )
        self._on_error("par_ASF_RSAT_SS", supplied_args, result[0])
        return result

    def par_ASF_SLC(
        self, CEOS_SAR_leader, SLC_par: str, CEOS_data: str = None, SLC: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ASF_SLC"] += 1

        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if CEOS_data is not None:
            result = self._validate(
                "par_ASF_SLC",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_ASF_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ASF_SLC", supplied_args, result[0])
        )
        self._on_error("par_ASF_SLC", supplied_args, result[0])
        return result

    def par_KS_SLC(self, HDF5: str, trunk: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_KS_SLC"] += 1

        if HDF5 is not None:
            result = self._validate(
                "par_KS_SLC",
                HDF5 == "-" or Path(HDF5).exists(),
                result,
                f"HDF5 path does not exist ({HDF5})",
            )
        if trunk is not None and trunk != "-":
            Path(trunk).touch()
        if self._wraps is not None:
            result = self._wraps.par_KS_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_KS_SLC", supplied_args, result[0])
        )
        self._on_error("par_KS_SLC", supplied_args, result[0])
        return result

    def ScanSAR_full_aperture_SLC(
        self,
        SLC1_tab: str,
        SLC2_tab: str,
        SLCR_tab: str = None,
        SLCR_dir=None,
        vmode=None,
        wflg=None,
        imode=None,
        order=None,
        n_ovr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ScanSAR_full_aperture_SLC"] += 1

        if SLC1_tab is not None:
            result = self._validate(
                "ScanSAR_full_aperture_SLC",
                SLC1_tab == "-" or Path(SLC1_tab).exists(),
                result,
                f"SLC1_tab path does not exist ({SLC1_tab})",
            )
        if SLC2_tab is not None and SLC2_tab != "-" and not Path(SLC2_tab).exists():
            Path(SLC2_tab).touch()
        if SLCR_tab is not None:
            result = self._validate(
                "ScanSAR_full_aperture_SLC",
                SLCR_tab == "-" or Path(SLCR_tab).exists(),
                result,
                f"SLCR_tab path does not exist ({SLCR_tab})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ScanSAR_full_aperture_SLC",
            vmode == "-" or vmode in valid_values,
            result,
            f"vmode is not a valid value (expects: {valid_values}, got: {vmode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ScanSAR_full_aperture_SLC",
            wflg == "-" or wflg in valid_values,
            result,
            f"wflg is not a valid value (expects: {valid_values}, got: {wflg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ScanSAR_full_aperture_SLC",
            imode == "-" or imode in valid_values,
            result,
            f"imode is not a valid value (expects: {valid_values}, got: {imode})",
        )
        if self._wraps is not None:
            result = self._wraps.ScanSAR_full_aperture_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ScanSAR_full_aperture_SLC", supplied_args, result[0])
        )
        self._on_error("ScanSAR_full_aperture_SLC", supplied_args, result[0])
        return result

    def init_offset(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        rlks=None,
        azlks=None,
        rpos=None,
        azpos=None,
        offr=None,
        offaz=None,
        thres=None,
        rwin=None,
        azwin=None,
        cflag=None,
        deramp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["init_offset"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "init_offset",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "init_offset",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "init_offset",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "init_offset",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "init_offset",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "init_offset",
            cflag == "-" or cflag in valid_values,
            result,
            f"cflag is not a valid value (expects: {valid_values}, got: {cflag})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "init_offset",
            deramp == "-" or deramp in valid_values,
            result,
            f"deramp is not a valid value (expects: {valid_values}, got: {deramp})",
        )
        if self._wraps is not None:
            result = self._wraps.init_offset(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "init_offset", supplied_args, result[0])
        )
        self._on_error("init_offset", supplied_args, result[0])
        return result

    def bridge(
        self,
        int: str,
        flag: str,
        unw: str,
        bridge: str,
        width,
        xmin=None,
        xmax=None,
        ymin=None,
        ymax=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["bridge"] += 1

        if int is not None:
            result = self._validate(
                "bridge",
                int == "-" or Path(int).exists(),
                result,
                f"int path does not exist ({int})",
            )
        if flag is not None:
            result = self._validate(
                "bridge",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if unw is not None and unw != "-" and not Path(unw).exists():
            Path(unw).touch()
        if bridge is not None:
            result = self._validate(
                "bridge",
                bridge == "-" or Path(bridge).exists(),
                result,
                f"bridge path does not exist ({bridge})",
            )
        if self._wraps is not None:
            result = self._wraps.bridge(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "bridge", supplied_args, result[0]))
        self._on_error("bridge", supplied_args, result[0])
        return result

    def par_ERSDAC_PALSAR(self, VEXCEL_SLC_par, SLC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ERSDAC_PALSAR"] += 1

        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_ERSDAC_PALSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ERSDAC_PALSAR", supplied_args, result[0])
        )
        self._on_error("par_ERSDAC_PALSAR", supplied_args, result[0])
        return result

    def SR_to_GRD(
        self,
        MLI_par,
        OFF_par: str,
        GRD_par: str,
        in_file,
        out_file: str,
        rlks=None,
        azlks=None,
        interp_mode=None,
        grd_rsp=None,
        grd_azsp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SR_to_GRD"] += 1

        if OFF_par is not None:
            result = self._validate(
                "SR_to_GRD",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if GRD_par is not None and GRD_par != "-" and not Path(GRD_par).exists():
            Path(GRD_par).touch()
        if out_file is not None and out_file != "-":
            Path(out_file).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "SR_to_GRD",
            interp_mode == "-" or interp_mode in valid_values,
            result,
            f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.SR_to_GRD(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SR_to_GRD", supplied_args, result[0])
        )
        self._on_error("SR_to_GRD", supplied_args, result[0])
        return result

    def par_ACS_ERS(self, CEOS_SAR_leader: str, SLC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ACS_ERS"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "par_ACS_ERS",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_ACS_ERS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ACS_ERS", supplied_args, result[0])
        )
        self._on_error("par_ACS_ERS", supplied_args, result[0])
        return result

    def offset_fit(
        self,
        offs: str,
        ccp,
        OFF_par: str,
        coffs: str = None,
        coffsets: str = None,
        thres=None,
        npoly=None,
        interact_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_fit"] += 1

        if offs is not None:
            result = self._validate(
                "offset_fit",
                offs == "-" or Path(offs).exists(),
                result,
                f"offs path does not exist ({offs})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_fit",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if coffs is not None and coffs != "-":
            Path(coffs).touch()
        if coffsets is not None and coffsets != "-":
            Path(coffsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_fit",
            interact_flag == "-" or interact_flag in valid_values,
            result,
            f"interact_flag is not a valid value (expects: {valid_values}, got: {interact_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.offset_fit(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_fit", supplied_args, result[0])
        )
        self._on_error("offset_fit", supplied_args, result[0])
        return result

    def radcal_PRI(
        self,
        PRI: str,
        PRI_PAR: str,
        GRD: str,
        GRD_PAR: str,
        K_dB=None,
        inc_ref=None,
        roff=None,
        nr=None,
        loff=None,
        nl=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["radcal_PRI"] += 1

        if PRI is not None:
            result = self._validate(
                "radcal_PRI",
                PRI == "-" or Path(PRI).exists(),
                result,
                f"PRI path does not exist ({PRI})",
            )
        if PRI_PAR is not None:
            result = self._validate(
                "radcal_PRI",
                PRI_PAR == "-" or Path(PRI_PAR).exists(),
                result,
                f"PRI_PAR path does not exist ({PRI_PAR})",
            )
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if GRD_PAR is not None and GRD_PAR != "-":
            Path(GRD_PAR).touch()
        if self._wraps is not None:
            result = self._wraps.radcal_PRI(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "radcal_PRI", supplied_args, result[0])
        )
        self._on_error("radcal_PRI", supplied_args, result[0])
        return result

    def gcp_phase(self, unw: str, OFF_par: str, gcp: str, gcp_ph: str, win_sz=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gcp_phase"] += 1

        if unw is not None:
            result = self._validate(
                "gcp_phase",
                unw == "-" or Path(unw).exists(),
                result,
                f"unw path does not exist ({unw})",
            )
        if OFF_par is not None:
            result = self._validate(
                "gcp_phase",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if gcp is not None:
            result = self._validate(
                "gcp_phase",
                gcp == "-" or Path(gcp).exists(),
                result,
                f"gcp path does not exist ({gcp})",
            )
        if gcp_ph is not None and gcp_ph != "-":
            Path(gcp_ph).touch()
        if self._wraps is not None:
            result = self._wraps.gcp_phase(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "gcp_phase", supplied_args, result[0])
        )
        self._on_error("gcp_phase", supplied_args, result[0])
        return result

    def par_MSP(
        self, SAR_par: str, PROC_par: str, SLC_MLI_par: str = None, image_format=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_MSP"] += 1

        if SAR_par is not None:
            result = self._validate(
                "par_MSP",
                SAR_par == "-" or Path(SAR_par).exists(),
                result,
                f"SAR_par path does not exist ({SAR_par})",
            )
        if PROC_par is not None:
            result = self._validate(
                "par_MSP",
                PROC_par == "-" or Path(PROC_par).exists(),
                result,
                f"PROC_par path does not exist ({PROC_par})",
            )
        if SLC_MLI_par is not None and SLC_MLI_par != "-":
            Path(SLC_MLI_par).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "par_MSP",
            image_format == "-" or image_format in valid_values,
            result,
            f"image_format is not a valid value (expects: {valid_values}, got: {image_format})",
        )
        if self._wraps is not None:
            result = self._wraps.par_MSP(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "par_MSP", supplied_args, result[0]))
        self._on_error("par_MSP", supplied_args, result[0])
        return result

    def offset_pwr_tracking2(
        self,
        SLC1: str,
        SLC2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        offs: str,
        ccp: str,
        OFF_par2: str = None,
        offs2: str = None,
        rwin=None,
        azwin=None,
        offsets: str = None,
        n_ovr=None,
        thres=None,
        rstep=None,
        azstep=None,
        rstart=None,
        rstop=None,
        azstart=None,
        azstop=None,
        bw_frac=None,
        deramp=None,
        int_filt=None,
        pflag=None,
        pltflg=None,
        ccs: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_pwr_tracking2"] += 1

        if SLC1 is not None:
            result = self._validate(
                "offset_pwr_tracking2",
                SLC1 == "-" or Path(SLC1).exists(),
                result,
                f"SLC1 path does not exist ({SLC1})",
            )
        if SLC2 is not None:
            result = self._validate(
                "offset_pwr_tracking2",
                SLC2 == "-" or Path(SLC2).exists(),
                result,
                f"SLC2 path does not exist ({SLC2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "offset_pwr_tracking2",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "offset_pwr_tracking2",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_pwr_tracking2",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if OFF_par2 is not None:
            result = self._validate(
                "offset_pwr_tracking2",
                OFF_par2 == "-" or Path(OFF_par2).exists(),
                result,
                f"OFF_par2 path does not exist ({OFF_par2})",
            )
        if offs2 is not None:
            result = self._validate(
                "offset_pwr_tracking2",
                offs2 == "-" or Path(offs2).exists(),
                result,
                f"offs2 path does not exist ({offs2})",
            )
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_tracking2",
            deramp == "-" or deramp in valid_values,
            result,
            f"deramp is not a valid value (expects: {valid_values}, got: {deramp})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_tracking2",
            int_filt == "-" or int_filt in valid_values,
            result,
            f"int_filt is not a valid value (expects: {valid_values}, got: {int_filt})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_tracking2",
            pflag == "-" or pflag in valid_values,
            result,
            f"pflag is not a valid value (expects: {valid_values}, got: {pflag})",
        )
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "offset_pwr_tracking2",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if ccs is not None and ccs != "-":
            Path(ccs).touch()
        if self._wraps is not None:
            result = self._wraps.offset_pwr_tracking2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_pwr_tracking2", supplied_args, result[0])
        )
        self._on_error("offset_pwr_tracking2", supplied_args, result[0])
        return result

    def offset_tracking(
        self,
        offs: str,
        ccp,
        SLC_par: str,
        OFF_par: str,
        disp_map: str,
        disp_val: str = None,
        mode=None,
        thres=None,
        poly_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_tracking"] += 1

        if offs is not None:
            result = self._validate(
                "offset_tracking",
                offs == "-" or Path(offs).exists(),
                result,
                f"offs path does not exist ({offs})",
            )
        if SLC_par is not None:
            result = self._validate(
                "offset_tracking",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_tracking",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if disp_map is not None and disp_map != "-":
            Path(disp_map).touch()
        if disp_val is not None and disp_val != "-":
            Path(disp_val).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "offset_tracking",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_tracking",
            poly_flag == "-" or poly_flag in valid_values,
            result,
            f"poly_flag is not a valid value (expects: {valid_values}, got: {poly_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.offset_tracking(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_tracking", supplied_args, result[0])
        )
        self._on_error("offset_tracking", supplied_args, result[0])
        return result

    def SLC_interp_ScanSAR(
        self,
        SLC2_tab: str,
        SLC2_par: str,
        SLC1_tab: str,
        SLC1_par: str,
        OFF_par,
        SLC2R_tab: str,
        SLC_2R: str = None,
        SLC2R_par: str = None,
        mode=None,
        order=None,
        SLC2R_dir=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_interp_ScanSAR"] += 1

        if SLC2_tab is not None:
            result = self._validate(
                "SLC_interp_ScanSAR",
                SLC2_tab == "-" or Path(SLC2_tab).exists(),
                result,
                f"SLC2_tab path does not exist ({SLC2_tab})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "SLC_interp_ScanSAR",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if SLC1_tab is not None:
            result = self._validate(
                "SLC_interp_ScanSAR",
                SLC1_tab == "-" or Path(SLC1_tab).exists(),
                result,
                f"SLC1_tab path does not exist ({SLC1_tab})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_interp_ScanSAR",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2R_tab is not None and SLC2R_tab != "-" and not Path(SLC2R_tab).exists():
            Path(SLC2R_tab).touch()
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_interp_ScanSAR",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_interp_ScanSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_interp_ScanSAR", supplied_args, result[0])
        )
        self._on_error("SLC_interp_ScanSAR", supplied_args, result[0])
        return result

    def error_stat(self, d1: str, d2: str, width, dtype, roff, loff, nr, nl, report):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["error_stat"] += 1

        if d1 is not None:
            result = self._validate(
                "error_stat",
                d1 == "-" or Path(d1).exists(),
                result,
                f"d1 path does not exist ({d1})",
            )
        if d2 is not None:
            result = self._validate(
                "error_stat",
                d2 == "-" or Path(d2).exists(),
                result,
                f"d2 path does not exist ({d2})",
            )
        valid_values = [0, 1]
        result = self._validate(
            "error_stat",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.error_stat(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "error_stat", supplied_args, result[0])
        )
        self._on_error("error_stat", supplied_args, result[0])
        return result

    def res_map(
        self,
        hgt: str,
        gr: str,
        data,
        SLC_par: str,
        OFF_par,
        res_hgt: str,
        res_data: str,
        nr=None,
        naz=None,
        azps_res=None,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["res_map"] += 1

        if hgt is not None:
            result = self._validate(
                "res_map",
                hgt == "-" or Path(hgt).exists(),
                result,
                f"hgt path does not exist ({hgt})",
            )
        if gr is not None:
            result = self._validate(
                "res_map",
                gr == "-" or Path(gr).exists(),
                result,
                f"gr path does not exist ({gr})",
            )
        if SLC_par is not None:
            result = self._validate(
                "res_map",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if res_hgt is not None and res_hgt != "-":
            Path(res_hgt).touch()
        if res_data is not None and res_data != "-":
            Path(res_data).touch()
        if self._wraps is not None:
            result = self._wraps.res_map(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "res_map", supplied_args, result[0]))
        self._on_error("res_map", supplied_args, result[0])
        return result

    def RSAT2_vec(self, SLC_par: str, RSAT2_orb, nstate=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["RSAT2_vec"] += 1

        if SLC_par is not None:
            result = self._validate(
                "RSAT2_vec",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if self._wraps is not None:
            result = self._wraps.RSAT2_vec(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "RSAT2_vec", supplied_args, result[0])
        )
        self._on_error("RSAT2_vec", supplied_args, result[0])
        return result

    def par_S1_GRD(
        self,
        GeoTIFF: str,
        annotation_XML: str,
        calibration_XML: str,
        noise_XML: str,
        MLI_par: str,
        MLI: str,
        GRD_par: str = None,
        GRD: str = None,
        eflg=None,
        rps=None,
        noise_pwr=None,
        edge_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_S1_GRD"] += 1

        if GeoTIFF is not None:
            result = self._validate(
                "par_S1_GRD",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if annotation_XML is not None:
            result = self._validate(
                "par_S1_GRD",
                annotation_XML == "-" or Path(annotation_XML).exists(),
                result,
                f"annotation_XML path does not exist ({annotation_XML})",
            )
        if calibration_XML is not None:
            result = self._validate(
                "par_S1_GRD",
                calibration_XML == "-" or Path(calibration_XML).exists(),
                result,
                f"calibration_XML path does not exist ({calibration_XML})",
            )
        if noise_XML is not None:
            result = self._validate(
                "par_S1_GRD",
                noise_XML == "-" or Path(noise_XML).exists(),
                result,
                f"noise_XML path does not exist ({noise_XML})",
            )
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if self._wraps is not None:
            result = self._wraps.par_S1_GRD(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_S1_GRD", supplied_args, result[0])
        )
        self._on_error("par_S1_GRD", supplied_args, result[0])
        return result

    def SLC_deramp_S1_TOPS(self, SLC1_tab: str, SLC2_tab: str, mode, phflg):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_deramp_S1_TOPS"] += 1

        if SLC1_tab is not None:
            result = self._validate(
                "SLC_deramp_S1_TOPS",
                SLC1_tab == "-" or Path(SLC1_tab).exists(),
                result,
                f"SLC1_tab path does not exist ({SLC1_tab})",
            )
        if SLC2_tab is not None:
            result = self._validate(
                "SLC_deramp_S1_TOPS",
                SLC2_tab == "-" or Path(SLC2_tab).exists(),
                result,
                f"SLC2_tab path does not exist ({SLC2_tab})",
            )
        valid_values = [0, 1]
        result = self._validate(
            "SLC_deramp_S1_TOPS",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1]
        result = self._validate(
            "SLC_deramp_S1_TOPS",
            phflg == "-" or phflg in valid_values,
            result,
            f"phflg is not a valid value (expects: {valid_values}, got: {phflg})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_deramp_S1_TOPS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_deramp_S1_TOPS", supplied_args, result[0])
        )
        self._on_error("SLC_deramp_S1_TOPS", supplied_args, result[0])
        return result

    def par_RSAT_SGF(
        self,
        CEOS_leader: str,
        CEOS_data: str,
        GRD_par: str,
        GRD: str,
        sc_dB=None,
        dt=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RSAT_SGF"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_RSAT_SGF",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if CEOS_data is not None:
            result = self._validate(
                "par_RSAT_SGF",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if self._wraps is not None:
            result = self._wraps.par_RSAT_SGF(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RSAT_SGF", supplied_args, result[0])
        )
        self._on_error("par_RSAT_SGF", supplied_args, result[0])
        return result

    def par_ICEYE_GRD(
        self,
        GeoTIFF: str,
        MLI_par: str,
        mli=None,
        GRD_par: str = None,
        GRD=None,
        rps=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ICEYE_GRD"] += 1

        if GeoTIFF is not None:
            result = self._validate(
                "par_ICEYE_GRD",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if MLI_par is not None:
            result = self._validate(
                "par_ICEYE_GRD",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_ICEYE_GRD(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ICEYE_GRD", supplied_args, result[0])
        )
        self._on_error("par_ICEYE_GRD", supplied_args, result[0])
        return result

    def par_CS_SLC_TIF(self, GeoTIFF: str, XML: str, trunk: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_CS_SLC_TIF"] += 1

        if GeoTIFF is not None:
            result = self._validate(
                "par_CS_SLC_TIF",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if XML is not None:
            result = self._validate(
                "par_CS_SLC_TIF",
                XML == "-" or Path(XML).exists(),
                result,
                f"XML path does not exist ({XML})",
            )
        if trunk is not None and trunk != "-":
            Path(trunk).touch()
        if self._wraps is not None:
            result = self._wraps.par_CS_SLC_TIF(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_CS_SLC_TIF", supplied_args, result[0])
        )
        self._on_error("par_CS_SLC_TIF", supplied_args, result[0])
        return result

    def DORIS_vec(self, SLC_PAR: str, DOR: str, nstate=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["DORIS_vec"] += 1

        if SLC_PAR is not None and SLC_PAR != "-" and not Path(SLC_PAR).exists():
            Path(SLC_PAR).touch()
        if DOR is not None:
            result = self._validate(
                "DORIS_vec",
                DOR == "-" or Path(DOR).exists(),
                result,
                f"DOR path does not exist ({DOR})",
            )
        if self._wraps is not None:
            result = self._wraps.DORIS_vec(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "DORIS_vec", supplied_args, result[0])
        )
        self._on_error("DORIS_vec", supplied_args, result[0])
        return result

    def bpf(
        self,
        data_in,
        data_out: str,
        width,
        fc_x,
        bw_x,
        fc_y,
        bw_y,
        roff=None,
        azoff=None,
        nr=None,
        naz=None,
        data_type=None,
        f_mode=None,
        beta=None,
        fir_len=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["bpf"] += 1

        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if self._wraps is not None:
            result = self._wraps.bpf(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "bpf", supplied_args, result[0]))
        self._on_error("bpf", supplied_args, result[0])
        return result

    def image_stat(self, image, width, roff, loff, nr, nl, report):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["image_stat"] += 1

        if self._wraps is not None:
            result = self._wraps.image_stat(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "image_stat", supplied_args, result[0])
        )
        self._on_error("image_stat", supplied_args, result[0])
        return result

    def clear_flag(self, flag: str, width, flag_bits, xmin, xmax, ymin=None, ymax=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["clear_flag"] += 1

        if flag is not None:
            result = self._validate(
                "clear_flag",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if self._wraps is not None:
            result = self._wraps.clear_flag(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "clear_flag", supplied_args, result[0])
        )
        self._on_error("clear_flag", supplied_args, result[0])
        return result

    def par_NovaSAR_GRD(
        self,
        GeoTIFF: str,
        XML: str,
        polarization,
        MLI_par: str,
        MLI: str = None,
        GRD_par: str = None,
        GRD: str = None,
        rps=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_NovaSAR_GRD"] += 1

        if GeoTIFF is not None:
            result = self._validate(
                "par_NovaSAR_GRD",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if XML is not None:
            result = self._validate(
                "par_NovaSAR_GRD",
                XML == "-" or Path(XML).exists(),
                result,
                f"XML path does not exist ({XML})",
            )
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if self._wraps is not None:
            result = self._wraps.par_NovaSAR_GRD(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_NovaSAR_GRD", supplied_args, result[0])
        )
        self._on_error("par_NovaSAR_GRD", supplied_args, result[0])
        return result

    def slant_range(self, SLC_par: str, slr: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["slant_range"] += 1

        if SLC_par is not None:
            result = self._validate(
                "slant_range",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if slr is not None and slr != "-":
            Path(slr).touch()
        if self._wraps is not None:
            result = self._wraps.slant_range(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "slant_range", supplied_args, result[0])
        )
        self._on_error("slant_range", supplied_args, result[0])
        return result

    def par_IECAS_SLC(
        self, aux_data: str, slc_Re: str, slc_Im: str, date: str, SLC_par: str, SLC: str
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_IECAS_SLC"] += 1

        if aux_data is not None:
            result = self._validate(
                "par_IECAS_SLC",
                aux_data == "-" or Path(aux_data).exists(),
                result,
                f"aux_data path does not exist ({aux_data})",
            )
        if slc_Re is not None:
            result = self._validate(
                "par_IECAS_SLC",
                slc_Re == "-" or Path(slc_Re).exists(),
                result,
                f"slc_Re path does not exist ({slc_Re})",
            )
        if slc_Im is not None:
            result = self._validate(
                "par_IECAS_SLC",
                slc_Im == "-" or Path(slc_Im).exists(),
                result,
                f"slc_Im path does not exist ({slc_Im})",
            )
        if date is not None:
            result = self._validate(
                "par_IECAS_SLC",
                date == "-" or Path(date).exists(),
                result,
                f"date path does not exist ({date})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_IECAS_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_IECAS_SLC", supplied_args, result[0])
        )
        self._on_error("par_IECAS_SLC", supplied_args, result[0])
        return result

    def corr_flag(
        self,
        corr: str,
        flag: str,
        width,
        corr_thr,
        xmin=None,
        xmax=None,
        ymin=None,
        ymax=None,
        border=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["corr_flag"] += 1

        if corr is not None:
            result = self._validate(
                "corr_flag",
                corr == "-" or Path(corr).exists(),
                result,
                f"corr path does not exist ({corr})",
            )
        if flag is not None and flag != "-" and not Path(flag).exists():
            Path(flag).touch()
        if self._wraps is not None:
            result = self._wraps.corr_flag(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "corr_flag", supplied_args, result[0])
        )
        self._on_error("corr_flag", supplied_args, result[0])
        return result

    def ptarg_cal_MLI(
        self,
        MLI_par: str,
        MLI: str,
        r_samp,
        az_samp,
        psigma,
        c_r_samp,
        c_az_samp,
        ptr_image: str,
        r_plot: str,
        az_plot: str,
        pcal: str,
        osf=None,
        win=None,
        pltflg=None,
        psz=None,
        csz=None,
        theta_inc=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ptarg_cal_MLI"] += 1

        if MLI_par is not None:
            result = self._validate(
                "ptarg_cal_MLI",
                MLI_par == "-" or Path(MLI_par).exists(),
                result,
                f"MLI_par path does not exist ({MLI_par})",
            )
        if MLI is not None:
            result = self._validate(
                "ptarg_cal_MLI",
                MLI == "-" or Path(MLI).exists(),
                result,
                f"MLI path does not exist ({MLI})",
            )
        if ptr_image is not None and ptr_image != "-":
            Path(ptr_image).touch()
        if r_plot is not None and r_plot != "-":
            Path(r_plot).touch()
        if az_plot is not None and az_plot != "-":
            Path(az_plot).touch()
        if pcal is not None and pcal != "-":
            Path(pcal).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "ptarg_cal_MLI",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.ptarg_cal_MLI(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ptarg_cal_MLI", supplied_args, result[0])
        )
        self._on_error("ptarg_cal_MLI", supplied_args, result[0])
        return result

    def ORB_filt(self, SLC_par_in: str, SLC_par_out: str, interval=None, extra=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ORB_filt"] += 1

        if SLC_par_in is not None:
            result = self._validate(
                "ORB_filt",
                SLC_par_in == "-" or Path(SLC_par_in).exists(),
                result,
                f"SLC_par_in path does not exist ({SLC_par_in})",
            )
        if SLC_par_out is not None and SLC_par_out != "-":
            Path(SLC_par_out).touch()
        if self._wraps is not None:
            result = self._wraps.ORB_filt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ORB_filt", supplied_args, result[0])
        )
        self._on_error("ORB_filt", supplied_args, result[0])
        return result

    def offset_sub(self, offs: str, OFF_par: str, offs_sub: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_sub"] += 1

        if offs is not None:
            result = self._validate(
                "offset_sub",
                offs == "-" or Path(offs).exists(),
                result,
                f"offs path does not exist ({offs})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_sub",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if offs_sub is not None and offs_sub != "-":
            Path(offs_sub).touch()
        if self._wraps is not None:
            result = self._wraps.offset_sub(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_sub", supplied_args, result[0])
        )
        self._on_error("offset_sub", supplied_args, result[0])
        return result

    def radcal_MLI(
        self,
        MLI,
        MLI_PAR: str,
        OFF_par: str,
        CMLI: str,
        antenna: str = None,
        rloss_flag=None,
        ant_flag=None,
        refarea_flag=None,
        sc_dB=None,
        K_dB=None,
        pix_area: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["radcal_MLI"] += 1

        if MLI_PAR is not None:
            result = self._validate(
                "radcal_MLI",
                MLI_PAR == "-" or Path(MLI_PAR).exists(),
                result,
                f"MLI_PAR path does not exist ({MLI_PAR})",
            )
        if OFF_par is not None:
            result = self._validate(
                "radcal_MLI",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if CMLI is not None and CMLI != "-":
            Path(CMLI).touch()
        if antenna is not None:
            result = self._validate(
                "radcal_MLI",
                antenna == "-" or Path(antenna).exists(),
                result,
                f"antenna path does not exist ({antenna})",
            )
        if pix_area is not None and pix_area != "-":
            Path(pix_area).touch()
        if self._wraps is not None:
            result = self._wraps.radcal_MLI(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "radcal_MLI", supplied_args, result[0])
        )
        self._on_error("radcal_MLI", supplied_args, result[0])
        return result

    def S1_OPOD_vec(self, SLC_PAR: str, OPOD: str, nstate=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["S1_OPOD_vec"] += 1

        if SLC_PAR is not None and SLC_PAR != "-" and not Path(SLC_PAR).exists():
            Path(SLC_PAR).touch()
        if OPOD is not None:
            result = self._validate(
                "S1_OPOD_vec",
                OPOD == "-" or Path(OPOD).exists(),
                result,
                f"OPOD path does not exist ({OPOD})",
            )
        if self._wraps is not None:
            result = self._wraps.S1_OPOD_vec(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "S1_OPOD_vec", supplied_args, result[0])
        )
        self._on_error("S1_OPOD_vec", supplied_args, result[0])
        return result

    def par_RCM_GRD(
        self,
        RCM_dir: str,
        polarization,
        radcal,
        noise,
        MLI_par: str = None,
        MLI: str = None,
        GRD_par: str = None,
        GRD: str = None,
        rps=None,
        noise_pwr: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RCM_GRD"] += 1

        if RCM_dir is not None:
            result = self._validate(
                "par_RCM_GRD",
                RCM_dir == "-" or Path(RCM_dir).exists(),
                result,
                f"RCM_dir path does not exist ({RCM_dir})",
            )
        valid_values = [0, 1, 2, 3]
        result = self._validate(
            "par_RCM_GRD",
            radcal == "-" or radcal in valid_values,
            result,
            f"radcal is not a valid value (expects: {valid_values}, got: {radcal})",
        )
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if noise_pwr is not None and noise_pwr != "-":
            Path(noise_pwr).touch()
        if self._wraps is not None:
            result = self._wraps.par_RCM_GRD(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RCM_GRD", supplied_args, result[0])
        )
        self._on_error("par_RCM_GRD", supplied_args, result[0])
        return result

    def offset_pwr_tracking(
        self,
        SLC1: str,
        SLC2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        offs: str,
        ccp: str,
        rwin=None,
        azwin=None,
        offsets: str = None,
        n_ovr=None,
        thres=None,
        rstep=None,
        azstep=None,
        rstart=None,
        rstop=None,
        azstart=None,
        azstop=None,
        lanczos=None,
        bw_frac=None,
        deramp=None,
        int_filt=None,
        pflag=None,
        pltflg=None,
        ccs: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_pwr_tracking"] += 1

        if SLC1 is not None:
            result = self._validate(
                "offset_pwr_tracking",
                SLC1 == "-" or Path(SLC1).exists(),
                result,
                f"SLC1 path does not exist ({SLC1})",
            )
        if SLC2 is not None:
            result = self._validate(
                "offset_pwr_tracking",
                SLC2 == "-" or Path(SLC2).exists(),
                result,
                f"SLC2 path does not exist ({SLC2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "offset_pwr_tracking",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "offset_pwr_tracking",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_pwr_tracking",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_tracking",
            deramp == "-" or deramp in valid_values,
            result,
            f"deramp is not a valid value (expects: {valid_values}, got: {deramp})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_tracking",
            int_filt == "-" or int_filt in valid_values,
            result,
            f"int_filt is not a valid value (expects: {valid_values}, got: {int_filt})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr_tracking",
            pflag == "-" or pflag in valid_values,
            result,
            f"pflag is not a valid value (expects: {valid_values}, got: {pflag})",
        )
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "offset_pwr_tracking",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if ccs is not None and ccs != "-":
            Path(ccs).touch()
        if self._wraps is not None:
            result = self._wraps.offset_pwr_tracking(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_pwr_tracking", supplied_args, result[0])
        )
        self._on_error("offset_pwr_tracking", supplied_args, result[0])
        return result

    def SLC_phase_shift(
        self, SLC_1: str, SLC_par1: str, SLC_2: str, SLC_par2: str, ph_shift
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_phase_shift"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "SLC_phase_shift",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_par1 is not None:
            result = self._validate(
                "SLC_phase_shift",
                SLC_par1 == "-" or Path(SLC_par1).exists(),
                result,
                f"SLC_par1 path does not exist ({SLC_par1})",
            )
        if SLC_2 is not None and SLC_2 != "-":
            Path(SLC_2).touch()
        if SLC_par2 is not None and SLC_par2 != "-":
            Path(SLC_par2).touch()
        if self._wraps is not None:
            result = self._wraps.SLC_phase_shift(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_phase_shift", supplied_args, result[0])
        )
        self._on_error("SLC_phase_shift", supplied_args, result[0])
        return result

    def unw_model(
        self,
        interf: str,
        unw_model,
        unw: str,
        width,
        xinit=None,
        yinit=None,
        ref_ph=None,
        width_model=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["unw_model"] += 1

        if interf is not None:
            result = self._validate(
                "unw_model",
                interf == "-" or Path(interf).exists(),
                result,
                f"interf path does not exist ({interf})",
            )
        if unw is not None and unw != "-":
            Path(unw).touch()
        if self._wraps is not None:
            result = self._wraps.unw_model(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "unw_model", supplied_args, result[0])
        )
        self._on_error("unw_model", supplied_args, result[0])
        return result

    def par_TX_SLC(self, annotation_XML: str, COSAR, SLC_par: str, SLC: str, pol=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_TX_SLC"] += 1

        if annotation_XML is not None:
            result = self._validate(
                "par_TX_SLC",
                annotation_XML == "-" or Path(annotation_XML).exists(),
                result,
                f"annotation_XML path does not exist ({annotation_XML})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_TX_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_TX_SLC", supplied_args, result[0])
        )
        self._on_error("par_TX_SLC", supplied_args, result[0])
        return result

    def ScanSAR_burst_MLI(
        self,
        SLC_tab: str,
        MLI_tab: str,
        rlks,
        azlks,
        bflg=None,
        SLCR_tab: str = None,
        MLI_dir=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ScanSAR_burst_MLI"] += 1

        if SLC_tab is not None:
            result = self._validate(
                "ScanSAR_burst_MLI",
                SLC_tab == "-" or Path(SLC_tab).exists(),
                result,
                f"SLC_tab path does not exist ({SLC_tab})",
            )
        if MLI_tab is not None and MLI_tab != "-":
            Path(MLI_tab).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ScanSAR_burst_MLI",
            bflg == "-" or bflg in valid_values,
            result,
            f"bflg is not a valid value (expects: {valid_values}, got: {bflg})",
        )
        if SLCR_tab is not None:
            result = self._validate(
                "ScanSAR_burst_MLI",
                SLCR_tab == "-" or Path(SLCR_tab).exists(),
                result,
                f"SLCR_tab path does not exist ({SLCR_tab})",
            )
        if self._wraps is not None:
            result = self._wraps.ScanSAR_burst_MLI(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ScanSAR_burst_MLI", supplied_args, result[0])
        )
        self._on_error("ScanSAR_burst_MLI", supplied_args, result[0])
        return result

    def base_copy(
        self,
        SLC1_par: str,
        baseline_1: str,
        SLC2_par: str,
        baseline_2: str,
        time_rev=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["base_copy"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "base_copy",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if baseline_1 is not None:
            result = self._validate(
                "base_copy",
                baseline_1 == "-" or Path(baseline_1).exists(),
                result,
                f"baseline_1 path does not exist ({baseline_1})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "base_copy",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if baseline_2 is not None and baseline_2 != "-":
            Path(baseline_2).touch()
        if self._wraps is not None:
            result = self._wraps.base_copy(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "base_copy", supplied_args, result[0])
        )
        self._on_error("base_copy", supplied_args, result[0])
        return result

    def SLC_interp_map(
        self,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        SLC_2R: str,
        SLC2R_par: str,
        OFF_par2: str,
        coffs_sm,
        loff=None,
        nlines=None,
        mode=None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_interp_map"] += 1

        if SLC_2 is not None:
            result = self._validate(
                "SLC_interp_map",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_interp_map",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "SLC_interp_map",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "SLC_interp_map",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()
        if OFF_par2 is not None:
            result = self._validate(
                "SLC_interp_map",
                OFF_par2 == "-" or Path(OFF_par2).exists(),
                result,
                f"OFF_par2 path does not exist ({OFF_par2})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_interp_map",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_interp_map(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_interp_map", supplied_args, result[0])
        )
        self._on_error("SLC_interp_map", supplied_args, result[0])
        return result

    def base_perp(self, baseline: str, SLC1_par: str, OFF_par: str, time_rev=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["base_perp"] += 1

        if baseline is not None:
            result = self._validate(
                "base_perp",
                baseline == "-" or Path(baseline).exists(),
                result,
                f"baseline path does not exist ({baseline})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "base_perp",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "base_perp",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if self._wraps is not None:
            result = self._wraps.base_perp(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "base_perp", supplied_args, result[0])
        )
        self._on_error("base_perp", supplied_args, result[0])
        return result

    def SLC_adf(
        self,
        SLC: str,
        ref_SLC: str,
        ref_SLC_par: str,
        SLC_filt: str,
        mode=None,
        alpha=None,
        nfft_r=None,
        nfft_az=None,
        r_step=None,
        az_step=None,
        mwin_r=None,
        mwin_az=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_adf"] += 1

        if SLC is not None:
            result = self._validate(
                "SLC_adf",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if ref_SLC is not None:
            result = self._validate(
                "SLC_adf",
                ref_SLC == "-" or Path(ref_SLC).exists(),
                result,
                f"ref_SLC path does not exist ({ref_SLC})",
            )
        if ref_SLC_par is not None:
            result = self._validate(
                "SLC_adf",
                ref_SLC_par == "-" or Path(ref_SLC_par).exists(),
                result,
                f"ref_SLC_par path does not exist ({ref_SLC_par})",
            )
        if SLC_filt is not None and SLC_filt != "-":
            Path(SLC_filt).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "SLC_adf",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_adf(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "SLC_adf", supplied_args, result[0]))
        self._on_error("SLC_adf", supplied_args, result[0])
        return result

    def offset_SLC(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        offs: str,
        snr: str,
        rwin=None,
        azwin=None,
        offsets: str = None,
        n_ovr=None,
        nr=None,
        naz=None,
        thres=None,
        ISZ=None,
        pflag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_SLC"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "offset_SLC",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "offset_SLC",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "offset_SLC",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "offset_SLC",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_SLC",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if snr is not None and snr != "-":
            Path(snr).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if self._wraps is not None:
            result = self._wraps.offset_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_SLC", supplied_args, result[0])
        )
        self._on_error("offset_SLC", supplied_args, result[0])
        return result

    def adf(
        self,
        interf: str,
        sm: str,
        cc: str,
        width,
        alpha=None,
        nfft=None,
        cc_win=None,
        step=None,
        loff=None,
        nlines=None,
        wfrac=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["adf"] += 1

        if interf is not None:
            result = self._validate(
                "adf",
                interf == "-" or Path(interf).exists(),
                result,
                f"interf path does not exist ({interf})",
            )
        if sm is not None and sm != "-":
            Path(sm).touch()
        if cc is not None and cc != "-":
            Path(cc).touch()
        if self._wraps is not None:
            result = self._wraps.adf(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "adf", supplied_args, result[0]))
        self._on_error("adf", supplied_args, result[0])
        return result

    def PRC_vec(self, SLC_par: str, PRC: str, nstate=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["PRC_vec"] += 1

        if SLC_par is not None and SLC_par != "-" and not Path(SLC_par).exists():
            Path(SLC_par).touch()
        if PRC is not None:
            result = self._validate(
                "PRC_vec",
                PRC == "-" or Path(PRC).exists(),
                result,
                f"PRC path does not exist ({PRC})",
            )
        if self._wraps is not None:
            result = self._wraps.PRC_vec(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "PRC_vec", supplied_args, result[0]))
        self._on_error("PRC_vec", supplied_args, result[0])
        return result

    def adapt_filt(
        self,
        int: str,
        sm: str,
        width,
        low_SNR_thr=None,
        filt_width=None,
        xmin=None,
        xmax=None,
        ymin=None,
        ymax=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["adapt_filt"] += 1

        if int is not None:
            result = self._validate(
                "adapt_filt",
                int == "-" or Path(int).exists(),
                result,
                f"int path does not exist ({int})",
            )
        if sm is not None and sm != "-":
            Path(sm).touch()
        if self._wraps is not None:
            result = self._wraps.adapt_filt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "adapt_filt", supplied_args, result[0])
        )
        self._on_error("adapt_filt", supplied_args, result[0])
        return result

    def par_RSAT2_SG(
        self,
        product_XML: str,
        lut_XML: str,
        GeoTIFF: str,
        polarization,
        GRD_par: str,
        GRD: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RSAT2_SG"] += 1

        if product_XML is not None:
            result = self._validate(
                "par_RSAT2_SG",
                product_XML == "-" or Path(product_XML).exists(),
                result,
                f"product_XML path does not exist ({product_XML})",
            )
        if lut_XML is not None:
            result = self._validate(
                "par_RSAT2_SG",
                lut_XML == "-" or Path(lut_XML).exists(),
                result,
                f"lut_XML path does not exist ({lut_XML})",
            )
        if GeoTIFF is not None:
            result = self._validate(
                "par_RSAT2_SG",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if self._wraps is not None:
            result = self._wraps.par_RSAT2_SG(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RSAT2_SG", supplied_args, result[0])
        )
        self._on_error("par_RSAT2_SG", supplied_args, result[0])
        return result

    def ScanSAR_burst_corners(self, SLC_par: str, TOPS_par: str, KML: str = None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ScanSAR_burst_corners"] += 1

        if SLC_par is not None:
            result = self._validate(
                "ScanSAR_burst_corners",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if TOPS_par is not None:
            result = self._validate(
                "ScanSAR_burst_corners",
                TOPS_par == "-" or Path(TOPS_par).exists(),
                result,
                f"TOPS_par path does not exist ({TOPS_par})",
            )
        if KML is not None and KML != "-":
            Path(KML).touch()
        if self._wraps is not None:
            result = self._wraps.ScanSAR_burst_corners(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ScanSAR_burst_corners", supplied_args, result[0])
        )
        self._on_error("ScanSAR_burst_corners", supplied_args, result[0])
        return result

    def par_RCM_SLC_ScanSAR(
        self,
        RCM_dir: str,
        polarization,
        radcal,
        noise_in,
        root_name: str,
        SLC_tab: str = None,
        beam=None,
        noise_out=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RCM_SLC_ScanSAR"] += 1

        if RCM_dir is not None:
            result = self._validate(
                "par_RCM_SLC_ScanSAR",
                RCM_dir == "-" or Path(RCM_dir).exists(),
                result,
                f"RCM_dir path does not exist ({RCM_dir})",
            )
        valid_values = [0, 1, 2, 3]
        result = self._validate(
            "par_RCM_SLC_ScanSAR",
            radcal == "-" or radcal in valid_values,
            result,
            f"radcal is not a valid value (expects: {valid_values}, got: {radcal})",
        )
        if root_name is not None and root_name != "-":
            Path(root_name).touch()
        if SLC_tab is not None and SLC_tab != "-":
            Path(SLC_tab).touch()
        if self._wraps is not None:
            result = self._wraps.par_RCM_SLC_ScanSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RCM_SLC_ScanSAR", supplied_args, result[0])
        )
        self._on_error("par_RCM_SLC_ScanSAR", supplied_args, result[0])
        return result

    def offset_add(self, OFF_par1: str, OFF_par2: str, OFF_par3: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_add"] += 1

        if OFF_par1 is not None:
            result = self._validate(
                "offset_add",
                OFF_par1 == "-" or Path(OFF_par1).exists(),
                result,
                f"OFF_par1 path does not exist ({OFF_par1})",
            )
        if OFF_par2 is not None:
            result = self._validate(
                "offset_add",
                OFF_par2 == "-" or Path(OFF_par2).exists(),
                result,
                f"OFF_par2 path does not exist ({OFF_par2})",
            )
        if OFF_par3 is not None and OFF_par3 != "-":
            Path(OFF_par3).touch()
        if self._wraps is not None:
            result = self._wraps.offset_add(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_add", supplied_args, result[0])
        )
        self._on_error("offset_add", supplied_args, result[0])
        return result

    def multi_SLC_WSS(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_SLC_WSS"] += 1

        if SLC is not None:
            result = self._validate(
                "multi_SLC_WSS",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if SLC_par is not None:
            result = self._validate(
                "multi_SLC_WSS",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if self._wraps is not None:
            result = self._wraps.multi_SLC_WSS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "multi_SLC_WSS", supplied_args, result[0])
        )
        self._on_error("multi_SLC_WSS", supplied_args, result[0])
        return result

    def SLC_cat_ScanSAR(self, SLC_tab1: str, SLC_tab2: str, SLC_tab3: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_cat_ScanSAR"] += 1

        if SLC_tab1 is not None:
            result = self._validate(
                "SLC_cat_ScanSAR",
                SLC_tab1 == "-" or Path(SLC_tab1).exists(),
                result,
                f"SLC_tab1 path does not exist ({SLC_tab1})",
            )
        if SLC_tab2 is not None:
            result = self._validate(
                "SLC_cat_ScanSAR",
                SLC_tab2 == "-" or Path(SLC_tab2).exists(),
                result,
                f"SLC_tab2 path does not exist ({SLC_tab2})",
            )
        if SLC_tab3 is not None:
            result = self._validate(
                "SLC_cat_ScanSAR",
                SLC_tab3 == "-" or Path(SLC_tab3).exists(),
                result,
                f"SLC_tab3 path does not exist ({SLC_tab3})",
            )
        if self._wraps is not None:
            result = self._wraps.SLC_cat_ScanSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_cat_ScanSAR", supplied_args, result[0])
        )
        self._on_error("SLC_cat_ScanSAR", supplied_args, result[0])
        return result

    def par_RSAT_SLC(
        self,
        CEOS_leader: str,
        SLC_par: str,
        CEOS_data: str,
        SLC: str = None,
        sc_dB=None,
        dt=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RSAT_SLC"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_RSAT_SLC",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if CEOS_data is not None:
            result = self._validate(
                "par_RSAT_SLC",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_RSAT_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RSAT_SLC", supplied_args, result[0])
        )
        self._on_error("par_RSAT_SLC", supplied_args, result[0])
        return result

    def base_est_fft(
        self,
        interf: str,
        SLC1_par: str,
        OFF_par: str,
        baseline: str,
        nazfft=None,
        r_samp=None,
        az_line=None,
        nrfft=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["base_est_fft"] += 1

        if interf is not None:
            result = self._validate(
                "base_est_fft",
                interf == "-" or Path(interf).exists(),
                result,
                f"interf path does not exist ({interf})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "base_est_fft",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "base_est_fft",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if baseline is not None and baseline != "-":
            Path(baseline).touch()
        if self._wraps is not None:
            result = self._wraps.base_est_fft(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "base_est_fft", supplied_args, result[0])
        )
        self._on_error("base_est_fft", supplied_args, result[0])
        return result

    def par_RCM_GRC(
        self,
        RCM_dir: str,
        polarization,
        radcal,
        noise,
        SLC_par: str = None,
        SLC: str = None,
        GRC_par: str = None,
        GRC: str = None,
        rps=None,
        noise_pwr: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RCM_GRC"] += 1

        if RCM_dir is not None:
            result = self._validate(
                "par_RCM_GRC",
                RCM_dir == "-" or Path(RCM_dir).exists(),
                result,
                f"RCM_dir path does not exist ({RCM_dir})",
            )
        valid_values = [0, 1, 2, 3]
        result = self._validate(
            "par_RCM_GRC",
            radcal == "-" or radcal in valid_values,
            result,
            f"radcal is not a valid value (expects: {valid_values}, got: {radcal})",
        )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if GRC_par is not None and GRC_par != "-":
            Path(GRC_par).touch()
        if GRC is not None and GRC != "-":
            Path(GRC).touch()
        if noise_pwr is not None and noise_pwr != "-":
            Path(noise_pwr).touch()
        if self._wraps is not None:
            result = self._wraps.par_RCM_GRC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RCM_GRC", supplied_args, result[0])
        )
        self._on_error("par_RCM_GRC", supplied_args, result[0])
        return result

    def base_orbit(self, SLC1_par: str, SLC2_par: str, baseline: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["base_orbit"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "base_orbit",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "base_orbit",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if baseline is not None and baseline != "-":
            Path(baseline).touch()
        if self._wraps is not None:
            result = self._wraps.base_orbit(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "base_orbit", supplied_args, result[0])
        )
        self._on_error("base_orbit", supplied_args, result[0])
        return result

    def par_KS_DGM(self, HDF5: str, trunk: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_KS_DGM"] += 1

        if HDF5 is not None:
            result = self._validate(
                "par_KS_DGM",
                HDF5 == "-" or Path(HDF5).exists(),
                result,
                f"HDF5 path does not exist ({HDF5})",
            )
        if trunk is not None and trunk != "-":
            Path(trunk).touch()
        if self._wraps is not None:
            result = self._wraps.par_KS_DGM(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_KS_DGM", supplied_args, result[0])
        )
        self._on_error("par_KS_DGM", supplied_args, result[0])
        return result

    def par_RSI_ERS(self, CEOS_SAR_leader, SLC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RSI_ERS"] += 1

        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_RSI_ERS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RSI_ERS", supplied_args, result[0])
        )
        self._on_error("par_RSI_ERS", supplied_args, result[0])
        return result

    def af_SLC(
        self,
        SLC_par: str,
        SLC: str,
        rwin=None,
        azwin=None,
        dr=None,
        daz=None,
        thres=None,
        a1_flg=None,
        b0_flg=None,
        offsets: str = None,
        n_ovr=None,
        roff=None,
        azoff=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["af_SLC"] += 1

        if SLC_par is not None:
            result = self._validate(
                "af_SLC",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if SLC is not None:
            result = self._validate(
                "af_SLC",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "af_SLC",
            a1_flg == "-" or a1_flg in valid_values,
            result,
            f"a1_flg is not a valid value (expects: {valid_values}, got: {a1_flg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "af_SLC",
            b0_flg == "-" or b0_flg in valid_values,
            result,
            f"b0_flg is not a valid value (expects: {valid_values}, got: {b0_flg})",
        )
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if self._wraps is not None:
            result = self._wraps.af_SLC(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "af_SLC", supplied_args, result[0]))
        self._on_error("af_SLC", supplied_args, result[0])
        return result

    def par_EORC_JERS_SLC(
        self, CEOS_SAR_leader: str, SLC_par: str, CEOS_data: str = None, slc: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_EORC_JERS_SLC"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "par_EORC_JERS_SLC",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if CEOS_data is not None:
            result = self._validate(
                "par_EORC_JERS_SLC",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if slc is not None and slc != "-":
            Path(slc).touch()
        if self._wraps is not None:
            result = self._wraps.par_EORC_JERS_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_EORC_JERS_SLC", supplied_args, result[0])
        )
        self._on_error("par_EORC_JERS_SLC", supplied_args, result[0])
        return result

    def fill_gaps(
        self,
        data_in: str,
        width,
        data_out: str,
        dtype=None,
        method=None,
        max_dist=None,
        bp_flag=None,
        win=None,
        ds_method=None,
        ds_size=None,
        ds_data: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["fill_gaps"] += 1

        if data_in is not None:
            result = self._validate(
                "fill_gaps",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "fill_gaps",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if ds_data is not None and ds_data != "-":
            Path(ds_data).touch()
        if self._wraps is not None:
            result = self._wraps.fill_gaps(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "fill_gaps", supplied_args, result[0])
        )
        self._on_error("fill_gaps", supplied_args, result[0])
        return result

    def rascc_mask_thinning(
        self,
        ras_in: str,
        in_file,
        width,
        ras_out: str,
        nmax=None,
        thresh_1=None,
        thresh_nmax=None,
        *args,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rascc_mask_thinning"] += 1

        if ras_in is not None:
            result = self._validate(
                "rascc_mask_thinning",
                ras_in == "-" or Path(ras_in).exists(),
                result,
                f"ras_in path does not exist ({ras_in})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        if self._wraps is not None:
            result = self._wraps.rascc_mask_thinning(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "rascc_mask_thinning", supplied_args, result[0])
        )
        self._on_error("rascc_mask_thinning", supplied_args, result[0])
        return result

    def GRD_to_SR(
        self,
        GRD_par: str,
        SLC_par: str,
        OFF_par: str,
        in_file,
        out_file: str,
        rlks=None,
        azlks=None,
        interp_mode=None,
        sr_rsp=None,
        sr_azsp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["GRD_to_SR"] += 1

        if GRD_par is not None:
            result = self._validate(
                "GRD_to_SR",
                GRD_par == "-" or Path(GRD_par).exists(),
                result,
                f"GRD_par path does not exist ({GRD_par})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if OFF_par is not None:
            result = self._validate(
                "GRD_to_SR",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if out_file is not None and out_file != "-":
            Path(out_file).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "GRD_to_SR",
            interp_mode == "-" or interp_mode in valid_values,
            result,
            f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})",
        )
        if self._wraps is not None:
            result = self._wraps.GRD_to_SR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "GRD_to_SR", supplied_args, result[0])
        )
        self._on_error("GRD_to_SR", supplied_args, result[0])
        return result

    def multi_look2(
        self,
        SLC: str,
        SLC_par: str,
        MLI: str,
        MLI_par: str,
        r_dec,
        az_dec,
        rwin=None,
        azwin=None,
        wflg=None,
        lanczos=None,
        beta=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_look2"] += 1

        if SLC is not None:
            result = self._validate(
                "multi_look2",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if SLC_par is not None:
            result = self._validate(
                "multi_look2",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "multi_look2",
            wflg == "-" or wflg in valid_values,
            result,
            f"wflg is not a valid value (expects: {valid_values}, got: {wflg})",
        )
        if self._wraps is not None:
            result = self._wraps.multi_look2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "multi_look2", supplied_args, result[0])
        )
        self._on_error("multi_look2", supplied_args, result[0])
        return result

    def dcomp_sirc(self, infile: str, outfile: str, samples, loff=None, nlines=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dcomp_sirc"] += 1

        if infile is not None:
            result = self._validate(
                "dcomp_sirc",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        if self._wraps is not None:
            result = self._wraps.dcomp_sirc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "dcomp_sirc", supplied_args, result[0])
        )
        self._on_error("dcomp_sirc", supplied_args, result[0])
        return result

    def subtract_phase(
        self, interf_in: str, phase_file, interf_out: str, width, factor=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["subtract_phase"] += 1

        if interf_in is not None:
            result = self._validate(
                "subtract_phase",
                interf_in == "-" or Path(interf_in).exists(),
                result,
                f"interf_in path does not exist ({interf_in})",
            )
        if interf_out is not None and interf_out != "-":
            Path(interf_out).touch()
        if self._wraps is not None:
            result = self._wraps.subtract_phase(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "subtract_phase", supplied_args, result[0])
        )
        self._on_error("subtract_phase", supplied_args, result[0])
        return result

    def dcomp_sirc_quad(
        self, infile: str, outfile: str, samples, parameter, loff=None, nlines=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["dcomp_sirc_quad"] += 1

        if infile is not None:
            result = self._validate(
                "dcomp_sirc_quad",
                infile == "-" or Path(infile).exists(),
                result,
                f"infile path does not exist ({infile})",
            )
        if outfile is not None and outfile != "-":
            Path(outfile).touch()
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        result = self._validate(
            "dcomp_sirc_quad",
            parameter == "-" or parameter in valid_values,
            result,
            f"parameter is not a valid value (expects: {valid_values}, got: {parameter})",
        )
        if self._wraps is not None:
            result = self._wraps.dcomp_sirc_quad(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "dcomp_sirc_quad", supplied_args, result[0])
        )
        self._on_error("dcomp_sirc_quad", supplied_args, result[0])
        return result

    def SLC_copy_ScanSAR(
        self, SLC1_tab: str, SLC2_tab: str, BURST_tab: str, dtype=None, SLC2_dir=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_copy_ScanSAR"] += 1

        if SLC1_tab is not None:
            result = self._validate(
                "SLC_copy_ScanSAR",
                SLC1_tab == "-" or Path(SLC1_tab).exists(),
                result,
                f"SLC1_tab path does not exist ({SLC1_tab})",
            )
        if SLC2_tab is not None and SLC2_tab != "-" and not Path(SLC2_tab).exists():
            Path(SLC2_tab).touch()
        if BURST_tab is not None:
            result = self._validate(
                "SLC_copy_ScanSAR",
                BURST_tab == "-" or Path(BURST_tab).exists(),
                result,
                f"BURST_tab path does not exist ({BURST_tab})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_copy_ScanSAR",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_copy_ScanSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_copy_ScanSAR", supplied_args, result[0])
        )
        self._on_error("SLC_copy_ScanSAR", supplied_args, result[0])
        return result

    def par_RISAT_SLC(
        self,
        CEOS_leader: str,
        BAND_META,
        SLC_par: str,
        CEOS_image: str,
        SLC: str = None,
        line_dir=None,
        pix_dir=None,
        cal_flg=None,
        KdB=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RISAT_SLC"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_RISAT_SLC",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if CEOS_image is not None:
            result = self._validate(
                "par_RISAT_SLC",
                CEOS_image == "-" or Path(CEOS_image).exists(),
                result,
                f"CEOS_image path does not exist ({CEOS_image})",
            )
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "par_RISAT_SLC",
            cal_flg == "-" or cal_flg in valid_values,
            result,
            f"cal_flg is not a valid value (expects: {valid_values}, got: {cal_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.par_RISAT_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RISAT_SLC", supplied_args, result[0])
        )
        self._on_error("par_RISAT_SLC", supplied_args, result[0])
        return result

    def SLC_freq_shift(
        self, SLC: str, SLC_par: str, SLC_shift: str, SLC_shift_par: str, freq_shift
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_freq_shift"] += 1

        if SLC is not None:
            result = self._validate(
                "SLC_freq_shift",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if SLC_par is not None:
            result = self._validate(
                "SLC_freq_shift",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if SLC_shift is not None and SLC_shift != "-":
            Path(SLC_shift).touch()
        if SLC_shift_par is not None and SLC_shift_par != "-":
            Path(SLC_shift_par).touch()
        if self._wraps is not None:
            result = self._wraps.SLC_freq_shift(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_freq_shift", supplied_args, result[0])
        )
        self._on_error("SLC_freq_shift", supplied_args, result[0])
        return result

    def DELFT_vec2(self, SLC_par: str, DELFT_dir, nstate=None, interval=None, ODR=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["DELFT_vec2"] += 1

        if SLC_par is not None:
            result = self._validate(
                "DELFT_vec2",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if self._wraps is not None:
            result = self._wraps.DELFT_vec2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "DELFT_vec2", supplied_args, result[0])
        )
        self._on_error("DELFT_vec2", supplied_args, result[0])
        return result

    def SLC_intf(
        self,
        SLC_1: str,
        SLC_2R: str,
        SLC1_par: str,
        SLC2R_par: str,
        OFF_par: str,
        interf: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
        sps_flg=None,
        azf_flg=None,
        rp1_flg=None,
        rp2_flg=None,
        SLC_1s=None,
        SLC_2Rs=None,
        SLC_1s_par=None,
        SLC_2Rs_par=None,
        az_beta=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_intf"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "SLC_intf",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2R is not None:
            result = self._validate(
                "SLC_intf",
                SLC_2R == "-" or Path(SLC_2R).exists(),
                result,
                f"SLC_2R path does not exist ({SLC_2R})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_intf",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2R_par is not None:
            result = self._validate(
                "SLC_intf",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "SLC_intf",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if interf is not None and interf != "-":
            Path(interf).touch()
        valid_values = [1, 0] + [None]
        result = self._validate(
            "SLC_intf",
            sps_flg == "-" or sps_flg in valid_values,
            result,
            f"sps_flg is not a valid value (expects: {valid_values}, got: {sps_flg})",
        )
        valid_values = [1, 0] + [None]
        result = self._validate(
            "SLC_intf",
            azf_flg == "-" or azf_flg in valid_values,
            result,
            f"azf_flg is not a valid value (expects: {valid_values}, got: {azf_flg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_intf",
            rp1_flg == "-" or rp1_flg in valid_values,
            result,
            f"rp1_flg is not a valid value (expects: {valid_values}, got: {rp1_flg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_intf",
            rp2_flg == "-" or rp2_flg in valid_values,
            result,
            f"rp2_flg is not a valid value (expects: {valid_values}, got: {rp2_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_intf(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_intf", supplied_args, result[0])
        )
        self._on_error("SLC_intf", supplied_args, result[0])
        return result

    def ptarg_cal_SLC(
        self,
        SLC_par: str,
        SLC: str,
        r_samp,
        az_samp,
        psigma,
        c_r_samp,
        c_az_samp,
        ptr_image: str,
        r_plot: str,
        az_plot: str,
        pcal: str,
        osf=None,
        win=None,
        pltflg=None,
        psz=None,
        csz=None,
        c_image: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ptarg_cal_SLC"] += 1

        if SLC_par is not None:
            result = self._validate(
                "ptarg_cal_SLC",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if SLC is not None:
            result = self._validate(
                "ptarg_cal_SLC",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if ptr_image is not None and ptr_image != "-":
            Path(ptr_image).touch()
        if r_plot is not None and r_plot != "-":
            Path(r_plot).touch()
        if az_plot is not None and az_plot != "-":
            Path(az_plot).touch()
        if pcal is not None and pcal != "-":
            Path(pcal).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "ptarg_cal_SLC",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if c_image is not None and c_image != "-":
            Path(c_image).touch()
        if self._wraps is not None:
            result = self._wraps.ptarg_cal_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ptarg_cal_SLC", supplied_args, result[0])
        )
        self._on_error("ptarg_cal_SLC", supplied_args, result[0])
        return result

    def sbi_filt(
        self,
        SLC_1: str,
        SLC1_par: str,
        SLC2R_par: str,
        SLCf: str,
        SLCf_par: str,
        SLCb: str,
        SLCb_par: str,
        norm_sq,
        iwflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["sbi_filt"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "sbi_filt",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "sbi_filt",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2R_par is not None:
            result = self._validate(
                "sbi_filt",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        if SLCf is not None and SLCf != "-":
            Path(SLCf).touch()
        if SLCf_par is not None and SLCf_par != "-":
            Path(SLCf_par).touch()
        if SLCb is not None and SLCb != "-":
            Path(SLCb).touch()
        if SLCb_par is not None and SLCb_par != "-":
            Path(SLCb_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "sbi_filt",
            iwflg == "-" or iwflg in valid_values,
            result,
            f"iwflg is not a valid value (expects: {valid_values}, got: {iwflg})",
        )
        if self._wraps is not None:
            result = self._wraps.sbi_filt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "sbi_filt", supplied_args, result[0])
        )
        self._on_error("sbi_filt", supplied_args, result[0])
        return result

    def ph_slope_base(
        self,
        int_in: str,
        SLC_par: str,
        OFF_par: str,
        base: str,
        int_out: str,
        int_type=None,
        inverse=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ph_slope_base"] += 1

        if int_in is not None:
            result = self._validate(
                "ph_slope_base",
                int_in == "-" or Path(int_in).exists(),
                result,
                f"int_in path does not exist ({int_in})",
            )
        if SLC_par is not None:
            result = self._validate(
                "ph_slope_base",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "ph_slope_base",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if base is not None:
            result = self._validate(
                "ph_slope_base",
                base == "-" or Path(base).exists(),
                result,
                f"base path does not exist ({base})",
            )
        if int_out is not None and int_out != "-":
            Path(int_out).touch()
        if self._wraps is not None:
            result = self._wraps.ph_slope_base(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ph_slope_base", supplied_args, result[0])
        )
        self._on_error("ph_slope_base", supplied_args, result[0])
        return result

    def multi_look_ScanSAR(
        self,
        SLC_tab: str,
        MLI: str,
        MLI_par: str,
        rlks,
        azlks,
        bflg=None,
        SLCR_tab: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_look_ScanSAR"] += 1

        if SLC_tab is not None:
            result = self._validate(
                "multi_look_ScanSAR",
                SLC_tab == "-" or Path(SLC_tab).exists(),
                result,
                f"SLC_tab path does not exist ({SLC_tab})",
            )
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "multi_look_ScanSAR",
            bflg == "-" or bflg in valid_values,
            result,
            f"bflg is not a valid value (expects: {valid_values}, got: {bflg})",
        )
        if SLCR_tab is not None:
            result = self._validate(
                "multi_look_ScanSAR",
                SLCR_tab == "-" or Path(SLCR_tab).exists(),
                result,
                f"SLCR_tab path does not exist ({SLCR_tab})",
            )
        if self._wraps is not None:
            result = self._wraps.multi_look_ScanSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "multi_look_ScanSAR", supplied_args, result[0])
        )
        self._on_error("multi_look_ScanSAR", supplied_args, result[0])
        return result

    def par_ASNARO2(
        self, CEOS_data: str, CEOS_leader: str, SLC_par: str, SLC: str = None, reramp=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ASNARO2"] += 1

        if CEOS_data is not None:
            result = self._validate(
                "par_ASNARO2",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if CEOS_leader is not None:
            result = self._validate(
                "par_ASNARO2",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "par_ASNARO2",
            reramp == "-" or reramp in valid_values,
            result,
            f"reramp is not a valid value (expects: {valid_values}, got: {reramp})",
        )
        if self._wraps is not None:
            result = self._wraps.par_ASNARO2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ASNARO2", supplied_args, result[0])
        )
        self._on_error("par_ASNARO2", supplied_args, result[0])
        return result

    def grasses(
        self,
        int: str,
        flag: str,
        unw: str,
        width,
        xmin=None,
        xmax=None,
        ymin=None,
        ymax=None,
        xinit=None,
        yinit=None,
        init_ph=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["grasses"] += 1

        if int is not None:
            result = self._validate(
                "grasses",
                int == "-" or Path(int).exists(),
                result,
                f"int path does not exist ({int})",
            )
        if flag is not None:
            result = self._validate(
                "grasses",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if unw is not None and unw != "-":
            Path(unw).touch()
        if self._wraps is not None:
            result = self._wraps.grasses(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "grasses", supplied_args, result[0]))
        self._on_error("grasses", supplied_args, result[0])
        return result

    def mask_data(self, data_in: str, width, data_out: str, mask: str, dtype=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["mask_data"] += 1

        if data_in is not None:
            result = self._validate(
                "mask_data",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if mask is not None:
            result = self._validate(
                "mask_data",
                mask == "-" or Path(mask).exists(),
                result,
                f"mask path does not exist ({mask})",
            )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "mask_data",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.mask_data(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "mask_data", supplied_args, result[0])
        )
        self._on_error("mask_data", supplied_args, result[0])
        return result

    def par_ESA_JERS_SEASAT_SLC(
        self, CEOS_data: str, CEOS_leader: str, SLC_par: str, SLC: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ESA_JERS_SEASAT_SLC"] += 1

        if CEOS_data is not None:
            result = self._validate(
                "par_ESA_JERS_SEASAT_SLC",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if CEOS_leader is not None:
            result = self._validate(
                "par_ESA_JERS_SEASAT_SLC",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_ESA_JERS_SEASAT_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ESA_JERS_SEASAT_SLC", supplied_args, result[0])
        )
        self._on_error("par_ESA_JERS_SEASAT_SLC", supplied_args, result[0])
        return result

    def ScanSAR_burst_overlap(
        self,
        SLC_tab: str,
        root_name: str,
        rlks,
        azlks,
        mode=None,
        bflg=None,
        SLCR_tab: str = None,
        dburst=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ScanSAR_burst_overlap"] += 1

        if SLC_tab is not None:
            result = self._validate(
                "ScanSAR_burst_overlap",
                SLC_tab == "-" or Path(SLC_tab).exists(),
                result,
                f"SLC_tab path does not exist ({SLC_tab})",
            )
        if root_name is not None and root_name != "-":
            Path(root_name).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "ScanSAR_burst_overlap",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ScanSAR_burst_overlap",
            bflg == "-" or bflg in valid_values,
            result,
            f"bflg is not a valid value (expects: {valid_values}, got: {bflg})",
        )
        if SLCR_tab is not None:
            result = self._validate(
                "ScanSAR_burst_overlap",
                SLCR_tab == "-" or Path(SLCR_tab).exists(),
                result,
                f"SLCR_tab path does not exist ({SLCR_tab})",
            )
        if self._wraps is not None:
            result = self._wraps.ScanSAR_burst_overlap(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ScanSAR_burst_overlap", supplied_args, result[0])
        )
        self._on_error("ScanSAR_burst_overlap", supplied_args, result[0])
        return result

    def ORB_prop_SLC(
        self, SLC_par: str, nstate=None, interval=None, extra=None, mode=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ORB_prop_SLC"] += 1

        if SLC_par is not None:
            result = self._validate(
                "ORB_prop_SLC",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if self._wraps is not None:
            result = self._wraps.ORB_prop_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ORB_prop_SLC", supplied_args, result[0])
        )
        self._on_error("ORB_prop_SLC", supplied_args, result[0])
        return result

    def interp_ad(
        self,
        data_in: str,
        data_out: str,
        width,
        r_max=None,
        np_min=None,
        np_max=None,
        w_mode=None,
        dtype=None,
        cp_data=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["interp_ad"] += 1

        if data_in is not None:
            result = self._validate(
                "interp_ad",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "interp_ad",
            w_mode == "-" or w_mode in valid_values,
            result,
            f"w_mode is not a valid value (expects: {valid_values}, got: {w_mode})",
        )
        valid_values = [0, 1, 2, 3, 4] + [None]
        result = self._validate(
            "interp_ad",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "interp_ad",
            cp_data == "-" or cp_data in valid_values,
            result,
            f"cp_data is not a valid value (expects: {valid_values}, got: {cp_data})",
        )
        if self._wraps is not None:
            result = self._wraps.interp_ad(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "interp_ad", supplied_args, result[0])
        )
        self._on_error("interp_ad", supplied_args, result[0])
        return result

    def par_RISAT_GRD(
        self,
        CEOS_leader: str,
        BAND_META,
        GRD_par: str,
        CEOS_image: str,
        GRD: str = None,
        line_dir=None,
        pix_dir=None,
        cal_flg=None,
        KdB=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RISAT_GRD"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_RISAT_GRD",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if CEOS_image is not None:
            result = self._validate(
                "par_RISAT_GRD",
                CEOS_image == "-" or Path(CEOS_image).exists(),
                result,
                f"CEOS_image path does not exist ({CEOS_image})",
            )
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "par_RISAT_GRD",
            cal_flg == "-" or cal_flg in valid_values,
            result,
            f"cal_flg is not a valid value (expects: {valid_values}, got: {cal_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.par_RISAT_GRD(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RISAT_GRD", supplied_args, result[0])
        )
        self._on_error("par_RISAT_GRD", supplied_args, result[0])
        return result

    def par_RSAT_SCW(
        self,
        CEOS_leader: str,
        CEOS_trailer: str,
        CEOS_data: str,
        GRD_par: str,
        GRD: str,
        sc_dB=None,
        dt=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RSAT_SCW"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_RSAT_SCW",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if CEOS_trailer is not None:
            result = self._validate(
                "par_RSAT_SCW",
                CEOS_trailer == "-" or Path(CEOS_trailer).exists(),
                result,
                f"CEOS_trailer path does not exist ({CEOS_trailer})",
            )
        if CEOS_data is not None:
            result = self._validate(
                "par_RSAT_SCW",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if self._wraps is not None:
            result = self._wraps.par_RSAT_SCW(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RSAT_SCW", supplied_args, result[0])
        )
        self._on_error("par_RSAT_SCW", supplied_args, result[0])
        return result

    def neutron(self, intensity: str, flag: str, width, n_thres, ymin=None, ymax=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["neutron"] += 1

        if intensity is not None:
            result = self._validate(
                "neutron",
                intensity == "-" or Path(intensity).exists(),
                result,
                f"intensity path does not exist ({intensity})",
            )
        if flag is not None:
            result = self._validate(
                "neutron",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if self._wraps is not None:
            result = self._wraps.neutron(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "neutron", supplied_args, result[0]))
        self._on_error("neutron", supplied_args, result[0])
        return result

    def SLC_mosaic_S1_TOPS(
        self,
        SLC_tab: str,
        SLC: str,
        SLC_par: str,
        rlks,
        azlks,
        bflg=None,
        SLCR_tab: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_mosaic_S1_TOPS"] += 1

        if SLC_tab is not None:
            result = self._validate(
                "SLC_mosaic_S1_TOPS",
                SLC_tab == "-" or Path(SLC_tab).exists(),
                result,
                f"SLC_tab path does not exist ({SLC_tab})",
            )
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_mosaic_S1_TOPS",
            bflg == "-" or bflg in valid_values,
            result,
            f"bflg is not a valid value (expects: {valid_values}, got: {bflg})",
        )
        if SLCR_tab is not None:
            result = self._validate(
                "SLC_mosaic_S1_TOPS",
                SLCR_tab == "-" or Path(SLCR_tab).exists(),
                result,
                f"SLCR_tab path does not exist ({SLCR_tab})",
            )
        if self._wraps is not None:
            result = self._wraps.SLC_mosaic_S1_TOPS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_mosaic_S1_TOPS", supplied_args, result[0])
        )
        self._on_error("SLC_mosaic_S1_TOPS", supplied_args, result[0])
        return result

    def multi_look(
        self,
        SLC: str,
        SLC_par: str,
        MLI: str,
        MLI_par: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
        scale=None,
        exp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_look"] += 1

        if SLC is not None:
            result = self._validate(
                "multi_look",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if SLC_par is not None:
            result = self._validate(
                "multi_look",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if self._wraps is not None:
            result = self._wraps.multi_look(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "multi_look", supplied_args, result[0])
        )
        self._on_error("multi_look", supplied_args, result[0])
        return result

    def mosaic_WB(
        self, data_tab: str, dtype: str, data_out: str, data_par_out: str, sc_flg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["mosaic_WB"] += 1

        if data_tab is not None:
            result = self._validate(
                "mosaic_WB",
                data_tab == "-" or Path(data_tab).exists(),
                result,
                f"data_tab path does not exist ({data_tab})",
            )
        if dtype is not None:
            result = self._validate(
                "mosaic_WB",
                dtype == "-" or Path(dtype).exists(),
                result,
                f"dtype path does not exist ({dtype})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if data_par_out is not None and data_par_out != "-":
            Path(data_par_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "mosaic_WB",
            sc_flg == "-" or sc_flg in valid_values,
            result,
            f"sc_flg is not a valid value (expects: {valid_values}, got: {sc_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.mosaic_WB(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "mosaic_WB", supplied_args, result[0])
        )
        self._on_error("mosaic_WB", supplied_args, result[0])
        return result

    def ScanSAR_burst_to_mosaic(
        self, DATA_tab: str, mosaic: str, MLI_par: str, mflg=None, dtype=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ScanSAR_burst_to_mosaic"] += 1

        if DATA_tab is not None:
            result = self._validate(
                "ScanSAR_burst_to_mosaic",
                DATA_tab == "-" or Path(DATA_tab).exists(),
                result,
                f"DATA_tab path does not exist ({DATA_tab})",
            )
        if mosaic is not None and mosaic != "-":
            Path(mosaic).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "ScanSAR_burst_to_mosaic",
            mflg == "-" or mflg in valid_values,
            result,
            f"mflg is not a valid value (expects: {valid_values}, got: {mflg})",
        )
        if self._wraps is not None:
            result = self._wraps.ScanSAR_burst_to_mosaic(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ScanSAR_burst_to_mosaic", supplied_args, result[0])
        )
        self._on_error("ScanSAR_burst_to_mosaic", supplied_args, result[0])
        return result

    def par_UAVSAR_SLC(
        self,
        ann: str,
        SLC_MLC_in: str = None,
        SLC_MLI_par: str = None,
        SLC_MLI_out: str = None,
        image_type=None,
        image_format=None,
        DOP: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_UAVSAR_SLC"] += 1

        if ann is not None:
            result = self._validate(
                "par_UAVSAR_SLC",
                ann == "-" or Path(ann).exists(),
                result,
                f"ann path does not exist ({ann})",
            )
        if SLC_MLC_in is not None:
            result = self._validate(
                "par_UAVSAR_SLC",
                SLC_MLC_in == "-" or Path(SLC_MLC_in).exists(),
                result,
                f"SLC_MLC_in path does not exist ({SLC_MLC_in})",
            )
        if SLC_MLI_par is not None and SLC_MLI_par != "-":
            Path(SLC_MLI_par).touch()
        if SLC_MLI_out is not None and SLC_MLI_out != "-":
            Path(SLC_MLI_out).touch()
        valid_values = [0, 2] + [None]
        result = self._validate(
            "par_UAVSAR_SLC",
            image_format == "-" or image_format in valid_values,
            result,
            f"image_format is not a valid value (expects: {valid_values}, got: {image_format})",
        )
        if DOP is not None:
            result = self._validate(
                "par_UAVSAR_SLC",
                DOP == "-" or Path(DOP).exists(),
                result,
                f"DOP path does not exist ({DOP})",
            )
        if self._wraps is not None:
            result = self._wraps.par_UAVSAR_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_UAVSAR_SLC", supplied_args, result[0])
        )
        self._on_error("par_UAVSAR_SLC", supplied_args, result[0])
        return result

    def ScanSAR_burst_copy(
        self,
        SLC,
        SLC_par: str,
        TOPS_par: str,
        SLC_out: str,
        SLC_out_par: str,
        burst_num,
        drflg=None,
        SLC_par2: str = None,
        dtype=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ScanSAR_burst_copy"] += 1

        if SLC_par is not None:
            result = self._validate(
                "ScanSAR_burst_copy",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if TOPS_par is not None:
            result = self._validate(
                "ScanSAR_burst_copy",
                TOPS_par == "-" or Path(TOPS_par).exists(),
                result,
                f"TOPS_par path does not exist ({TOPS_par})",
            )
        if SLC_out is not None and SLC_out != "-":
            Path(SLC_out).touch()
        if SLC_out_par is not None and SLC_out_par != "-":
            Path(SLC_out_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ScanSAR_burst_copy",
            drflg == "-" or drflg in valid_values,
            result,
            f"drflg is not a valid value (expects: {valid_values}, got: {drflg})",
        )
        if SLC_par2 is not None and SLC_par2 != "-":
            Path(SLC_par2).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ScanSAR_burst_copy",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.ScanSAR_burst_copy(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ScanSAR_burst_copy", supplied_args, result[0])
        )
        self._on_error("ScanSAR_burst_copy", supplied_args, result[0])
        return result

    def hgt_map(
        self,
        unw: str,
        SLC_par: str,
        OFF_par,
        baseline: str,
        hgt: str,
        gr: str,
        ph_flag=None,
        loff=None,
        nlines=None,
        SLC2R_par=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["hgt_map"] += 1

        if unw is not None:
            result = self._validate(
                "hgt_map",
                unw == "-" or Path(unw).exists(),
                result,
                f"unw path does not exist ({unw})",
            )
        if SLC_par is not None:
            result = self._validate(
                "hgt_map",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if baseline is not None:
            result = self._validate(
                "hgt_map",
                baseline == "-" or Path(baseline).exists(),
                result,
                f"baseline path does not exist ({baseline})",
            )
        if hgt is not None and hgt != "-":
            Path(hgt).touch()
        if gr is not None and gr != "-":
            Path(gr).touch()
        if self._wraps is not None:
            result = self._wraps.hgt_map(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "hgt_map", supplied_args, result[0]))
        self._on_error("hgt_map", supplied_args, result[0])
        return result

    def par_CS_SLC(self, HDF5: str, trunk: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_CS_SLC"] += 1

        if HDF5 is not None:
            result = self._validate(
                "par_CS_SLC",
                HDF5 == "-" or Path(HDF5).exists(),
                result,
                f"HDF5 path does not exist ({HDF5})",
            )
        if trunk is not None and trunk != "-":
            Path(trunk).touch()
        if self._wraps is not None:
            result = self._wraps.par_CS_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_CS_SLC", supplied_args, result[0])
        )
        self._on_error("par_CS_SLC", supplied_args, result[0])
        return result

    def par_TX_GRD(self, annotation_XML: str, COSAR, GRD_par, GRD: str, pol=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_TX_GRD"] += 1

        if annotation_XML is not None:
            result = self._validate(
                "par_TX_GRD",
                annotation_XML == "-" or Path(annotation_XML).exists(),
                result,
                f"annotation_XML path does not exist ({annotation_XML})",
            )
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if self._wraps is not None:
            result = self._wraps.par_TX_GRD(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_TX_GRD", supplied_args, result[0])
        )
        self._on_error("par_TX_GRD", supplied_args, result[0])
        return result

    def split_WB(self, data_in: str, data_par_in: str, data_tab: str, dtype: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["split_WB"] += 1

        if data_in is not None:
            result = self._validate(
                "split_WB",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_par_in is not None:
            result = self._validate(
                "split_WB",
                data_par_in == "-" or Path(data_par_in).exists(),
                result,
                f"data_par_in path does not exist ({data_par_in})",
            )
        if data_tab is not None:
            result = self._validate(
                "split_WB",
                data_tab == "-" or Path(data_tab).exists(),
                result,
                f"data_tab path does not exist ({data_tab})",
            )
        if dtype is not None:
            result = self._validate(
                "split_WB",
                dtype == "-" or Path(dtype).exists(),
                result,
                f"dtype path does not exist ({dtype})",
            )
        if self._wraps is not None:
            result = self._wraps.split_WB(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "split_WB", supplied_args, result[0])
        )
        self._on_error("split_WB", supplied_args, result[0])
        return result

    def base_init(
        self,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        interf: str,
        base,
        mflag=None,
        nrfft=None,
        nazfft=None,
        r_samp=None,
        az_line=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["base_init"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "base_init",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "base_init",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "base_init",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if interf is not None:
            result = self._validate(
                "base_init",
                interf == "-" or Path(interf).exists(),
                result,
                f"interf path does not exist ({interf})",
            )
        valid_values = [0, 1, 2, 3, 4] + [None]
        result = self._validate(
            "base_init",
            mflag == "-" or mflag in valid_values,
            result,
            f"mflag is not a valid value (expects: {valid_values}, got: {mflag})",
        )
        if self._wraps is not None:
            result = self._wraps.base_init(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "base_init", supplied_args, result[0])
        )
        self._on_error("base_init", supplied_args, result[0])
        return result

    def par_SIRC(self, CEOS_leader: str, SLC_par: str, UTC_MET=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_SIRC"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_SIRC",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_SIRC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_SIRC", supplied_args, result[0])
        )
        self._on_error("par_SIRC", supplied_args, result[0])
        return result

    def rascc_mask(
        self,
        cc,
        pwr,
        width,
        start_cc=None,
        start_pwr=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        cc_thres=None,
        pwr_thres=None,
        cc_min=None,
        cc_max=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["rascc_mask"] += 1

        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.rascc_mask(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "rascc_mask", supplied_args, result[0])
        )
        self._on_error("rascc_mask", supplied_args, result[0])
        return result

    def init_offset_orbit(
        self,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        rpos=None,
        azpos=None,
        cflag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["init_offset_orbit"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "init_offset_orbit",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "init_offset_orbit",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None and OFF_par != "-" and not Path(OFF_par).exists():
            Path(OFF_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "init_offset_orbit",
            cflag == "-" or cflag in valid_values,
            result,
            f"cflag is not a valid value (expects: {valid_values}, got: {cflag})",
        )
        if self._wraps is not None:
            result = self._wraps.init_offset_orbit(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "init_offset_orbit", supplied_args, result[0])
        )
        self._on_error("init_offset_orbit", supplied_args, result[0])
        return result

    def interf_SLC(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        MLI_1: str,
        MLI_2: str,
        interf,
        nrlk=None,
        nazlk=None,
        loff=None,
        nltot=None,
        rfilt=None,
        azfilt=None,
        s_off=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["interf_SLC"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "interf_SLC",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "interf_SLC",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "interf_SLC",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "interf_SLC",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "interf_SLC",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if MLI_1 is not None and MLI_1 != "-":
            Path(MLI_1).touch()
        if MLI_2 is not None and MLI_2 != "-":
            Path(MLI_2).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "interf_SLC",
            rfilt == "-" or rfilt in valid_values,
            result,
            f"rfilt is not a valid value (expects: {valid_values}, got: {rfilt})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "interf_SLC",
            azfilt == "-" or azfilt in valid_values,
            result,
            f"azfilt is not a valid value (expects: {valid_values}, got: {azfilt})",
        )
        if self._wraps is not None:
            result = self._wraps.interf_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "interf_SLC", supplied_args, result[0])
        )
        self._on_error("interf_SLC", supplied_args, result[0])
        return result

    def MLI_cat(
        self,
        MLI_1: str,
        MLI_2: str,
        MLI1_par: str,
        MLI2_par: str,
        MLI_3: str,
        MLI3_par: str,
        dtype=None,
        mflg=None,
        overlap=None,
        interp_mode=None,
        degree=None,
        extrapol=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["MLI_cat"] += 1

        if MLI_1 is not None:
            result = self._validate(
                "MLI_cat",
                MLI_1 == "-" or Path(MLI_1).exists(),
                result,
                f"MLI_1 path does not exist ({MLI_1})",
            )
        if MLI_2 is not None:
            result = self._validate(
                "MLI_cat",
                MLI_2 == "-" or Path(MLI_2).exists(),
                result,
                f"MLI_2 path does not exist ({MLI_2})",
            )
        if MLI1_par is not None:
            result = self._validate(
                "MLI_cat",
                MLI1_par == "-" or Path(MLI1_par).exists(),
                result,
                f"MLI1_par path does not exist ({MLI1_par})",
            )
        if MLI2_par is not None:
            result = self._validate(
                "MLI_cat",
                MLI2_par == "-" or Path(MLI2_par).exists(),
                result,
                f"MLI2_par path does not exist ({MLI2_par})",
            )
        if MLI_3 is not None and MLI_3 != "-":
            Path(MLI_3).touch()
        if MLI3_par is not None and MLI3_par != "-":
            Path(MLI3_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "MLI_cat",
            mflg == "-" or mflg in valid_values,
            result,
            f"mflg is not a valid value (expects: {valid_values}, got: {mflg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "MLI_cat",
            extrapol == "-" or extrapol in valid_values,
            result,
            f"extrapol is not a valid value (expects: {valid_values}, got: {extrapol})",
        )
        if self._wraps is not None:
            result = self._wraps.MLI_cat(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "MLI_cat", supplied_args, result[0]))
        self._on_error("MLI_cat", supplied_args, result[0])
        return result

    def par_RCM_SLC(
        self,
        RCM_dir: str,
        polarization,
        radcal,
        noise,
        SLC_par: str,
        SLC: str,
        noise_pwr: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RCM_SLC"] += 1

        if RCM_dir is not None:
            result = self._validate(
                "par_RCM_SLC",
                RCM_dir == "-" or Path(RCM_dir).exists(),
                result,
                f"RCM_dir path does not exist ({RCM_dir})",
            )
        valid_values = [0, 1, 2, 3]
        result = self._validate(
            "par_RCM_SLC",
            radcal == "-" or radcal in valid_values,
            result,
            f"radcal is not a valid value (expects: {valid_values}, got: {radcal})",
        )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if noise_pwr is not None and noise_pwr != "-":
            Path(noise_pwr).touch()
        if self._wraps is not None:
            result = self._wraps.par_RCM_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RCM_SLC", supplied_args, result[0])
        )
        self._on_error("par_RCM_SLC", supplied_args, result[0])
        return result

    def phase_slope(
        self,
        interf: str,
        slopes: str,
        width,
        win_sz=None,
        thres=None,
        xmin=None,
        xmax=None,
        ymin=None,
        ymax=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["phase_slope"] += 1

        if interf is not None:
            result = self._validate(
                "phase_slope",
                interf == "-" or Path(interf).exists(),
                result,
                f"interf path does not exist ({interf})",
            )
        if slopes is not None and slopes != "-":
            Path(slopes).touch()
        if self._wraps is not None:
            result = self._wraps.phase_slope(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "phase_slope", supplied_args, result[0])
        )
        self._on_error("phase_slope", supplied_args, result[0])
        return result

    def par_TX_ScanSAR(
        self, annot_XML: str, swath, SLC_par: str, SLC: str, TOPS_par: str, bwflg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_TX_ScanSAR"] += 1

        if annot_XML is not None:
            result = self._validate(
                "par_TX_ScanSAR",
                annot_XML == "-" or Path(annot_XML).exists(),
                result,
                f"annot_XML path does not exist ({annot_XML})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if TOPS_par is not None and TOPS_par != "-":
            Path(TOPS_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "par_TX_ScanSAR",
            bwflg == "-" or bwflg in valid_values,
            result,
            f"bwflg is not a valid value (expects: {valid_values}, got: {bwflg})",
        )
        if self._wraps is not None:
            result = self._wraps.par_TX_ScanSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_TX_ScanSAR", supplied_args, result[0])
        )
        self._on_error("par_TX_ScanSAR", supplied_args, result[0])
        return result

    def ave_image(
        self,
        im_list,
        width,
        ave: str,
        start=None,
        nlines=None,
        pixav_x=None,
        pixav_y=None,
        zflag=None,
        nmin=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ave_image"] += 1

        if ave is not None and ave != "-":
            Path(ave).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ave_image",
            zflag == "-" or zflag in valid_values,
            result,
            f"zflag is not a valid value (expects: {valid_values}, got: {zflag})",
        )
        if self._wraps is not None:
            result = self._wraps.ave_image(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ave_image", supplied_args, result[0])
        )
        self._on_error("ave_image", supplied_args, result[0])
        return result

    def multi_cpx(
        self,
        data_in: str,
        OFF_par_in: str,
        data_out: str,
        OFF_par_out: str,
        rlks=None,
        azlks=None,
        loff=None,
        nlines=None,
        roff=None,
        nsamp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_cpx"] += 1

        if data_in is not None:
            result = self._validate(
                "multi_cpx",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if OFF_par_in is not None:
            result = self._validate(
                "multi_cpx",
                OFF_par_in == "-" or Path(OFF_par_in).exists(),
                result,
                f"OFF_par_in path does not exist ({OFF_par_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if (
            OFF_par_out is not None
            and OFF_par_out != "-"
            and not Path(OFF_par_out).exists()
        ):
            Path(OFF_par_out).touch()
        if self._wraps is not None:
            result = self._wraps.multi_cpx(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "multi_cpx", supplied_args, result[0])
        )
        self._on_error("multi_cpx", supplied_args, result[0])
        return result

    def ASAR_LO_phase_drift(
        self, SLC1_par: str, SLC2_par: str, OFF_par: str, ph_drift: str
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ASAR_LO_phase_drift"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "ASAR_LO_phase_drift",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "ASAR_LO_phase_drift",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "ASAR_LO_phase_drift",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if ph_drift is not None and ph_drift != "-":
            Path(ph_drift).touch()
        if self._wraps is not None:
            result = self._wraps.ASAR_LO_phase_drift(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ASAR_LO_phase_drift", supplied_args, result[0])
        )
        self._on_error("ASAR_LO_phase_drift", supplied_args, result[0])
        return result

    def radcal_pwr_stat(
        self,
        SLC_tab: str,
        SLC_tab_cal: str,
        plist: str,
        MSR_cal,
        PWR_cal,
        roff=None,
        loff=None,
        nr=None,
        nl=None,
        plist_out=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["radcal_pwr_stat"] += 1

        if SLC_tab is not None:
            result = self._validate(
                "radcal_pwr_stat",
                SLC_tab == "-" or Path(SLC_tab).exists(),
                result,
                f"SLC_tab path does not exist ({SLC_tab})",
            )
        if SLC_tab_cal is not None:
            result = self._validate(
                "radcal_pwr_stat",
                SLC_tab_cal == "-" or Path(SLC_tab_cal).exists(),
                result,
                f"SLC_tab_cal path does not exist ({SLC_tab_cal})",
            )
        if plist is not None:
            result = self._validate(
                "radcal_pwr_stat",
                plist == "-" or Path(plist).exists(),
                result,
                f"plist path does not exist ({plist})",
            )
        if self._wraps is not None:
            result = self._wraps.radcal_pwr_stat(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "radcal_pwr_stat", supplied_args, result[0])
        )
        self._on_error("radcal_pwr_stat", supplied_args, result[0])
        return result

    def par_ICEYE_SLC(self, HDF5: str, SLC_par: str, slc: str = None, dtype=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ICEYE_SLC"] += 1

        if HDF5 is not None:
            result = self._validate(
                "par_ICEYE_SLC",
                HDF5 == "-" or Path(HDF5).exists(),
                result,
                f"HDF5 path does not exist ({HDF5})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if slc is not None and slc != "-":
            Path(slc).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "par_ICEYE_SLC",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.par_ICEYE_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ICEYE_SLC", supplied_args, result[0])
        )
        self._on_error("par_ICEYE_SLC", supplied_args, result[0])
        return result

    def offset_SLC_tracking(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        offs: str,
        snr: str,
        rsw=None,
        azsw=None,
        offsets: str = None,
        n_ovr=None,
        thres=None,
        rstep=None,
        azstep=None,
        rstart=None,
        rstop=None,
        azstart=None,
        azstop=None,
        ISZ=None,
        pflag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_SLC_tracking"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "offset_SLC_tracking",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "offset_SLC_tracking",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "offset_SLC_tracking",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "offset_SLC_tracking",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_SLC_tracking",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if snr is not None and snr != "-":
            Path(snr).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_SLC_tracking",
            pflag == "-" or pflag in valid_values,
            result,
            f"pflag is not a valid value (expects: {valid_values}, got: {pflag})",
        )
        if self._wraps is not None:
            result = self._wraps.offset_SLC_tracking(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_SLC_tracking", supplied_args, result[0])
        )
        self._on_error("offset_SLC_tracking", supplied_args, result[0])
        return result

    def tree_cc(
        self, flag: str, width, mbl=None, xmin=None, xmax=None, ymin=None, ymax=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["tree_cc"] += 1

        if flag is not None:
            result = self._validate(
                "tree_cc",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if self._wraps is not None:
            result = self._wraps.tree_cc(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "tree_cc", supplied_args, result[0]))
        self._on_error("tree_cc", supplied_args, result[0])
        return result

    def MLI_copy(
        self,
        MLI_in,
        MLI_in_par: str,
        MLI_out: str,
        MLI_out_par: str,
        roff=None,
        nr=None,
        loff=None,
        nl=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["MLI_copy"] += 1

        if MLI_in_par is not None:
            result = self._validate(
                "MLI_copy",
                MLI_in_par == "-" or Path(MLI_in_par).exists(),
                result,
                f"MLI_in_par path does not exist ({MLI_in_par})",
            )
        if MLI_out is not None and MLI_out != "-":
            Path(MLI_out).touch()
        if MLI_out_par is not None and MLI_out_par != "-":
            Path(MLI_out_par).touch()
        if self._wraps is not None:
            result = self._wraps.MLI_copy(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "MLI_copy", supplied_args, result[0])
        )
        self._on_error("MLI_copy", supplied_args, result[0])
        return result

    def ORRM_vec(self, SLC_par: str, ORRM: str, nstate=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ORRM_vec"] += 1

        if SLC_par is not None and SLC_par != "-" and not Path(SLC_par).exists():
            Path(SLC_par).touch()
        if ORRM is not None:
            result = self._validate(
                "ORRM_vec",
                ORRM == "-" or Path(ORRM).exists(),
                result,
                f"ORRM path does not exist ({ORRM})",
            )
        if self._wraps is not None:
            result = self._wraps.ORRM_vec(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ORRM_vec", supplied_args, result[0])
        )
        self._on_error("ORRM_vec", supplied_args, result[0])
        return result

    def SLC_ovr(
        self,
        SLC: str,
        SLC_par: str,
        SLC_ovr: str,
        SLC_ovr_par: str,
        r_ovr=None,
        az_ovr=None,
        mode=None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_ovr"] += 1

        if SLC is not None:
            result = self._validate(
                "SLC_ovr",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if SLC_par is not None:
            result = self._validate(
                "SLC_ovr",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if SLC_ovr is not None and SLC_ovr != "-":
            Path(SLC_ovr).touch()
        if SLC_ovr_par is not None and SLC_ovr_par != "-":
            Path(SLC_ovr_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_ovr",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_ovr(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "SLC_ovr", supplied_args, result[0]))
        self._on_error("SLC_ovr", supplied_args, result[0])
        return result

    def tree_gzw(
        self, flag: str, width, mbl=None, xmin=None, xmax=None, ymin=None, ymax=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["tree_gzw"] += 1

        if flag is not None:
            result = self._validate(
                "tree_gzw",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if self._wraps is not None:
            result = self._wraps.tree_gzw(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "tree_gzw", supplied_args, result[0])
        )
        self._on_error("tree_gzw", supplied_args, result[0])
        return result

    def mcf(
        self,
        interf: str,
        wgt,
        mask: str,
        unw: str,
        width,
        tri_mode=None,
        roff=None,
        loff=None,
        nr=None,
        nlines=None,
        npat_r=None,
        npat_az=None,
        ovrlap=None,
        r_init=None,
        az_init=None,
        init_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["mcf"] += 1

        if interf is not None:
            result = self._validate(
                "mcf",
                interf == "-" or Path(interf).exists(),
                result,
                f"interf path does not exist ({interf})",
            )
        if mask is not None:
            result = self._validate(
                "mcf",
                mask == "-" or Path(mask).exists(),
                result,
                f"mask path does not exist ({mask})",
            )
        if unw is not None and unw != "-":
            Path(unw).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "mcf",
            tri_mode == "-" or tri_mode in valid_values,
            result,
            f"tri_mode is not a valid value (expects: {valid_values}, got: {tri_mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "mcf",
            init_flag == "-" or init_flag in valid_values,
            result,
            f"init_flag is not a valid value (expects: {valid_values}, got: {init_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.mcf(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "mcf", supplied_args, result[0]))
        self._on_error("mcf", supplied_args, result[0])
        return result

    def par_ESA_ERS(
        self, CEOS_SAR_leader: str, SLC_par: str, CEOS_DAT: str = None, SLC: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ESA_ERS"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "par_ESA_ERS",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if CEOS_DAT is not None:
            result = self._validate(
                "par_ESA_ERS",
                CEOS_DAT == "-" or Path(CEOS_DAT).exists(),
                result,
                f"CEOS_DAT path does not exist ({CEOS_DAT})",
            )
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_ESA_ERS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ESA_ERS", supplied_args, result[0])
        )
        self._on_error("par_ESA_ERS", supplied_args, result[0])
        return result

    def SLC_interp(
        self,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        SLC_2R: str,
        SLC2R_par: str,
        loff=None,
        nlines=None,
        mode=None,
        order=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_interp"] += 1

        if SLC_2 is not None:
            result = self._validate(
                "SLC_interp",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_interp",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "SLC_interp",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "SLC_interp",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_interp",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_interp(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_interp", supplied_args, result[0])
        )
        self._on_error("SLC_interp", supplied_args, result[0])
        return result

    def par_S1_SLC(
        self,
        GeoTIFF: str,
        annotation_XML: str,
        calibration_XML: str,
        noise_XML: str,
        SLC_par: str,
        SLC: str,
        TOPS_par: str = None,
        dtype=None,
        sc_dB=None,
        noise_pwr=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_S1_SLC"] += 1

        if GeoTIFF is not None:
            result = self._validate(
                "par_S1_SLC",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if annotation_XML is not None:
            result = self._validate(
                "par_S1_SLC",
                annotation_XML == "-" or Path(annotation_XML).exists(),
                result,
                f"annotation_XML path does not exist ({annotation_XML})",
            )
        if calibration_XML is not None:
            result = self._validate(
                "par_S1_SLC",
                calibration_XML == "-" or Path(calibration_XML).exists(),
                result,
                f"calibration_XML path does not exist ({calibration_XML})",
            )
        if noise_XML is not None:
            result = self._validate(
                "par_S1_SLC",
                noise_XML == "-" or Path(noise_XML).exists(),
                result,
                f"noise_XML path does not exist ({noise_XML})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if TOPS_par is not None and TOPS_par != "-":
            Path(TOPS_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "par_S1_SLC",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.par_S1_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_S1_SLC", supplied_args, result[0])
        )
        self._on_error("par_S1_SLC", supplied_args, result[0])
        return result

    def par_ASAR(
        self, ASAR_ERS_file: str = None, output_name: str = None, K_dB=None, to=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ASAR"] += 1

        if ASAR_ERS_file is not None:
            result = self._validate(
                "par_ASAR",
                ASAR_ERS_file == "-" or Path(ASAR_ERS_file).exists(),
                result,
                f"ASAR_ERS_file path does not exist ({ASAR_ERS_file})",
            )
        if output_name is not None and output_name != "-":
            Path(output_name).touch()
        if self._wraps is not None:
            result = self._wraps.par_ASAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ASAR", supplied_args, result[0])
        )
        self._on_error("par_ASAR", supplied_args, result[0])
        return result

    def par_ASF_96(self, CEOS_SAR_leader: str, SLC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ASF_96"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "par_ASF_96",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_ASF_96(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ASF_96", supplied_args, result[0])
        )
        self._on_error("par_ASF_96", supplied_args, result[0])
        return result

    def ScanSAR_mosaic_to_burst(self, DATA: str, MLI_par, DATA_tab):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ScanSAR_mosaic_to_burst"] += 1

        if DATA is not None:
            result = self._validate(
                "ScanSAR_mosaic_to_burst",
                DATA == "-" or Path(DATA).exists(),
                result,
                f"DATA path does not exist ({DATA})",
            )
        if self._wraps is not None:
            result = self._wraps.ScanSAR_mosaic_to_burst(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ScanSAR_mosaic_to_burst", supplied_args, result[0])
        )
        self._on_error("ScanSAR_mosaic_to_burst", supplied_args, result[0])
        return result

    def base_ls(
        self,
        SLC_par: str,
        OFF_par: str,
        gcp_ph: str,
        baseline: str,
        ph_flag=None,
        bc_flag=None,
        bn_flag=None,
        bcdot_flag=None,
        bndot_flag=None,
        bperp_min=None,
        SLC2R_par: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["base_ls"] += 1

        if SLC_par is not None:
            result = self._validate(
                "base_ls",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "base_ls",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if gcp_ph is not None:
            result = self._validate(
                "base_ls",
                gcp_ph == "-" or Path(gcp_ph).exists(),
                result,
                f"gcp_ph path does not exist ({gcp_ph})",
            )
        if baseline is not None:
            result = self._validate(
                "base_ls",
                baseline == "-" or Path(baseline).exists(),
                result,
                f"baseline path does not exist ({baseline})",
            )
        if SLC2R_par is not None:
            result = self._validate(
                "base_ls",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        if self._wraps is not None:
            result = self._wraps.base_ls(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "base_ls", supplied_args, result[0]))
        self._on_error("base_ls", supplied_args, result[0])
        return result

    def az_spec_SLC(
        self, SLC: str, SLC_par: str, spectrum: str, roff=None, namb=None, pltflg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["az_spec_SLC"] += 1

        if SLC is not None:
            result = self._validate(
                "az_spec_SLC",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if SLC_par is not None:
            result = self._validate(
                "az_spec_SLC",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if spectrum is not None and spectrum != "-":
            Path(spectrum).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "az_spec_SLC",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.az_spec_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "az_spec_SLC", supplied_args, result[0])
        )
        self._on_error("az_spec_SLC", supplied_args, result[0])
        return result

    def SLC_copy(
        self,
        SLC_in: str,
        SLC_par_in: str,
        SLC_out: str,
        SLC_par_out: str,
        fcase=None,
        sc=None,
        roff=None,
        nr=None,
        loff=None,
        nl=None,
        swap=None,
        header_lines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_copy"] += 1

        if SLC_in is not None:
            result = self._validate(
                "SLC_copy",
                SLC_in == "-" or Path(SLC_in).exists(),
                result,
                f"SLC_in path does not exist ({SLC_in})",
            )
        if SLC_par_in is not None:
            result = self._validate(
                "SLC_copy",
                SLC_par_in == "-" or Path(SLC_par_in).exists(),
                result,
                f"SLC_par_in path does not exist ({SLC_par_in})",
            )
        if SLC_out is not None and SLC_out != "-":
            Path(SLC_out).touch()
        if SLC_par_out is not None and SLC_par_out != "-":
            Path(SLC_par_out).touch()
        valid_values = [1, 2, 3, 4] + [None]
        result = self._validate(
            "SLC_copy",
            fcase == "-" or fcase in valid_values,
            result,
            f"fcase is not a valid value (expects: {valid_values}, got: {fcase})",
        )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "SLC_copy",
            swap == "-" or swap in valid_values,
            result,
            f"swap is not a valid value (expects: {valid_values}, got: {swap})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_copy(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_copy", supplied_args, result[0])
        )
        self._on_error("SLC_copy", supplied_args, result[0])
        return result

    def az_integrate(self, data, width: str, azi: str, cflg, scale=None, lz=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["az_integrate"] += 1

        if width is not None:
            result = self._validate(
                "az_integrate",
                width == "-" or Path(width).exists(),
                result,
                f"width path does not exist ({width})",
            )
        if azi is not None and azi != "-":
            Path(azi).touch()
        valid_values = [0, 1]
        result = self._validate(
            "az_integrate",
            cflg == "-" or cflg in valid_values,
            result,
            f"cflg is not a valid value (expects: {valid_values}, got: {cflg})",
        )
        if self._wraps is not None:
            result = self._wraps.az_integrate(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "az_integrate", supplied_args, result[0])
        )
        self._on_error("az_integrate", supplied_args, result[0])
        return result

    def SLC_cat(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        SLC_3: str,
        SLC3_par: str,
        dopflg=None,
        iflg=None,
        phflg=None,
        gainflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_cat"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "SLC_cat",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "SLC_cat",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_cat",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "SLC_cat",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "SLC_cat",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if SLC_3 is not None and SLC_3 != "-":
            Path(SLC_3).touch()
        if SLC3_par is not None and SLC3_par != "-":
            Path(SLC3_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_cat",
            dopflg == "-" or dopflg in valid_values,
            result,
            f"dopflg is not a valid value (expects: {valid_values}, got: {dopflg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_cat",
            iflg == "-" or iflg in valid_values,
            result,
            f"iflg is not a valid value (expects: {valid_values}, got: {iflg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_cat",
            phflg == "-" or phflg in valid_values,
            result,
            f"phflg is not a valid value (expects: {valid_values}, got: {phflg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_cat",
            gainflg == "-" or gainflg in valid_values,
            result,
            f"gainflg is not a valid value (expects: {valid_values}, got: {gainflg})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_cat(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "SLC_cat", supplied_args, result[0]))
        self._on_error("SLC_cat", supplied_args, result[0])
        return result

    def par_NovaSAR_SLC(
        self,
        GeoTIFF: str,
        XML: str,
        polarization,
        SLC_par: str,
        SLC: str = None,
        dtype=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_NovaSAR_SLC"] += 1

        if GeoTIFF is not None:
            result = self._validate(
                "par_NovaSAR_SLC",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if XML is not None:
            result = self._validate(
                "par_NovaSAR_SLC",
                XML == "-" or Path(XML).exists(),
                result,
                f"XML path does not exist ({XML})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "par_NovaSAR_SLC",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        if self._wraps is not None:
            result = self._wraps.par_NovaSAR_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_NovaSAR_SLC", supplied_args, result[0])
        )
        self._on_error("par_NovaSAR_SLC", supplied_args, result[0])
        return result

    def SLC_corners(self, SLC_par: str, terra_alt=None, kml: str = None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_corners"] += 1

        if SLC_par is not None:
            result = self._validate(
                "SLC_corners",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if kml is not None and kml != "-":
            Path(kml).touch()
        if self._wraps is not None:
            result = self._wraps.SLC_corners(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_corners", supplied_args, result[0])
        )
        self._on_error("SLC_corners", supplied_args, result[0])
        return result

    def SLC_deramp(
        self,
        SLC_1: str,
        SLC_par1: str,
        SLC_2: str,
        SLC_par2: str,
        mode,
        dop_ph: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_deramp"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "SLC_deramp",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_par1 is not None:
            result = self._validate(
                "SLC_deramp",
                SLC_par1 == "-" or Path(SLC_par1).exists(),
                result,
                f"SLC_par1 path does not exist ({SLC_par1})",
            )
        if SLC_2 is not None and SLC_2 != "-":
            Path(SLC_2).touch()
        if SLC_par2 is not None and SLC_par2 != "-":
            Path(SLC_par2).touch()
        valid_values = [0, 1]
        result = self._validate(
            "SLC_deramp",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if dop_ph is not None and dop_ph != "-":
            Path(dop_ph).touch()
        if self._wraps is not None:
            result = self._wraps.SLC_deramp(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_deramp", supplied_args, result[0])
        )
        self._on_error("SLC_deramp", supplied_args, result[0])
        return result

    def residue(
        self, int: str, flag: str, width, xmin=None, xmax=None, ymin=None, ymax=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["residue"] += 1

        if int is not None:
            result = self._validate(
                "residue",
                int == "-" or Path(int).exists(),
                result,
                f"int path does not exist ({int})",
            )
        if flag is not None:
            result = self._validate(
                "residue",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if self._wraps is not None:
            result = self._wraps.residue(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "residue", supplied_args, result[0]))
        self._on_error("residue", supplied_args, result[0])
        return result

    def par_PRI(self, CEOS_SAR_leader: str, PRI_par: str, CEOS_DAT: str, PRI: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_PRI"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "par_PRI",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PRI_par is not None and PRI_par != "-":
            Path(PRI_par).touch()
        if CEOS_DAT is not None:
            result = self._validate(
                "par_PRI",
                CEOS_DAT == "-" or Path(CEOS_DAT).exists(),
                result,
                f"CEOS_DAT path does not exist ({CEOS_DAT})",
            )
        if PRI is not None and PRI != "-":
            Path(PRI).touch()
        if self._wraps is not None:
            result = self._wraps.par_PRI(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "par_PRI", supplied_args, result[0]))
        self._on_error("par_PRI", supplied_args, result[0])
        return result

    def create_offset(
        self,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        algorithm=None,
        rlks=None,
        azlks=None,
        iflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["create_offset"] += 1

        if SLC1_par is not None:
            result = self._validate(
                "create_offset",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "create_offset",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None and OFF_par != "-" and not Path(OFF_par).exists():
            Path(OFF_par).touch()
        valid_values = [1, 2] + [None]
        result = self._validate(
            "create_offset",
            algorithm == "-" or algorithm in valid_values,
            result,
            f"algorithm is not a valid value (expects: {valid_values}, got: {algorithm})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "create_offset",
            iflg == "-" or iflg in valid_values,
            result,
            f"iflg is not a valid value (expects: {valid_values}, got: {iflg})",
        )
        if self._wraps is not None:
            result = self._wraps.create_offset(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "create_offset", supplied_args, result[0])
        )
        self._on_error("create_offset", supplied_args, result[0])
        return result

    def multi_look_MLI(
        self,
        MLI_in,
        MLI_in_par: str,
        MLI_out: str,
        MLI_out_par: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
        scale=None,
        e_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_look_MLI"] += 1

        if MLI_in_par is not None:
            result = self._validate(
                "multi_look_MLI",
                MLI_in_par == "-" or Path(MLI_in_par).exists(),
                result,
                f"MLI_in_par path does not exist ({MLI_in_par})",
            )
        if MLI_out is not None and MLI_out != "-":
            Path(MLI_out).touch()
        if MLI_out_par is not None and MLI_out_par != "-":
            Path(MLI_out_par).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "multi_look_MLI",
            e_flag == "-" or e_flag in valid_values,
            result,
            f"e_flag is not a valid value (expects: {valid_values}, got: {e_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.multi_look_MLI(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "multi_look_MLI", supplied_args, result[0])
        )
        self._on_error("multi_look_MLI", supplied_args, result[0])
        return result

    def multi_real(
        self,
        data_in,
        OFF_par_in: str,
        data_out: str,
        OFF_par_out: str,
        rlks=None,
        azlks=None,
        loff=None,
        nlines=None,
        roff=None,
        nsamp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_real"] += 1

        if OFF_par_in is not None:
            result = self._validate(
                "multi_real",
                OFF_par_in == "-" or Path(OFF_par_in).exists(),
                result,
                f"OFF_par_in path does not exist ({OFF_par_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if (
            OFF_par_out is not None
            and OFF_par_out != "-"
            and not Path(OFF_par_out).exists()
        ):
            Path(OFF_par_out).touch()
        if self._wraps is not None:
            result = self._wraps.multi_real(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "multi_real", supplied_args, result[0])
        )
        self._on_error("multi_real", supplied_args, result[0])
        return result

    def SLC_intf2(
        self,
        SLC_1: str,
        SLC_2R: str,
        SLC1_par: str,
        SLC2R_par: str,
        MLI_1: str,
        MLI_2R: str,
        MLI1_par: str,
        MLI2R_par: str,
        interf: str,
        cc: str,
        r_dec,
        az_dec,
        rwin=None,
        azwin=None,
        wflg=None,
        lanczos=None,
        beta=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["SLC_intf2"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "SLC_intf2",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2R is not None:
            result = self._validate(
                "SLC_intf2",
                SLC_2R == "-" or Path(SLC_2R).exists(),
                result,
                f"SLC_2R path does not exist ({SLC_2R})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "SLC_intf2",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2R_par is not None:
            result = self._validate(
                "SLC_intf2",
                SLC2R_par == "-" or Path(SLC2R_par).exists(),
                result,
                f"SLC2R_par path does not exist ({SLC2R_par})",
            )
        if MLI_1 is not None and MLI_1 != "-":
            Path(MLI_1).touch()
        if MLI_2R is not None and MLI_2R != "-":
            Path(MLI_2R).touch()
        if MLI1_par is not None and MLI1_par != "-":
            Path(MLI1_par).touch()
        if MLI2R_par is not None and MLI2R_par != "-":
            Path(MLI2R_par).touch()
        if interf is not None and interf != "-":
            Path(interf).touch()
        if cc is not None and cc != "-":
            Path(cc).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "SLC_intf2",
            wflg == "-" or wflg in valid_values,
            result,
            f"wflg is not a valid value (expects: {valid_values}, got: {wflg})",
        )
        if self._wraps is not None:
            result = self._wraps.SLC_intf2(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "SLC_intf2", supplied_args, result[0])
        )
        self._on_error("SLC_intf2", supplied_args, result[0])
        return result

    def par_ASF_PRI(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ASF_PRI"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_ASF_PRI",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if CEOS_data is not None:
            result = self._validate(
                "par_ASF_PRI",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if self._wraps is not None:
            result = self._wraps.par_ASF_PRI(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ASF_PRI", supplied_args, result[0])
        )
        self._on_error("par_ASF_PRI", supplied_args, result[0])
        return result

    def offset_pwr(
        self,
        SLC1: str,
        SLC2: str,
        SLC1_par: str,
        SLC2_par: str,
        OFF_par: str,
        offs: str,
        ccp: str,
        rwin=None,
        azwin=None,
        offsets: str = None,
        n_ovr=None,
        nr=None,
        naz=None,
        thres=None,
        lanczos=None,
        bw_frac=None,
        deramp=None,
        int_filt=None,
        pflag=None,
        pltflg=None,
        ccs: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["offset_pwr"] += 1

        if SLC1 is not None:
            result = self._validate(
                "offset_pwr",
                SLC1 == "-" or Path(SLC1).exists(),
                result,
                f"SLC1 path does not exist ({SLC1})",
            )
        if SLC2 is not None:
            result = self._validate(
                "offset_pwr",
                SLC2 == "-" or Path(SLC2).exists(),
                result,
                f"SLC2 path does not exist ({SLC2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "offset_pwr",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "offset_pwr",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if OFF_par is not None:
            result = self._validate(
                "offset_pwr",
                OFF_par == "-" or Path(OFF_par).exists(),
                result,
                f"OFF_par path does not exist ({OFF_par})",
            )
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr",
            deramp == "-" or deramp in valid_values,
            result,
            f"deramp is not a valid value (expects: {valid_values}, got: {deramp})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr",
            int_filt == "-" or int_filt in valid_values,
            result,
            f"int_filt is not a valid value (expects: {valid_values}, got: {int_filt})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "offset_pwr",
            pflag == "-" or pflag in valid_values,
            result,
            f"pflag is not a valid value (expects: {valid_values}, got: {pflag})",
        )
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "offset_pwr",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if ccs is not None and ccs != "-":
            Path(ccs).touch()
        if self._wraps is not None:
            result = self._wraps.offset_pwr(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "offset_pwr", supplied_args, result[0])
        )
        self._on_error("offset_pwr", supplied_args, result[0])
        return result

    def par_ATLSCI_ERS(self, CEOS_SAR_leader, CEOS_Image: str, SLC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ATLSCI_ERS"] += 1

        if CEOS_Image is not None:
            result = self._validate(
                "par_ATLSCI_ERS",
                CEOS_Image == "-" or Path(CEOS_Image).exists(),
                result,
                f"CEOS_Image path does not exist ({CEOS_Image})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_ATLSCI_ERS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ATLSCI_ERS", supplied_args, result[0])
        )
        self._on_error("par_ATLSCI_ERS", supplied_args, result[0])
        return result

    def par_PRI_ESRIN_JERS(
        self, CEOS_SAR_leader: str, PRI_par: str, CEOS_DAT: str, PRI: str
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_PRI_ESRIN_JERS"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "par_PRI_ESRIN_JERS",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if PRI_par is not None and PRI_par != "-":
            Path(PRI_par).touch()
        if CEOS_DAT is not None:
            result = self._validate(
                "par_PRI_ESRIN_JERS",
                CEOS_DAT == "-" or Path(CEOS_DAT).exists(),
                result,
                f"CEOS_DAT path does not exist ({CEOS_DAT})",
            )
        if PRI is not None and PRI != "-":
            Path(PRI).touch()
        if self._wraps is not None:
            result = self._wraps.par_PRI_ESRIN_JERS(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_PRI_ESRIN_JERS", supplied_args, result[0])
        )
        self._on_error("par_PRI_ESRIN_JERS", supplied_args, result[0])
        return result

    def par_KC_PALSAR_slr(
        self,
        facter_m: str,
        CEOS_leader: str,
        SLC_par: str,
        pol,
        pls_mode,
        KC_data: str,
        pwr: str,
        fdtab: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_KC_PALSAR_slr"] += 1

        if facter_m is not None:
            result = self._validate(
                "par_KC_PALSAR_slr",
                facter_m == "-" or Path(facter_m).exists(),
                result,
                f"facter_m path does not exist ({facter_m})",
            )
        if CEOS_leader is not None:
            result = self._validate(
                "par_KC_PALSAR_slr",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        valid_values = [1, 2, 3]
        result = self._validate(
            "par_KC_PALSAR_slr",
            pls_mode == "-" or pls_mode in valid_values,
            result,
            f"pls_mode is not a valid value (expects: {valid_values}, got: {pls_mode})",
        )
        if KC_data is not None:
            result = self._validate(
                "par_KC_PALSAR_slr",
                KC_data == "-" or Path(KC_data).exists(),
                result,
                f"KC_data path does not exist ({KC_data})",
            )
        if pwr is not None and pwr != "-":
            Path(pwr).touch()
        if fdtab is not None and fdtab != "-":
            Path(fdtab).touch()
        if self._wraps is not None:
            result = self._wraps.par_KC_PALSAR_slr(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_KC_PALSAR_slr", supplied_args, result[0])
        )
        self._on_error("par_KC_PALSAR_slr", supplied_args, result[0])
        return result

    def ptarg_SLC(
        self,
        SLC_par: str,
        SLC: str,
        r_samp,
        az_samp,
        ptr_image: str,
        r_plot: str,
        az_plot: str,
        ptr_par: str = None,
        osf=None,
        win=None,
        pltflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ptarg_SLC"] += 1

        if SLC_par is not None:
            result = self._validate(
                "ptarg_SLC",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if SLC is not None:
            result = self._validate(
                "ptarg_SLC",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if ptr_image is not None and ptr_image != "-":
            Path(ptr_image).touch()
        if r_plot is not None and r_plot != "-":
            Path(r_plot).touch()
        if az_plot is not None and az_plot != "-":
            Path(az_plot).touch()
        if ptr_par is not None and ptr_par != "-":
            Path(ptr_par).touch()
        valid_values = [0, 1, 2, 3] + [None]
        result = self._validate(
            "ptarg_SLC",
            pltflg == "-" or pltflg in valid_values,
            result,
            f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})",
        )
        if self._wraps is not None:
            result = self._wraps.ptarg_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "ptarg_SLC", supplied_args, result[0])
        )
        self._on_error("ptarg_SLC", supplied_args, result[0])
        return result

    def par_EORC_PALSAR(
        self, CEOS_leader: str, SLC_par: str, CEOS_data: str, SLC: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_EORC_PALSAR"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_EORC_PALSAR",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if CEOS_data is not None:
            result = self._validate(
                "par_EORC_PALSAR",
                CEOS_data == "-" or Path(CEOS_data).exists(),
                result,
                f"CEOS_data path does not exist ({CEOS_data})",
            )
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_EORC_PALSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_EORC_PALSAR", supplied_args, result[0])
        )
        self._on_error("par_EORC_PALSAR", supplied_args, result[0])
        return result

    def S1_burstloc(self, annotation_XML: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["S1_burstloc"] += 1

        if annotation_XML is not None:
            result = self._validate(
                "S1_burstloc",
                annotation_XML == "-" or Path(annotation_XML).exists(),
                result,
                f"annotation_XML path does not exist ({annotation_XML})",
            )
        if self._wraps is not None:
            result = self._wraps.S1_burstloc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "S1_burstloc", supplied_args, result[0])
        )
        self._on_error("S1_burstloc", supplied_args, result[0])
        return result

    def par_GF3_SLC(
        self, GeoTIFF: str, annotation_XML: str, SLC_par: str, SLC: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_GF3_SLC"] += 1

        if GeoTIFF is not None:
            result = self._validate(
                "par_GF3_SLC",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if annotation_XML is not None:
            result = self._validate(
                "par_GF3_SLC",
                annotation_XML == "-" or Path(annotation_XML).exists(),
                result,
                f"annotation_XML path does not exist ({annotation_XML})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_GF3_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_GF3_SLC", supplied_args, result[0])
        )
        self._on_error("par_GF3_SLC", supplied_args, result[0])
        return result

    def cc_wave(
        self,
        interf: str,
        MLI_1,
        MLI_2,
        cc: str,
        width,
        bx=None,
        by=None,
        wflg=None,
        xmin=None,
        xmax=None,
        ymin=None,
        ymax=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cc_wave"] += 1

        if interf is not None:
            result = self._validate(
                "cc_wave",
                interf == "-" or Path(interf).exists(),
                result,
                f"interf path does not exist ({interf})",
            )
        if cc is not None and cc != "-":
            Path(cc).touch()
        if self._wraps is not None:
            result = self._wraps.cc_wave(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "cc_wave", supplied_args, result[0]))
        self._on_error("cc_wave", supplied_args, result[0])
        return result

    def par_RSAT2_SLC(
        self,
        product_XML: str,
        lut_XML: str,
        GeoTIFF: str,
        polarization,
        SLC_par: str,
        SLC: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_RSAT2_SLC"] += 1

        if product_XML is not None:
            result = self._validate(
                "par_RSAT2_SLC",
                product_XML == "-" or Path(product_XML).exists(),
                result,
                f"product_XML path does not exist ({product_XML})",
            )
        if lut_XML is not None:
            result = self._validate(
                "par_RSAT2_SLC",
                lut_XML == "-" or Path(lut_XML).exists(),
                result,
                f"lut_XML path does not exist ({lut_XML})",
            )
        if GeoTIFF is not None:
            result = self._validate(
                "par_RSAT2_SLC",
                GeoTIFF == "-" or Path(GeoTIFF).exists(),
                result,
                f"GeoTIFF path does not exist ({GeoTIFF})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if self._wraps is not None:
            result = self._wraps.par_RSAT2_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_RSAT2_SLC", supplied_args, result[0])
        )
        self._on_error("par_RSAT2_SLC", supplied_args, result[0])
        return result

    def residue_cc(
        self, int: str, flag: str, width, xmin=None, xmax=None, ymin=None, ymax=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["residue_cc"] += 1

        if int is not None:
            result = self._validate(
                "residue_cc",
                int == "-" or Path(int).exists(),
                result,
                f"int path does not exist ({int})",
            )
        if flag is not None:
            result = self._validate(
                "residue_cc",
                flag == "-" or Path(flag).exists(),
                result,
                f"flag path does not exist ({flag})",
            )
        if self._wraps is not None:
            result = self._wraps.residue_cc(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "residue_cc", supplied_args, result[0])
        )
        self._on_error("residue_cc", supplied_args, result[0])
        return result

    def par_PulSAR(self, CEOS_SAR_leader: str, SLC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_PulSAR"] += 1

        if CEOS_SAR_leader is not None:
            result = self._validate(
                "par_PulSAR",
                CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(),
                result,
                f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_PulSAR(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_PulSAR", supplied_args, result[0])
        )
        self._on_error("par_PulSAR", supplied_args, result[0])
        return result

    def par_ASF_91(self, CEOS_leader: str, CEOS_trailer: str, SLC_par: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["par_ASF_91"] += 1

        if CEOS_leader is not None:
            result = self._validate(
                "par_ASF_91",
                CEOS_leader == "-" or Path(CEOS_leader).exists(),
                result,
                f"CEOS_leader path does not exist ({CEOS_leader})",
            )
        if CEOS_trailer is not None:
            result = self._validate(
                "par_ASF_91",
                CEOS_trailer == "-" or Path(CEOS_trailer).exists(),
                result,
                f"CEOS_trailer path does not exist ({CEOS_trailer})",
            )
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if self._wraps is not None:
            result = self._wraps.par_ASF_91(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "par_ASF_91", supplied_args, result[0])
        )
        self._on_error("par_ASF_91", supplied_args, result[0])
        return result

    def fspf(
        self,
        data_in: str,
        data_out: str,
        width,
        dtype=None,
        r_max=None,
        spf_type=None,
        MLI_par=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["fspf"] += 1

        if data_in is not None:
            result = self._validate(
                "fspf",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "fspf",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        result = self._validate(
            "fspf",
            spf_type == "-" or spf_type in valid_values,
            result,
            f"spf_type is not a valid value (expects: {valid_values}, got: {spf_type})",
        )
        if self._wraps is not None:
            result = self._wraps.fspf(*supplied_args)

        self.call_sequence.append(PyGammaCall("ISP", "fspf", supplied_args, result[0]))
        self._on_error("fspf", supplied_args, result[0])
        return result

    def radcal_SLC(
        self,
        SLC: str,
        SLC_PAR: str,
        CSLC: str,
        CSLC_PAR: str,
        fcase=None,
        antenna=None,
        rloss_flag=None,
        ant_flag=None,
        refarea_flag=None,
        sc_dB=None,
        K_dB=None,
        pix_area: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["radcal_SLC"] += 1

        if SLC is not None:
            result = self._validate(
                "radcal_SLC",
                SLC == "-" or Path(SLC).exists(),
                result,
                f"SLC path does not exist ({SLC})",
            )
        if SLC_PAR is not None:
            result = self._validate(
                "radcal_SLC",
                SLC_PAR == "-" or Path(SLC_PAR).exists(),
                result,
                f"SLC_PAR path does not exist ({SLC_PAR})",
            )
        if CSLC is not None and CSLC != "-":
            Path(CSLC).touch()
        if CSLC_PAR is not None and CSLC_PAR != "-":
            Path(CSLC_PAR).touch()
        valid_values = [1, 2, 3, 4] + [None]
        result = self._validate(
            "radcal_SLC",
            fcase == "-" or fcase in valid_values,
            result,
            f"fcase is not a valid value (expects: {valid_values}, got: {fcase})",
        )
        if pix_area is not None and pix_area != "-":
            Path(pix_area).touch()
        if self._wraps is not None:
            result = self._wraps.radcal_SLC(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("ISP", "radcal_SLC", supplied_args, result[0])
        )
        self._on_error("radcal_SLC", supplied_args, result[0])
        return result

    def line_interp(self, input=None, output=None, width=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["line_interp"] += 1

        if self._wraps is not None:
            result = self._wraps.line_interp(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "line_interp", supplied_args, result[0])
        )
        self._on_error("line_interp", supplied_args, result[0])
        return result

    def product_cpx(
        self, f1: str, f2: str, f_out: str, width, start=None, nlines=None, conjg_flg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["product_cpx"] += 1

        if f1 is not None:
            result = self._validate(
                "product_cpx",
                f1 == "-" or Path(f1).exists(),
                result,
                f"f1 path does not exist ({f1})",
            )
        if f2 is not None:
            result = self._validate(
                "product_cpx",
                f2 == "-" or Path(f2).exists(),
                result,
                f"f2 path does not exist ({f2})",
            )
        if f_out is not None and f_out != "-":
            Path(f_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "product_cpx",
            conjg_flg == "-" or conjg_flg in valid_values,
            result,
            f"conjg_flg is not a valid value (expects: {valid_values}, got: {conjg_flg})",
        )
        if self._wraps is not None:
            result = self._wraps.product_cpx(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "product_cpx", supplied_args, result[0])
        )
        self._on_error("product_cpx", supplied_args, result[0])
        return result

    def ras_majority(self, ras_in: str, ras_out: str, filter_width=None, LR=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_majority"] += 1

        if ras_in is not None:
            result = self._validate(
                "ras_majority",
                ras_in == "-" or Path(ras_in).exists(),
                result,
                f"ras_in path does not exist ({ras_in})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        if self._wraps is not None:
            result = self._wraps.ras_majority(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "ras_majority", supplied_args, result[0])
        )
        self._on_error("ras_majority", supplied_args, result[0])
        return result

    def average_filter(
        self, din: str, dout: str, width, bx, by=None, wflg=None, min_pt=None, zflg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["average_filter"] += 1

        if din is not None:
            result = self._validate(
                "average_filter",
                din == "-" or Path(din).exists(),
                result,
                f"din path does not exist ({din})",
            )
        if dout is not None and dout != "-":
            Path(dout).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "average_filter",
            wflg == "-" or wflg in valid_values,
            result,
            f"wflg is not a valid value (expects: {valid_values}, got: {wflg})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "average_filter",
            zflg == "-" or zflg in valid_values,
            result,
            f"zflg is not a valid value (expects: {valid_values}, got: {zflg})",
        )
        if self._wraps is not None:
            result = self._wraps.average_filter(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "average_filter", supplied_args, result[0])
        )
        self._on_error("average_filter", supplied_args, result[0])
        return result

    def mask_class(
        self,
        class_map: str,
        file_in: str,
        file_out: str,
        format_flag,
        LR,
        selection_flag,
        n_class,
        class_1,
        class_n=None,
        null_value=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["mask_class"] += 1

        if class_map is not None:
            result = self._validate(
                "mask_class",
                class_map == "-" or Path(class_map).exists(),
                result,
                f"class_map path does not exist ({class_map})",
            )
        if file_in is not None:
            result = self._validate(
                "mask_class",
                file_in == "-" or Path(file_in).exists(),
                result,
                f"file_in path does not exist ({file_in})",
            )
        if file_out is not None and file_out != "-":
            Path(file_out).touch()
        valid_values = [0, 1, 2, 3]
        result = self._validate(
            "mask_class",
            format_flag == "-" or format_flag in valid_values,
            result,
            f"format_flag is not a valid value (expects: {valid_values}, got: {format_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.mask_class(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "mask_class", supplied_args, result[0])
        )
        self._on_error("mask_class", supplied_args, result[0])
        return result

    def ras_ratio_dB(
        self,
        pwr1: str,
        pwr2: str,
        width,
        start_pwr1=None,
        start_pwr2=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        min_cc=None,
        max_cc=None,
        scale=None,
        exp=None,
        LR=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_ratio_dB"] += 1

        if pwr1 is not None:
            result = self._validate(
                "ras_ratio_dB",
                pwr1 == "-" or Path(pwr1).exists(),
                result,
                f"pwr1 path does not exist ({pwr1})",
            )
        if pwr2 is not None:
            result = self._validate(
                "ras_ratio_dB",
                pwr2 == "-" or Path(pwr2).exists(),
                result,
                f"pwr2 path does not exist ({pwr2})",
            )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.ras_ratio_dB(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "ras_ratio_dB", supplied_args, result[0])
        )
        self._on_error("ras_ratio_dB", supplied_args, result[0])
        return result

    def linear_to_dB(
        self, data_in, data_out: str, width, inverse_flag=None, null_value=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["linear_to_dB"] += 1

        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "linear_to_dB",
            inverse_flag == "-" or inverse_flag in valid_values,
            result,
            f"inverse_flag is not a valid value (expects: {valid_values}, got: {inverse_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.linear_to_dB(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "linear_to_dB", supplied_args, result[0])
        )
        self._on_error("linear_to_dB", supplied_args, result[0])
        return result

    def histogram(
        self,
        data_in,
        width,
        polygon: str,
        hist: str,
        stat: str,
        min,
        max,
        nbins=None,
        mode=None,
        lin_log=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["histogram"] += 1

        if polygon is not None:
            result = self._validate(
                "histogram",
                polygon == "-" or Path(polygon).exists(),
                result,
                f"polygon path does not exist ({polygon})",
            )
        if hist is not None and hist != "-":
            Path(hist).touch()
        if stat is not None and stat != "-":
            Path(stat).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "histogram",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "histogram",
            lin_log == "-" or lin_log in valid_values,
            result,
            f"lin_log is not a valid value (expects: {valid_values}, got: {lin_log})",
        )
        if self._wraps is not None:
            result = self._wraps.histogram(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "histogram", supplied_args, result[0])
        )
        self._on_error("histogram", supplied_args, result[0])
        return result

    def gamma_map(self, input_data: str, output_data: str, width, nlooks, bx, by=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["gamma_map"] += 1

        if input_data is not None:
            result = self._validate(
                "gamma_map",
                input_data == "-" or Path(input_data).exists(),
                result,
                f"input_data path does not exist ({input_data})",
            )
        if output_data is not None and output_data != "-":
            Path(output_data).touch()
        if self._wraps is not None:
            result = self._wraps.gamma_map(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "gamma_map", supplied_args, result[0])
        )
        self._on_error("gamma_map", supplied_args, result[0])
        return result

    def m_chi(
        self, s0, m, s2chi: str, S_par: str, c1: str, c2: str = None, c3: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["m-chi"] += 1

        if s2chi is not None:
            result = self._validate(
                "m-chi",
                s2chi == "-" or Path(s2chi).exists(),
                result,
                f"s2chi path does not exist ({s2chi})",
            )
        if S_par is not None:
            result = self._validate(
                "m-chi",
                S_par == "-" or Path(S_par).exists(),
                result,
                f"S_par path does not exist ({S_par})",
            )
        if c1 is not None and c1 != "-":
            Path(c1).touch()
        if c2 is not None and c2 != "-":
            Path(c2).touch()
        if c3 is not None and c3 != "-":
            Path(c3).touch()
        if self._wraps is not None:
            result = self._wraps.m - chi(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "m-chi", supplied_args, result[0]))
        self._on_error("m-chi", supplied_args, result[0])
        return result

    def reallks(
        self,
        image,
        ML_image: str,
        width,
        rlks=None,
        azlks=None,
        start=None,
        nlines=None,
        r_start=None,
        nsamp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["reallks"] += 1

        if ML_image is not None and ML_image != "-":
            Path(ML_image).touch()
        if self._wraps is not None:
            result = self._wraps.reallks(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "reallks", supplied_args, result[0]))
        self._on_error("reallks", supplied_args, result[0])
        return result

    def frost(self, pwr1, pwr1_frost: str, width, fx=None, sx=None, power=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["frost"] += 1

        if pwr1_frost is not None and pwr1_frost != "-":
            Path(pwr1_frost).touch()
        if self._wraps is not None:
            result = self._wraps.frost(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "frost", supplied_args, result[0]))
        self._on_error("frost", supplied_args, result[0])
        return result

    def mt_lee_filt(
        self,
        im_list,
        ref_image: str,
        width,
        winsz,
        L_ref,
        L,
        cthres,
        out_list: str,
        ref_out: str = None,
        b_coeff: str = None,
        filt_num: str = None,
        msr: str = None,
        ctr: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["mt_lee_filt"] += 1

        if ref_image is not None:
            result = self._validate(
                "mt_lee_filt",
                ref_image == "-" or Path(ref_image).exists(),
                result,
                f"ref_image path does not exist ({ref_image})",
            )
        if out_list is not None:
            result = self._validate(
                "mt_lee_filt",
                out_list == "-" or Path(out_list).exists(),
                result,
                f"out_list path does not exist ({out_list})",
            )
        if ref_out is not None and ref_out != "-":
            Path(ref_out).touch()
        if b_coeff is not None and b_coeff != "-":
            Path(b_coeff).touch()
        if filt_num is not None and filt_num != "-":
            Path(filt_num).touch()
        if msr is not None and msr != "-":
            Path(msr).touch()
        if ctr is not None and ctr != "-":
            Path(ctr).touch()
        if self._wraps is not None:
            result = self._wraps.mt_lee_filt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "mt_lee_filt", supplied_args, result[0])
        )
        self._on_error("mt_lee_filt", supplied_args, result[0])
        return result

    def multi_stat(self, im_list, width, im_out: str, mode, rank, nmin=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_stat"] += 1

        if im_out is not None and im_out != "-":
            Path(im_out).touch()
        valid_values = [0, 1, 2, 3, 4]
        result = self._validate(
            "multi_stat",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.multi_stat(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "multi_stat", supplied_args, result[0])
        )
        self._on_error("multi_stat", supplied_args, result[0])
        return result

    def trigo(self, data1, func, data2: str, width):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["trigo"] += 1

        valid_values = [1]
        result = self._validate(
            "trigo",
            func == "-" or func in valid_values,
            result,
            f"func is not a valid value (expects: {valid_values}, got: {func})",
        )
        if data2 is not None and data2 != "-":
            Path(data2).touch()
        if self._wraps is not None:
            result = self._wraps.trigo(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "trigo", supplied_args, result[0]))
        self._on_error("trigo", supplied_args, result[0])
        return result

    def temp_filt(
        self,
        data_tab,
        width,
        waz=None,
        wr=None,
        wt_flag=None,
        zero_flag=None,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["temp_filt"] += 1

        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "temp_filt",
            wt_flag == "-" or wt_flag in valid_values,
            result,
            f"wt_flag is not a valid value (expects: {valid_values}, got: {wt_flag})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "temp_filt",
            zero_flag == "-" or zero_flag in valid_values,
            result,
            f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.temp_filt(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "temp_filt", supplied_args, result[0])
        )
        self._on_error("temp_filt", supplied_args, result[0])
        return result

    def cpxlks(
        self,
        CMPLX: str,
        ML_CMPLX: str,
        width,
        rlks=None,
        azlks=None,
        start=None,
        nlines=None,
        r_start=None,
        nsamp=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cpxlks"] += 1

        if CMPLX is not None:
            result = self._validate(
                "cpxlks",
                CMPLX == "-" or Path(CMPLX).exists(),
                result,
                f"CMPLX path does not exist ({CMPLX})",
            )
        if ML_CMPLX is not None and ML_CMPLX != "-":
            Path(ML_CMPLX).touch()
        if self._wraps is not None:
            result = self._wraps.cpxlks(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "cpxlks", supplied_args, result[0]))
        self._on_error("cpxlks", supplied_args, result[0])
        return result

    def ras_to_rgb(
        self,
        red_channel: str,
        green_channel: str,
        blue_channel: str,
        ras_out: str,
        LR=None,
        null_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_to_rgb"] += 1

        if red_channel is not None:
            result = self._validate(
                "ras_to_rgb",
                red_channel == "-" or Path(red_channel).exists(),
                result,
                f"red_channel path does not exist ({red_channel})",
            )
        if green_channel is not None:
            result = self._validate(
                "ras_to_rgb",
                green_channel == "-" or Path(green_channel).exists(),
                result,
                f"green_channel path does not exist ({green_channel})",
            )
        if blue_channel is not None:
            result = self._validate(
                "ras_to_rgb",
                blue_channel == "-" or Path(blue_channel).exists(),
                result,
                f"blue_channel path does not exist ({blue_channel})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ras_to_rgb",
            null_flag == "-" or null_flag in valid_values,
            result,
            f"null_flag is not a valid value (expects: {valid_values}, got: {null_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.ras_to_rgb(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "ras_to_rgb", supplied_args, result[0])
        )
        self._on_error("ras_to_rgb", supplied_args, result[0])
        return result

    def ave2pwr(self, pwr1, pwr2, pwr_out: str, width, scale_factor=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ave2pwr"] += 1

        if pwr_out is not None and pwr_out != "-":
            Path(pwr_out).touch()
        if self._wraps is not None:
            result = self._wraps.ave2pwr(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "ave2pwr", supplied_args, result[0]))
        self._on_error("ave2pwr", supplied_args, result[0])
        return result

    def ras_m_chi(
        self,
        s1,
        c1: str,
        c2: str,
        c3: str,
        width,
        start=None,
        nlines=None,
        pixavr=None,
        pixavaz=None,
        scale=None,
        exp=None,
        rasf: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_m-chi"] += 1

        if c1 is not None:
            result = self._validate(
                "ras_m-chi",
                c1 == "-" or Path(c1).exists(),
                result,
                f"c1 path does not exist ({c1})",
            )
        if c2 is not None:
            result = self._validate(
                "ras_m-chi",
                c2 == "-" or Path(c2).exists(),
                result,
                f"c2 path does not exist ({c2})",
            )
        if c3 is not None:
            result = self._validate(
                "ras_m-chi",
                c3 == "-" or Path(c3).exists(),
                result,
                f"c3 path does not exist ({c3})",
            )
        if rasf is not None and rasf != "-":
            Path(rasf).touch()
        if self._wraps is not None:
            result = self._wraps.ras_m - chi(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "ras_m-chi", supplied_args, result[0])
        )
        self._on_error("ras_m-chi", supplied_args, result[0])
        return result

    def sigma2gamma(self, pwr1: str, inc: str, gamma: str, width):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["sigma2gamma"] += 1

        if pwr1 is not None:
            result = self._validate(
                "sigma2gamma",
                pwr1 == "-" or Path(pwr1).exists(),
                result,
                f"pwr1 path does not exist ({pwr1})",
            )
        if inc is not None:
            result = self._validate(
                "sigma2gamma",
                inc == "-" or Path(inc).exists(),
                result,
                f"inc path does not exist ({inc})",
            )
        if gamma is not None and gamma != "-":
            Path(gamma).touch()
        if self._wraps is not None:
            result = self._wraps.sigma2gamma(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "sigma2gamma", supplied_args, result[0])
        )
        self._on_error("sigma2gamma", supplied_args, result[0])
        return result

    def hsi_color_scale(
        self, file_out: str, nval=None, chip_width=None, gap=None, height=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["hsi_color_scale"] += 1

        if file_out is not None and file_out != "-":
            Path(file_out).touch()
        valid_values = [0] + [None]
        result = self._validate(
            "hsi_color_scale",
            nval == "-" or nval in valid_values,
            result,
            f"nval is not a valid value (expects: {valid_values}, got: {nval})",
        )
        if self._wraps is not None:
            result = self._wraps.hsi_color_scale(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "hsi_color_scale", supplied_args, result[0])
        )
        self._on_error("hsi_color_scale", supplied_args, result[0])
        return result

    def unw_to_cpx(self, unw, cpx: str, width):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["unw_to_cpx"] += 1

        if cpx is not None and cpx != "-":
            Path(cpx).touch()
        if self._wraps is not None:
            result = self._wraps.unw_to_cpx(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "unw_to_cpx", supplied_args, result[0])
        )
        self._on_error("unw_to_cpx", supplied_args, result[0])
        return result

    def polyx(
        self,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["polyx"] += 1

        if self._wraps is not None:
            result = self._wraps.polyx(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "polyx", supplied_args, result[0]))
        self._on_error("polyx", supplied_args, result[0])
        return result

    def pauli(
        self,
        SLC_HH: str,
        SLC_VV: str,
        SLC_HV: str,
        SLC_HH_par: str,
        SLC_VV_par: str,
        SLC_HV_par: str,
        P: str,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["pauli"] += 1

        if SLC_HH is not None:
            result = self._validate(
                "pauli",
                SLC_HH == "-" or Path(SLC_HH).exists(),
                result,
                f"SLC_HH path does not exist ({SLC_HH})",
            )
        if SLC_VV is not None:
            result = self._validate(
                "pauli",
                SLC_VV == "-" or Path(SLC_VV).exists(),
                result,
                f"SLC_VV path does not exist ({SLC_VV})",
            )
        if SLC_HV is not None:
            result = self._validate(
                "pauli",
                SLC_HV == "-" or Path(SLC_HV).exists(),
                result,
                f"SLC_HV path does not exist ({SLC_HV})",
            )
        if SLC_HH_par is not None:
            result = self._validate(
                "pauli",
                SLC_HH_par == "-" or Path(SLC_HH_par).exists(),
                result,
                f"SLC_HH_par path does not exist ({SLC_HH_par})",
            )
        if SLC_VV_par is not None:
            result = self._validate(
                "pauli",
                SLC_VV_par == "-" or Path(SLC_VV_par).exists(),
                result,
                f"SLC_VV_par path does not exist ({SLC_VV_par})",
            )
        if SLC_HV_par is not None:
            result = self._validate(
                "pauli",
                SLC_HV_par == "-" or Path(SLC_HV_par).exists(),
                result,
                f"SLC_HV_par path does not exist ({SLC_HV_par})",
            )
        if P is not None and P != "-":
            Path(P).touch()
        if self._wraps is not None:
            result = self._wraps.pauli(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "pauli", supplied_args, result[0]))
        self._on_error("pauli", supplied_args, result[0])
        return result

    def m_alpha(
        self, s0, m, alpha: str, S_par: str, c1: str, c2: str = None, c3: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["m-alpha"] += 1

        if alpha is not None:
            result = self._validate(
                "m-alpha",
                alpha == "-" or Path(alpha).exists(),
                result,
                f"alpha path does not exist ({alpha})",
            )
        if S_par is not None:
            result = self._validate(
                "m-alpha",
                S_par == "-" or Path(S_par).exists(),
                result,
                f"S_par path does not exist ({S_par})",
            )
        if c1 is not None and c1 != "-":
            Path(c1).touch()
        if c2 is not None and c2 != "-":
            Path(c2).touch()
        if c3 is not None and c3 != "-":
            Path(c3).touch()
        if self._wraps is not None:
            result = self._wraps.m - alpha(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "m-alpha", supplied_args, result[0]))
        self._on_error("m-alpha", supplied_args, result[0])
        return result

    def stokes(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        S: str,
        S_par: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["stokes"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "stokes",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "stokes",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "stokes",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "stokes",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if S is not None and S != "-":
            Path(S).touch()
        if S_par is not None and S_par != "-":
            Path(S_par).touch()
        if self._wraps is not None:
            result = self._wraps.stokes(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "stokes", supplied_args, result[0]))
        self._on_error("stokes", supplied_args, result[0])
        return result

    def histogram_ras(
        self,
        ras_in: str,
        polygon,
        histograms,
        mean_stdev=None,
        percent=None,
        lr_flag=None,
        start=None,
        stop=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["histogram_ras"] += 1

        if ras_in is not None:
            result = self._validate(
                "histogram_ras",
                ras_in == "-" or Path(ras_in).exists(),
                result,
                f"ras_in path does not exist ({ras_in})",
            )
        if self._wraps is not None:
            result = self._wraps.histogram_ras(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "histogram_ras", supplied_args, result[0])
        )
        self._on_error("histogram_ras", supplied_args, result[0])
        return result

    def product(
        self, data_1, data_2, product: str, width, bx=None, by=None, wgt_flag=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["product"] += 1

        if product is not None and product != "-":
            Path(product).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "product",
            wgt_flag == "-" or wgt_flag in valid_values,
            result,
            f"wgt_flag is not a valid value (expects: {valid_values}, got: {wgt_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.product(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "product", supplied_args, result[0]))
        self._on_error("product", supplied_args, result[0])
        return result

    def mt_lee_filt_cpx(
        self,
        cpx_list: str,
        ref_image,
        width,
        winsz,
        L_ref,
        cthres,
        out_list: str,
        ref_out: str = None,
        b_coeff: str = None,
        filt_num: str = None,
        msr: str = None,
        ctr: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["mt_lee_filt_cpx"] += 1

        if cpx_list is not None:
            result = self._validate(
                "mt_lee_filt_cpx",
                cpx_list == "-" or Path(cpx_list).exists(),
                result,
                f"cpx_list path does not exist ({cpx_list})",
            )
        if out_list is not None:
            result = self._validate(
                "mt_lee_filt_cpx",
                out_list == "-" or Path(out_list).exists(),
                result,
                f"out_list path does not exist ({out_list})",
            )
        if ref_out is not None and ref_out != "-":
            Path(ref_out).touch()
        if b_coeff is not None and b_coeff != "-":
            Path(b_coeff).touch()
        if filt_num is not None and filt_num != "-":
            Path(filt_num).touch()
        if msr is not None and msr != "-":
            Path(msr).touch()
        if ctr is not None and ctr != "-":
            Path(ctr).touch()
        if self._wraps is not None:
            result = self._wraps.mt_lee_filt_cpx(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "mt_lee_filt_cpx", supplied_args, result[0])
        )
        self._on_error("mt_lee_filt_cpx", supplied_args, result[0])
        return result

    def polcovar(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC_3: str,
        SLC1_par: str,
        SLC2_par: str,
        SLC3_par: str,
        C: str,
        C_par: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["polcovar"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "polcovar",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "polcovar",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC_3 is not None:
            result = self._validate(
                "polcovar",
                SLC_3 == "-" or Path(SLC_3).exists(),
                result,
                f"SLC_3 path does not exist ({SLC_3})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "polcovar",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "polcovar",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if SLC3_par is not None:
            result = self._validate(
                "polcovar",
                SLC3_par == "-" or Path(SLC3_par).exists(),
                result,
                f"SLC3_par path does not exist ({SLC3_par})",
            )
        if C is not None and C != "-":
            Path(C).touch()
        if C_par is not None and C_par != "-":
            Path(C_par).touch()
        if self._wraps is not None:
            result = self._wraps.polcovar(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "polcovar", supplied_args, result[0])
        )
        self._on_error("polcovar", supplied_args, result[0])
        return result

    def stokes_qm(
        self,
        S,
        S_par: str,
        m: str = None,
        s2chi: str = None,
        s2psi: str = None,
        m_l: str = None,
        m_c: str = None,
        lp_ratio: str = None,
        cp_ratio: str = None,
        mu: str = None,
        delta: str = None,
        alpha: str = None,
        phi: str = None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["stokes_qm"] += 1

        if S_par is not None:
            result = self._validate(
                "stokes_qm",
                S_par == "-" or Path(S_par).exists(),
                result,
                f"S_par path does not exist ({S_par})",
            )
        if m is not None and m != "-":
            Path(m).touch()
        if s2chi is not None and s2chi != "-":
            Path(s2chi).touch()
        if s2psi is not None and s2psi != "-":
            Path(s2psi).touch()
        if m_l is not None and m_l != "-":
            Path(m_l).touch()
        if m_c is not None and m_c != "-":
            Path(m_c).touch()
        if lp_ratio is not None and lp_ratio != "-":
            Path(lp_ratio).touch()
        if cp_ratio is not None and cp_ratio != "-":
            Path(cp_ratio).touch()
        if mu is not None and mu != "-":
            Path(mu).touch()
        if delta is not None and delta != "-":
            Path(delta).touch()
        if alpha is not None and alpha != "-":
            Path(alpha).touch()
        if phi is not None and phi != "-":
            Path(phi).touch()
        if self._wraps is not None:
            result = self._wraps.stokes_qm(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "stokes_qm", supplied_args, result[0])
        )
        self._on_error("stokes_qm", supplied_args, result[0])
        return result

    def frame(
        self,
        data_in: str,
        data_out: str,
        width,
        dtype,
        dx1,
        dx2,
        dy1,
        dy2,
        null_flag=None,
        all_flag=None,
        null_value=None,
        frame_value=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["frame"] += 1

        if data_in is not None:
            result = self._validate(
                "frame",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1, 2, 3, 4, 5]
        result = self._validate(
            "frame",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "frame",
            null_flag == "-" or null_flag in valid_values,
            result,
            f"null_flag is not a valid value (expects: {valid_values}, got: {null_flag})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "frame",
            all_flag == "-" or all_flag in valid_values,
            result,
            f"all_flag is not a valid value (expects: {valid_values}, got: {all_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.frame(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "frame", supplied_args, result[0]))
        self._on_error("frame", supplied_args, result[0])
        return result

    def looks(
        self,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["looks"] += 1

        if self._wraps is not None:
            result = self._wraps.looks(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "looks", supplied_args, result[0]))
        self._on_error("looks", supplied_args, result[0])
        return result

    def polcoh(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC_3: str,
        SLC1_par: str,
        SLC2_par: str,
        SLC3_par: str,
        T: str,
        T_par: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["polcoh"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "polcoh",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "polcoh",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC_3 is not None:
            result = self._validate(
                "polcoh",
                SLC_3 == "-" or Path(SLC_3).exists(),
                result,
                f"SLC_3 path does not exist ({SLC_3})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "polcoh",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "polcoh",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if SLC3_par is not None:
            result = self._validate(
                "polcoh",
                SLC3_par == "-" or Path(SLC3_par).exists(),
                result,
                f"SLC3_par path does not exist ({SLC3_par})",
            )
        if T is not None and T != "-":
            Path(T).touch()
        if T_par is not None and T_par != "-":
            Path(T_par).touch()
        if self._wraps is not None:
            result = self._wraps.polcoh(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "polcoh", supplied_args, result[0]))
        self._on_error("polcoh", supplied_args, result[0])
        return result

    def lin_comb(
        self,
        nfiles,
        f1,
        f2,
        constant=None,
        factor1=None,
        factor2=None,
        f_out: str = None,
        width=None,
        start=None,
        nlines=None,
        pixav_x=None,
        pixav_y=None,
        zero_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["lin_comb"] += 1

        if f_out is not None and f_out != "-":
            Path(f_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "lin_comb",
            zero_flag == "-" or zero_flag in valid_values,
            result,
            f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.lin_comb(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "lin_comb", supplied_args, result[0])
        )
        self._on_error("lin_comb", supplied_args, result[0])
        return result

    def multi_class_mapping(
        self,
        nfiles,
        f1,
        f2,
        fn=None,
        classf: str = None,
        ras_out: str = None,
        width=None,
        start=None,
        nlines=None,
        pixav_x=None,
        pixav_y=None,
        LR=None,
        color_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["multi_class_mapping"] += 1

        if classf is not None:
            result = self._validate(
                "multi_class_mapping",
                classf == "-" or Path(classf).exists(),
                result,
                f"classf path does not exist ({classf})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "multi_class_mapping",
            color_flag == "-" or color_flag in valid_values,
            result,
            f"color_flag is not a valid value (expects: {valid_values}, got: {color_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.multi_class_mapping(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "multi_class_mapping", supplied_args, result[0])
        )
        self._on_error("multi_class_mapping", supplied_args, result[0])
        return result

    def takecut(self, data_in, width, report: str, mode, pos, pr_flag=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["takecut"] += 1

        if report is not None and report != "-":
            Path(report).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "takecut",
            pr_flag == "-" or pr_flag in valid_values,
            result,
            f"pr_flag is not a valid value (expects: {valid_values}, got: {pr_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.takecut(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "takecut", supplied_args, result[0]))
        self._on_error("takecut", supplied_args, result[0])
        return result

    def polyx_phase(self, data: str, width, polygon: str, report: str):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["polyx_phase"] += 1

        if data is not None:
            result = self._validate(
                "polyx_phase",
                data == "-" or Path(data).exists(),
                result,
                f"data path does not exist ({data})",
            )
        if polygon is not None:
            result = self._validate(
                "polyx_phase",
                polygon == "-" or Path(polygon).exists(),
                result,
                f"polygon path does not exist ({polygon})",
            )
        if report is not None and report != "-":
            Path(report).touch()
        if self._wraps is not None:
            result = self._wraps.polyx_phase(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "polyx_phase", supplied_args, result[0])
        )
        self._on_error("polyx_phase", supplied_args, result[0])
        return result

    def temp_lin_var(
        self,
        data_tab,
        mean: str,
        stdev: str,
        width,
        waz=None,
        wr=None,
        wt_flag=None,
        zero_flag=None,
        loff=None,
        nlines=None,
        norm_pow=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["temp_lin_var"] += 1

        if mean is not None and mean != "-":
            Path(mean).touch()
        if stdev is not None and stdev != "-":
            Path(stdev).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "temp_lin_var",
            wt_flag == "-" or wt_flag in valid_values,
            result,
            f"wt_flag is not a valid value (expects: {valid_values}, got: {wt_flag})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "temp_lin_var",
            zero_flag == "-" or zero_flag in valid_values,
            result,
            f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.temp_lin_var(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "temp_lin_var", supplied_args, result[0])
        )
        self._on_error("temp_lin_var", supplied_args, result[0])
        return result

    def ave_cpx(
        self, cpx_list: str, width, ave: str, start=None, nlines=None, zflag=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ave_cpx"] += 1

        if cpx_list is not None:
            result = self._validate(
                "ave_cpx",
                cpx_list == "-" or Path(cpx_list).exists(),
                result,
                f"cpx_list path does not exist ({cpx_list})",
            )
        if ave is not None and ave != "-":
            Path(ave).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ave_cpx",
            zflag == "-" or zflag in valid_values,
            result,
            f"zflag is not a valid value (expects: {valid_values}, got: {zflag})",
        )
        if self._wraps is not None:
            result = self._wraps.ave_cpx(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "ave_cpx", supplied_args, result[0]))
        self._on_error("ave_cpx", supplied_args, result[0])
        return result

    def mask_op(self, mask_1: str, mask_2: str, mask_out: str, mode):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["mask_op"] += 1

        if mask_1 is not None:
            result = self._validate(
                "mask_op",
                mask_1 == "-" or Path(mask_1).exists(),
                result,
                f"mask_1 path does not exist ({mask_1})",
            )
        if mask_2 is not None:
            result = self._validate(
                "mask_op",
                mask_2 == "-" or Path(mask_2).exists(),
                result,
                f"mask_2 path does not exist ({mask_2})",
            )
        if mask_out is not None and mask_out != "-":
            Path(mask_out).touch()
        valid_values = [0, 1, 2]
        result = self._validate(
            "mask_op",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        if self._wraps is not None:
            result = self._wraps.mask_op(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "mask_op", supplied_args, result[0]))
        self._on_error("mask_op", supplied_args, result[0])
        return result

    def quad2cp(
        self,
        SLC_HH: str,
        SLC_HV: str,
        SLC_VH: str,
        SLC_VV: str,
        SLC_HH_par: str,
        SLC_HV_par: str,
        SLC_VH_par: str,
        SLC_VV_par: str,
        CP: str,
        TX_pol,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["quad2cp"] += 1

        if SLC_HH is not None:
            result = self._validate(
                "quad2cp",
                SLC_HH == "-" or Path(SLC_HH).exists(),
                result,
                f"SLC_HH path does not exist ({SLC_HH})",
            )
        if SLC_HV is not None:
            result = self._validate(
                "quad2cp",
                SLC_HV == "-" or Path(SLC_HV).exists(),
                result,
                f"SLC_HV path does not exist ({SLC_HV})",
            )
        if SLC_VH is not None:
            result = self._validate(
                "quad2cp",
                SLC_VH == "-" or Path(SLC_VH).exists(),
                result,
                f"SLC_VH path does not exist ({SLC_VH})",
            )
        if SLC_VV is not None:
            result = self._validate(
                "quad2cp",
                SLC_VV == "-" or Path(SLC_VV).exists(),
                result,
                f"SLC_VV path does not exist ({SLC_VV})",
            )
        if SLC_HH_par is not None:
            result = self._validate(
                "quad2cp",
                SLC_HH_par == "-" or Path(SLC_HH_par).exists(),
                result,
                f"SLC_HH_par path does not exist ({SLC_HH_par})",
            )
        if SLC_HV_par is not None:
            result = self._validate(
                "quad2cp",
                SLC_HV_par == "-" or Path(SLC_HV_par).exists(),
                result,
                f"SLC_HV_par path does not exist ({SLC_HV_par})",
            )
        if SLC_VH_par is not None:
            result = self._validate(
                "quad2cp",
                SLC_VH_par == "-" or Path(SLC_VH_par).exists(),
                result,
                f"SLC_VH_par path does not exist ({SLC_VH_par})",
            )
        if SLC_VV_par is not None:
            result = self._validate(
                "quad2cp",
                SLC_VV_par == "-" or Path(SLC_VV_par).exists(),
                result,
                f"SLC_VV_par path does not exist ({SLC_VV_par})",
            )
        if CP is not None and CP != "-":
            Path(CP).touch()
        valid_values = [0, 1]
        result = self._validate(
            "quad2cp",
            TX_pol == "-" or TX_pol in valid_values,
            result,
            f"TX_pol is not a valid value (expects: {valid_values}, got: {TX_pol})",
        )
        if self._wraps is not None:
            result = self._wraps.quad2cp(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "quad2cp", supplied_args, result[0]))
        self._on_error("quad2cp", supplied_args, result[0])
        return result

    def poly_math(
        self,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["poly_math"] += 1

        if self._wraps is not None:
            result = self._wraps.poly_math(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "poly_math", supplied_args, result[0])
        )
        self._on_error("poly_math", supplied_args, result[0])
        return result

    def single_class_mapping(
        self,
        nfiles,
        f1,
        lt1,
        ut1,
        fn=None,
        ltn=None,
        utn=None,
        ras_out: str = None,
        width=None,
        start=None,
        nlines=None,
        pixav_x=None,
        pixav_y=None,
        LR=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["single_class_mapping"] += 1

        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        if self._wraps is not None:
            result = self._wraps.single_class_mapping(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "single_class_mapping", supplied_args, result[0])
        )
        self._on_error("single_class_mapping", supplied_args, result[0])
        return result

    def drawthat(
        self,
        ras_in: str,
        ras_out: str,
        pt_list: str,
        mode=None,
        r=None,
        g=None,
        b=None,
        xs=None,
        zflg=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["drawthat"] += 1

        if ras_in is not None:
            result = self._validate(
                "drawthat",
                ras_in == "-" or Path(ras_in).exists(),
                result,
                f"ras_in path does not exist ({ras_in})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        if pt_list is not None:
            result = self._validate(
                "drawthat",
                pt_list == "-" or Path(pt_list).exists(),
                result,
                f"pt_list path does not exist ({pt_list})",
            )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "drawthat",
            mode == "-" or mode in valid_values,
            result,
            f"mode is not a valid value (expects: {valid_values}, got: {mode})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "drawthat",
            zflg == "-" or zflg in valid_values,
            result,
            f"zflg is not a valid value (expects: {valid_values}, got: {zflg})",
        )
        if self._wraps is not None:
            result = self._wraps.drawthat(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "drawthat", supplied_args, result[0])
        )
        self._on_error("drawthat", supplied_args, result[0])
        return result

    def m_delta(
        self, s0, m, delta: str, S_par: str, c1: str, c2: str = None, c3: str = None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["m-delta"] += 1

        if delta is not None:
            result = self._validate(
                "m-delta",
                delta == "-" or Path(delta).exists(),
                result,
                f"delta path does not exist ({delta})",
            )
        if S_par is not None:
            result = self._validate(
                "m-delta",
                S_par == "-" or Path(S_par).exists(),
                result,
                f"S_par path does not exist ({S_par})",
            )
        if c1 is not None and c1 != "-":
            Path(c1).touch()
        if c2 is not None and c2 != "-":
            Path(c2).touch()
        if c3 is not None and c3 != "-":
            Path(c3).touch()
        if self._wraps is not None:
            result = self._wraps.m - delta(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "m-delta", supplied_args, result[0]))
        self._on_error("m-delta", supplied_args, result[0])
        return result

    def temp_filt_ad(self, data_tab, width, zero_flag=None, loffset=None, nlines=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["temp_filt_ad"] += 1

        valid_values = [0, 1] + [None]
        result = self._validate(
            "temp_filt_ad",
            zero_flag == "-" or zero_flag in valid_values,
            result,
            f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.temp_filt_ad(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "temp_filt_ad", supplied_args, result[0])
        )
        self._on_error("temp_filt_ad", supplied_args, result[0])
        return result

    def bm3d(
        self,
        data_in: str,
        width,
        data_out: str,
        dtype=None,
        profile=None,
        looks=None,
        sigma=None,
        block_size=None,
        s_dist=None,
        step=None,
        d_max=None,
        t1d=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["bm3d"] += 1

        if data_in is not None:
            result = self._validate(
                "bm3d",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "bm3d",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1, 2, 3, 4, 5, 6] + [None]
        result = self._validate(
            "bm3d",
            profile == "-" or profile in valid_values,
            result,
            f"profile is not a valid value (expects: {valid_values}, got: {profile})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "bm3d",
            d_max == "-" or d_max in valid_values,
            result,
            f"d_max is not a valid value (expects: {valid_values}, got: {d_max})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "bm3d",
            t1d == "-" or t1d in valid_values,
            result,
            f"t1d is not a valid value (expects: {valid_values}, got: {t1d})",
        )
        if self._wraps is not None:
            result = self._wraps.bm3d(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "bm3d", supplied_args, result[0]))
        self._on_error("bm3d", supplied_args, result[0])
        return result

    def restore_float(self, input=None, output=None, width=None, interp_limit=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["restore_float"] += 1

        if self._wraps is not None:
            result = self._wraps.restore_float(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "restore_float", supplied_args, result[0])
        )
        self._on_error("restore_float", supplied_args, result[0])
        return result

    def haalpha(
        self,
        alpha: str,
        beta: str,
        gamma: str,
        SLC_par: str,
        anisotropy: str,
        entropy: str,
        lambda1: str,
        lambda2: str,
        lambda3: str,
        MLI_par: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["haalpha"] += 1

        if alpha is not None and alpha != "-":
            Path(alpha).touch()
        if beta is not None:
            result = self._validate(
                "haalpha",
                beta == "-" or Path(beta).exists(),
                result,
                f"beta path does not exist ({beta})",
            )
        if gamma is not None:
            result = self._validate(
                "haalpha",
                gamma == "-" or Path(gamma).exists(),
                result,
                f"gamma path does not exist ({gamma})",
            )
        if SLC_par is not None:
            result = self._validate(
                "haalpha",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if anisotropy is not None and anisotropy != "-":
            Path(anisotropy).touch()
        if entropy is not None and entropy != "-":
            Path(entropy).touch()
        if lambda1 is not None and lambda1 != "-":
            Path(lambda1).touch()
        if lambda2 is not None and lambda2 != "-":
            Path(lambda2).touch()
        if lambda3 is not None and lambda3 != "-":
            Path(lambda3).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if self._wraps is not None:
            result = self._wraps.haalpha(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "haalpha", supplied_args, result[0]))
        self._on_error("haalpha", supplied_args, result[0])
        return result

    def wolf(
        self,
        SLC_1: str,
        SLC_2: str,
        SLC1_par: str,
        SLC2_par: str,
        J: str,
        J_par: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["wolf"] += 1

        if SLC_1 is not None:
            result = self._validate(
                "wolf",
                SLC_1 == "-" or Path(SLC_1).exists(),
                result,
                f"SLC_1 path does not exist ({SLC_1})",
            )
        if SLC_2 is not None:
            result = self._validate(
                "wolf",
                SLC_2 == "-" or Path(SLC_2).exists(),
                result,
                f"SLC_2 path does not exist ({SLC_2})",
            )
        if SLC1_par is not None:
            result = self._validate(
                "wolf",
                SLC1_par == "-" or Path(SLC1_par).exists(),
                result,
                f"SLC1_par path does not exist ({SLC1_par})",
            )
        if SLC2_par is not None:
            result = self._validate(
                "wolf",
                SLC2_par == "-" or Path(SLC2_par).exists(),
                result,
                f"SLC2_par path does not exist ({SLC2_par})",
            )
        if J is not None and J != "-":
            Path(J).touch()
        if J_par is not None and J_par != "-":
            Path(J_par).touch()
        if self._wraps is not None:
            result = self._wraps.wolf(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "wolf", supplied_args, result[0]))
        self._on_error("wolf", supplied_args, result[0])
        return result

    def takethat_dem_par(
        self,
        data_in,
        width,
        positions: str,
        DEM_par: str,
        report: str,
        mode=None,
        zero_flag=None,
        nn_flag=None,
        print_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["takethat_dem_par"] += 1

        if positions is not None:
            result = self._validate(
                "takethat_dem_par",
                positions == "-" or Path(positions).exists(),
                result,
                f"positions path does not exist ({positions})",
            )
        if DEM_par is not None:
            result = self._validate(
                "takethat_dem_par",
                DEM_par == "-" or Path(DEM_par).exists(),
                result,
                f"DEM_par path does not exist ({DEM_par})",
            )
        if report is not None and report != "-":
            Path(report).touch()
        if self._wraps is not None:
            result = self._wraps.takethat_dem_par(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "takethat_dem_par", supplied_args, result[0])
        )
        self._on_error("takethat_dem_par", supplied_args, result[0])
        return result

    def lee(self, input_data: str, output_data: str, width, nlooks, bx, by=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["lee"] += 1

        if input_data is not None:
            result = self._validate(
                "lee",
                input_data == "-" or Path(input_data).exists(),
                result,
                f"input_data path does not exist ({input_data})",
            )
        if output_data is not None and output_data != "-":
            Path(output_data).touch()
        if self._wraps is not None:
            result = self._wraps.lee(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "lee", supplied_args, result[0]))
        self._on_error("lee", supplied_args, result[0])
        return result

    def enh_lee(
        self, input_data: str, output_data: str, width, nlooks, damp, bx, by=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["enh_lee"] += 1

        if input_data is not None:
            result = self._validate(
                "enh_lee",
                input_data == "-" or Path(input_data).exists(),
                result,
                f"input_data path does not exist ({input_data})",
            )
        if output_data is not None and output_data != "-":
            Path(output_data).touch()
        if self._wraps is not None:
            result = self._wraps.enh_lee(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "enh_lee", supplied_args, result[0]))
        self._on_error("enh_lee", supplied_args, result[0])
        return result

    def ratio(self, d1, d2, ratio: str, width, bx=None, by=None, wgt_flag=None):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ratio"] += 1

        if ratio is not None and ratio != "-":
            Path(ratio).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "ratio",
            wgt_flag == "-" or wgt_flag in valid_values,
            result,
            f"wgt_flag is not a valid value (expects: {valid_values}, got: {wgt_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.ratio(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "ratio", supplied_args, result[0]))
        self._on_error("ratio", supplied_args, result[0])
        return result

    def cc_ad(
        self,
        interf: str,
        pwr1: str,
        pwr2: str,
        slope: str,
        texture: str,
        cc_ad: str,
        width,
        box_min=None,
        box_max=None,
        wgt_flag=None,
        loff=None,
        nl=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cc_ad"] += 1

        if interf is not None:
            result = self._validate(
                "cc_ad",
                interf == "-" or Path(interf).exists(),
                result,
                f"interf path does not exist ({interf})",
            )
        if pwr1 is not None:
            result = self._validate(
                "cc_ad",
                pwr1 == "-" or Path(pwr1).exists(),
                result,
                f"pwr1 path does not exist ({pwr1})",
            )
        if pwr2 is not None:
            result = self._validate(
                "cc_ad",
                pwr2 == "-" or Path(pwr2).exists(),
                result,
                f"pwr2 path does not exist ({pwr2})",
            )
        if slope is not None:
            result = self._validate(
                "cc_ad",
                slope == "-" or Path(slope).exists(),
                result,
                f"slope path does not exist ({slope})",
            )
        if texture is not None:
            result = self._validate(
                "cc_ad",
                texture == "-" or Path(texture).exists(),
                result,
                f"texture path does not exist ({texture})",
            )
        if cc_ad is not None and cc_ad != "-":
            Path(cc_ad).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "cc_ad",
            wgt_flag == "-" or wgt_flag in valid_values,
            result,
            f"wgt_flag is not a valid value (expects: {valid_values}, got: {wgt_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.cc_ad(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "cc_ad", supplied_args, result[0]))
        self._on_error("cc_ad", supplied_args, result[0])
        return result

    def ras_ras(
        self,
        ras_in: str,
        ras_out: str,
        col_looks=None,
        row_looks=None,
        LR=None,
        r_lin_log=None,
        g_lin_log=None,
        b_lin_log=None,
        force24=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_ras"] += 1

        if ras_in is not None:
            result = self._validate(
                "ras_ras",
                ras_in == "-" or Path(ras_in).exists(),
                result,
                f"ras_in path does not exist ({ras_in})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ras_ras",
            force24 == "-" or force24 in valid_values,
            result,
            f"force24 is not a valid value (expects: {valid_values}, got: {force24})",
        )
        if self._wraps is not None:
            result = self._wraps.ras_ras(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "ras_ras", supplied_args, result[0]))
        self._on_error("ras_ras", supplied_args, result[0])
        return result

    def lin_comb_cpx(
        self,
        nfiles,
        f1: str,
        f2: str,
        constant_r=None,
        constant_i=None,
        factor1_r=None,
        factor1_i=None,
        factor2_r=None,
        factor2_i=None,
        f_out: str = None,
        width=None,
        start=None,
        nlines=None,
        pixav_x=None,
        pixav_y=None,
        zero_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["lin_comb_cpx"] += 1

        if f1 is not None:
            result = self._validate(
                "lin_comb_cpx",
                f1 == "-" or Path(f1).exists(),
                result,
                f"f1 path does not exist ({f1})",
            )
        if f2 is not None:
            result = self._validate(
                "lin_comb_cpx",
                f2 == "-" or Path(f2).exists(),
                result,
                f"f2 path does not exist ({f2})",
            )
        if f_out is not None and f_out != "-":
            Path(f_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "lin_comb_cpx",
            zero_flag == "-" or zero_flag in valid_values,
            result,
            f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.lin_comb_cpx(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "lin_comb_cpx", supplied_args, result[0])
        )
        self._on_error("lin_comb_cpx", supplied_args, result[0])
        return result

    def median_filter(
        self, din: str, dout: str, width, bx, by=None, min_pt=None, zflg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["median_filter"] += 1

        if din is not None:
            result = self._validate(
                "median_filter",
                din == "-" or Path(din).exists(),
                result,
                f"din path does not exist ({din})",
            )
        if dout is not None and dout != "-":
            Path(dout).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "median_filter",
            zflg == "-" or zflg in valid_values,
            result,
            f"zflg is not a valid value (expects: {valid_values}, got: {zflg})",
        )
        if self._wraps is not None:
            result = self._wraps.median_filter(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "median_filter", supplied_args, result[0])
        )
        self._on_error("median_filter", supplied_args, result[0])
        return result

    def takethat(
        self,
        data_in,
        width,
        positions: str,
        report: str,
        mode=None,
        zero_flag=None,
        nn_flag=None,
        print_flag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["takethat"] += 1

        if positions is not None:
            result = self._validate(
                "takethat",
                positions == "-" or Path(positions).exists(),
                result,
                f"positions path does not exist ({positions})",
            )
        if report is not None and report != "-":
            Path(report).touch()
        if self._wraps is not None:
            result = self._wraps.takethat(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "takethat", supplied_args, result[0])
        )
        self._on_error("takethat", supplied_args, result[0])
        return result

    def cc_monitoring(
        self,
        nfiles,
        f1,
        f2,
        ras_out: str = None,
        width=None,
        cc_thresh=None,
        start=None,
        nlines=None,
        pixav_x=None,
        pixav_y=None,
        LR=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["cc_monitoring"] += 1

        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        if self._wraps is not None:
            result = self._wraps.cc_monitoring(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "cc_monitoring", supplied_args, result[0])
        )
        self._on_error("cc_monitoring", supplied_args, result[0])
        return result

    def temp_log_var(
        self,
        data_tab,
        mean: str,
        stdev: str,
        width,
        waz=None,
        wr=None,
        wt_flag=None,
        zero_flag=None,
        loff=None,
        nlines=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["temp_log_var"] += 1

        if mean is not None and mean != "-":
            Path(mean).touch()
        if stdev is not None and stdev != "-":
            Path(stdev).touch()
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "temp_log_var",
            wt_flag == "-" or wt_flag in valid_values,
            result,
            f"wt_flag is not a valid value (expects: {valid_values}, got: {wt_flag})",
        )
        valid_values = [0, 1] + [None]
        result = self._validate(
            "temp_log_var",
            zero_flag == "-" or zero_flag in valid_values,
            result,
            f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.temp_log_var(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "temp_log_var", supplied_args, result[0])
        )
        self._on_error("temp_log_var", supplied_args, result[0])
        return result

    def ras_to_hsi(
        self, HUE: str, SATURATION: str, INTENSITY: str, ras_out: str, LR=None, cflg=None
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["ras_to_hsi"] += 1

        if HUE is not None:
            result = self._validate(
                "ras_to_hsi",
                HUE == "-" or Path(HUE).exists(),
                result,
                f"HUE path does not exist ({HUE})",
            )
        if SATURATION is not None:
            result = self._validate(
                "ras_to_hsi",
                SATURATION == "-" or Path(SATURATION).exists(),
                result,
                f"SATURATION path does not exist ({SATURATION})",
            )
        if INTENSITY is not None:
            result = self._validate(
                "ras_to_hsi",
                INTENSITY == "-" or Path(INTENSITY).exists(),
                result,
                f"INTENSITY path does not exist ({INTENSITY})",
            )
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "ras_to_hsi",
            cflg == "-" or cflg in valid_values,
            result,
            f"cflg is not a valid value (expects: {valid_values}, got: {cflg})",
        )
        if self._wraps is not None:
            result = self._wraps.ras_to_hsi(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "ras_to_hsi", supplied_args, result[0])
        )
        self._on_error("ras_to_hsi", supplied_args, result[0])
        return result

    def edge_detection(
        self,
        data_in: str,
        width,
        data_out: str,
        dtype=None,
        op_flg=None,
        sigma_x=None,
        sigma_y=None,
        T1=None,
        T2=None,
        min_seg_size=None,
        max_reg_len=None,
        max_reg_std=None,
        max_reg_dist=None,
        seg_out: str = None,
        line_filt=None,
        max_line_std=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["edge_detection"] += 1

        if data_in is not None:
            result = self._validate(
                "edge_detection",
                data_in == "-" or Path(data_in).exists(),
                result,
                f"data_in path does not exist ({data_in})",
            )
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "edge_detection",
            dtype == "-" or dtype in valid_values,
            result,
            f"dtype is not a valid value (expects: {valid_values}, got: {dtype})",
        )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "edge_detection",
            op_flg == "-" or op_flg in valid_values,
            result,
            f"op_flg is not a valid value (expects: {valid_values}, got: {op_flg})",
        )
        if seg_out is not None and seg_out != "-":
            Path(seg_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "edge_detection",
            line_filt == "-" or line_filt in valid_values,
            result,
            f"line_filt is not a valid value (expects: {valid_values}, got: {line_filt})",
        )
        if self._wraps is not None:
            result = self._wraps.edge_detection(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "edge_detection", supplied_args, result[0])
        )
        self._on_error("edge_detection", supplied_args, result[0])
        return result

    def texture(
        self,
        data_in,
        format_flag,
        texture: str,
        width,
        type=None,
        bx=None,
        by=None,
        r_looks=None,
        az_looks=None,
        weights_flag=None,
        data_in_mean=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["texture"] += 1

        if texture is not None and texture != "-":
            Path(texture).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "texture",
            type == "-" or type in valid_values,
            result,
            f"type is not a valid value (expects: {valid_values}, got: {type})",
        )
        valid_values = [0, 1, 2] + [None]
        result = self._validate(
            "texture",
            weights_flag == "-" or weights_flag in valid_values,
            result,
            f"weights_flag is not a valid value (expects: {valid_values}, got: {weights_flag})",
        )
        if self._wraps is not None:
            result = self._wraps.texture(*supplied_args)

        self.call_sequence.append(PyGammaCall("LAT", "texture", supplied_args, result[0]))
        self._on_error("texture", supplied_args, result[0])
        return result

    def diplane_helix(
        self,
        LL: str,
        RR: str,
        SLC_par: str,
        diplane: str,
        helix: str,
        MLI_par: str,
        rlks,
        azlks,
        loff=None,
        nlines=None,
        scale=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["diplane_helix"] += 1

        if LL is not None:
            result = self._validate(
                "diplane_helix",
                LL == "-" or Path(LL).exists(),
                result,
                f"LL path does not exist ({LL})",
            )
        if RR is not None:
            result = self._validate(
                "diplane_helix",
                RR == "-" or Path(RR).exists(),
                result,
                f"RR path does not exist ({RR})",
            )
        if SLC_par is not None:
            result = self._validate(
                "diplane_helix",
                SLC_par == "-" or Path(SLC_par).exists(),
                result,
                f"SLC_par path does not exist ({SLC_par})",
            )
        if diplane is not None and diplane != "-":
            Path(diplane).touch()
        if helix is not None and helix != "-":
            Path(helix).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if self._wraps is not None:
            result = self._wraps.diplane_helix(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "diplane_helix", supplied_args, result[0])
        )
        self._on_error("diplane_helix", supplied_args, result[0])
        return result

    def lin_comb_ref(
        self,
        f1,
        f2,
        constant,
        factor1,
        factor2,
        f_out: str,
        width,
        roff=None,
        loff=None,
        nr=None,
        nl=None,
        zflag=None,
    ):
        supplied_args = locals()
        result = (0, "", "")

        self.call_count["lin_comb_ref"] += 1

        if f_out is not None and f_out != "-":
            Path(f_out).touch()
        valid_values = [0, 1] + [None]
        result = self._validate(
            "lin_comb_ref",
            zflag == "-" or zflag in valid_values,
            result,
            f"zflag is not a valid value (expects: {valid_values}, got: {zflag})",
        )
        if self._wraps is not None:
            result = self._wraps.lin_comb_ref(*supplied_args)

        self.call_sequence.append(
            PyGammaCall("LAT", "lin_comb_ref", supplied_args, result[0])
        )
        self._on_error("lin_comb_ref", supplied_args, result[0])
        return result
